'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsBase64 = require('js-base64');
var mitt = require('mitt');
var debug = require('debug');
var axios = require('axios');
var HttpAgent = require('agentkeepalive');
var io = require('socket.io-client');
var uuid$1 = require('react-native-uuid');
var hash = require('object-hash');
var Hls = require('hls.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var mitt__default = /*#__PURE__*/_interopDefaultLegacy(mitt);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);
var HttpAgent__default = /*#__PURE__*/_interopDefaultLegacy(HttpAgent);
var io__default = /*#__PURE__*/_interopDefaultLegacy(io);
var uuid__default = /*#__PURE__*/_interopDefaultLegacy(uuid$1);
var hash__default = /*#__PURE__*/_interopDefaultLegacy(hash);
var Hls__default = /*#__PURE__*/_interopDefaultLegacy(Hls);

const FileType = Object.freeze({
    FILE: 'file',
    IMAGE: 'image',
    VIDEO: 'video',
});
const VideoResolution = Object.freeze({
    '1080P': '1080p',
    '720P': '720p',
    '480P': '480p',
    '360P': '360p',
    ORIGINAL: 'original',
});
const VideoTranscodingStatus = Object.freeze({
    UPLOADED: 'uploaded',
    TRANSCODING: 'transcoding',
    TRANSCODED: 'transcoded',
    TRANSCODE_FAILED: 'transcodeFailed',
});
const VideoSize = Object.freeze({
    LOW: 'low',
    MEDIUM: 'medium',
    HIGH: 'high',
    ORIGINAL: 'original',
});
exports.FileAccessTypeEnum = void 0;
(function (FileAccessTypeEnum) {
    FileAccessTypeEnum["PUBLIC"] = "public";
    FileAccessTypeEnum["NETWORK"] = "network";
})(exports.FileAccessTypeEnum || (exports.FileAccessTypeEnum = {}));

const CommunityPostSettings = Object.freeze({
    ONLY_ADMIN_CAN_POST: 'ONLY_ADMIN_CAN_POST',
    ADMIN_REVIEW_POST_REQUIRED: 'ADMIN_REVIEW_POST_REQUIRED',
    ANYONE_CAN_POST: 'ANYONE_CAN_POST',
});
const CommunityPostSettingMaps = Object.freeze({
    ONLY_ADMIN_CAN_POST: {
        needApprovalOnPostCreation: false,
        onlyAdminCanPost: true,
    },
    ADMIN_REVIEW_POST_REQUIRED: {
        needApprovalOnPostCreation: true,
        onlyAdminCanPost: false,
    },
    ANYONE_CAN_POST: {
        needApprovalOnPostCreation: false,
        onlyAdminCanPost: false,
    },
});
const DefaultCommunityPostSetting = 'ONLY_ADMIN_CAN_POST';

const ContentFeedType = Object.freeze({
    STORY: 'story',
    CLIP: 'clip',
    CHAT: 'chat',
    POST: 'post',
    MESSAGE: 'message',
});

const MessageContentType = Object.freeze({
    TEXT: 'text',
    IMAGE: 'image',
    FILE: 'file',
    VIDEO: 'video',
    AUDIO: 'audio',
    CUSTOM: 'custom',
});

const PostContentType = Object.freeze({
    TEXT: 'text',
    IMAGE: 'image',
    FILE: 'file',
    VIDEO: 'video',
    LIVESTREAM: 'liveStream',
    POLL: 'poll',
});

function getVersion() {
    try {
        // the string ''v7.3.0-cjs'' should be replaced by actual value by @rollup/plugin-replace
        return 'v7.3.0-cjs';
    }
    catch (error) {
        return '__dev__';
    }
}
const VERSION = getVersion();

const COLLECTION_DEFAULT_PAGINATION_LIMIT = 5;
const COLLECTION_DEFAULT_CACHING_POLICY = 'cache_then_server';
const ENABLE_CACHE_MESSAGE = 'For using Live Collection feature you need to enable Cache!';
const LIVE_OBJECT_ENABLE_CACHE_MESSAGE = 'For using Live Object feature you need to enable Cache!';
const UNSYNCED_OBJECT_CACHED_AT_MESSAGE = 'Observing unsynced object is not supported by Live Object.';
const UNSYNCED_OBJECT_CACHED_AT_VALUE = -5;
const SECOND$1 = 1000;
const MINUTE = 60 * SECOND$1;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
const YEAR = 365 * DAY;
const ACCESS_TOKEN_WATCHER_INTERVAL = 10 * MINUTE;

// cache constants
const CACHE_KEY_GET = 'get';
const CACHE_KEY_TOMBSTONE = 'dead';
const CACHE_SHORTEN_LIFESPAN = 2 * SECOND$1;
const CACHE_LIFESPAN = 1 * MINUTE; // 1 minute
const CACHE_LIFESPAN_TOMBSTONE = 3 * MINUTE; // 3 minutes
/**
 * Shallow-clones an object and sort its keys
 *
 * @param source a plain object to clone
 * @returns a clone of source, with keys sorted with default javascript sorting
 *
 * @category Cache
 * @hidden
 */
const normalize = (source) => Object.keys(source)
    .sort()
    .reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: source[key] })), {});
/**
 * Encodes a given {@link Amity.CacheKey} to a plain string
 *
 * @param key the key to encode
 * @returns an encoded string
 *
 * @category Cache
 * @hidden
 */
const encodeKey = (key) => JSON.stringify(key, (_, val) => (typeof val === 'object' ? normalize(val) : val));
/**
 * Decodes a string back into a {@link Amity.CacheKey}

 *
 * @param key the string key to decode
 * @returns a plain Amity.CacheKey object.
 *
 * @category Cache
 * @hidden
 */
const decodeKey = (key) => JSON.parse(key);
/**
 * Performs a recursive partial deep equal check on two objects.
 *
 * @param predicate the reference object containing the partial information
 * @param candidate the object to check against
 * @returns true if the candidate contains all the values of the predicate
 *
 * @category Cache
 */
const partialMatch = (predicate, candidate) => {
    if (predicate === candidate)
        return true;
    // if one or the other is nullish, there can't be equality
    if (!predicate || !candidate)
        return false;
    // we only perform recursive check on objects
    if (typeof predicate !== 'object') {
        return false;
    }
    // recursively call for partial match based on the predicate
    return Object.keys(predicate).every(key => partialMatch(predicate[key], candidate[key]));
};
/**
 * checks if passed error code is included in
 * Tombstone errors list
 *
 * @param errorCode as {@link Amity.ServerError}
 * @returns success boolean if the given errorCode
 * is included in Tombstone errors list
 *
 * @category Cache
 */
const checkIfShouldGoesToTombstone = (errorCode) => [400400 /* Amity.ServerError.ITEM_NOT_FOUND */, 400300 /* Amity.ServerError.FORBIDDEN */].includes(errorCode);

/**
 * Type guard to find if the a given decoded backend token uses "skip" pagination style
 *
 * @param json any json object as extracted from the backend
 * @returns success boolean if the token has either "skip" or "limit" props
 *
 * @hidden
 */
const isSkip = (json) => ['skip'].some(prop => prop in json);
/**
 * Type guard to find if the a given decoded backend token uses "after/before" pagination style
 *
 * @param json any json object as extracted from the backend
 * @returns success boolean if the token has either "after" or "before" props
 *
 * @hidden
 */
const isAfterBefore = (json) => ['after', 'before', 'first', 'last', 'limit'].some(prop => prop in json);
/**
 * Type guard to find if the a given decoded backend token uses v4 or newer "after/before" pagination style
 *
 * @param json any json object as extracted from the backend
 * @returns success boolean if the token has either "after" or "before" props
 *
 * @hidden
 */
const isAfterBeforeRaw = (json) => 'limit' in json;
/**
 * Type guard to find if the a given object is wrapped around Amity.Paged<>
 *
 * @param payload any object as passed from query functions
 * @returns success boolean if the object is an object shaped as { data: T[] } & Amity.Pages
 *
 * @hidden
 */
const isPaged = (payload) => {
    return ((payload === null || payload === void 0 ? void 0 : payload.hasOwnProperty('data')) &&
        (payload === null || payload === void 0 ? void 0 : payload.hasOwnProperty('nextPage')) &&
        (payload === null || payload === void 0 ? void 0 : payload.hasOwnProperty('prevPage')));
};
/**
 * Converts a paging object into a b64 string token
 *
 * @param paging the sdk-friendly paging object
 * @param style the style of token to produce
 * @returns a backend's b64 encoded token
 *
 * @hidden
 */
const toToken = (paging, style) => {
    var _a;
    if (!paging || !Object.keys(paging).length)
        return;
    let payload = {};
    // TODO: refactor this clean
    if (style === 'skiplimit') {
        payload = {
            skip: (_a = paging.after) !== null && _a !== void 0 ? _a : 0,
            limit: paging.limit,
        };
    }
    else if (style === 'afterbefore' && isAfterBefore(paging)) {
        /*
          Caution: this testing style is only valid because
          our backend expects nothing else than a number as
          "before" or "after" value. if that would change,
          we'd need to move toward a more simple: `!paging.before`
        */
        if (paging === null || paging === void 0 ? void 0 : paging.before) {
            payload = Object.assign(Object.assign({}, payload), { before: paging.before });
        }
        if (paging === null || paging === void 0 ? void 0 : paging.after) {
            payload = Object.assign(Object.assign({}, payload), { after: paging.after });
        }
        if (!Number.isNaN(Number(paging === null || paging === void 0 ? void 0 : paging.limit))) {
            payload = Object.assign(Object.assign({}, payload), { limit: paging.limit });
        }
    }
    else if (style === 'afterbeforeraw') {
        payload = paging;
    }
    // avoid sending {} as it seems backend flips when we do
    if (!Object.keys(payload).length)
        return;
    // don't try catch, let it throw
    return jsBase64.encode(JSON.stringify(payload));
};
/**
 * Converts a b64 string token into a paging object
 *
 * @param token the backend's b64 encoded token
 * @returns a sdk-friendly paging object
 *
 * @hidden
 */
const toPage = (token) => {
    if (!token)
        return undefined;
    // don't try catch, let it throw
    const json = JSON.parse(jsBase64.decode(token));
    if (isSkip(json)) {
        return {
            after: json.skip,
            limit: json.limit,
        };
    }
    if (isAfterBefore(json)) {
        if ('before' in json) {
            return {
                before: json.before,
                limit: json.last,
            };
        }
        if ('after' in json) {
            return {
                after: json.after,
                limit: json.first,
            };
        }
    }
    return undefined;
};
/**
 * Converts a b64 string token into a paging object
 *
 * @param token the backend's b64 encoded token
 * @returns a sdk-friendly paging object
 *
 * @hidden
 */
const toPageRaw = (token) => {
    if (!token)
        return undefined;
    // don't try catch, let it throw
    const json = JSON.parse(jsBase64.decode(token));
    if (isAfterBeforeRaw(json)) {
        return json;
    }
    return undefined;
};

/* eslint-disable no-use-before-define */
/**
 * Type guard to check and cast that a given async function is has the ".locally" property
 *
 * @param func any SDK APi function
 * @returns success boolean if the function has a 'locally' twin
 *
 * @hidden
 */
const isFetcher = (func) => 'locally' in func;
/**
 * Type guard to check and cast that a given async function is has the ".optimistically" property
 *
 * @param func any SDK APi function
 * @returns success boolean if the function has an 'optimistically' twin
 *
 * @hidden
 */
const isMutator = (func) => 'optimistically' in func;
/**
 * Type guard to check and cast that a given async function is has
 * the ".locally" or ".optimistically" property
 *
 * @param func any SDK APi function
 * @returns success boolean if the function has an offline twin
 *
 * @hidden
 */
const isOffline = (func) => isFetcher(func) || isMutator(func);
/**
 * Type guard to check and cast that a given object has the "cachedAt" property
 *
 * @param model any object to check on
 * @returns success boolean if the object has property "cachedAt"
 *
 * @hidden
 */
const isCachable = (model) => model === null || model === void 0 ? void 0 : model.hasOwnProperty('cachedAt');
/**
 * Checks if a model is considered local (cachedAt === -1)
 *
 * @param model any cachable object to check
 * @returns success boolean if the object is marked as local
 *
 * @hidden
 */
const isLocal = (model) => {
    return isCachable(model) && (model === null || model === void 0 ? void 0 : model.cachedAt) === -1;
};
/**
 * Checks if a model is considered fresh
 *
 * @param model any cachable object to check
 * @param lifeSpan the supposedly duration for which the object is considered synced
 * @returns success boolean if the object is below the given lifespan
 *
 * @hidden
 */
const isFresh = (model, lifeSpan = CACHE_LIFESPAN) => {
    var _a;
    return Date.now() - ((_a = model === null || model === void 0 ? void 0 : model.cachedAt) !== null && _a !== void 0 ? _a : 0) <= lifeSpan;
};
/**
 * ```js
 * import { createQuery, getUser } from '@amityco/ts-sdk'
 * const query = createQuery(getUser, 'foobar')
 * ```
 *
 * Creates a wrapper for the API call you wish to call.
 * This wrapper is necessary to create for optimistically calls
 *
 *
 * @param func A compatible API function from the ts sdk
 * @param args The arguments to pass to the function passed as `fn`
 * @returns A wrapper containing both the function and its future arguments
 *
 * @category Query
 */
const createQuery = (func, ...args) => ({ func, args });
/**
 * ```js
 * import { queryOptions } from '@amityco/ts-sdk'
 * const options = queryOptions('no_fetch', lifeSpan)
 * ```
 *
 * Creates a query options object based on the query policy passed
 *
 * @param policy The policy to apply to a query
 * @returns A properly set query options object
 *
 * @category Query
 */
const queryOptions = (policy, lifeSpan = CACHE_LIFESPAN) => {
    if (policy === 'cache_only')
        return { lifeSpan: Infinity };
    return { lifeSpan: lifeSpan < CACHE_LIFESPAN ? CACHE_LIFESPAN : lifeSpan };
};
/**
 * ```js
 * import { createQuery, getUser, runQuery } from '@amityco/ts-sdk'
 * const query = createQuery(getUser, client, 'foobar')
 * runQuery(query,  user => console.log(user))
 * ```
 *
 * Calls an API function wrapped around a Amity.Query, and executes the callback whenever
 * a value is available. The value can be picked either from the local cache and/or
 * from the server afterwards depending on the query options passed
 *
 * @param query A query object wrapping the call to be made
 * @param callback A function to execute when a value is available
 * @param options the query options
 *
 * @category Query
 */
const runQuery = ({ func, args }, callback, options = queryOptions('cache_then_server')) => {
    let local;
    const { lifeSpan } = queryOptions('cache_then_server', options.lifeSpan);
    // offline first
    if (isOffline(func)) {
        try {
            local = isMutator(func) ? func.optimistically(...args) : func.locally(...args);
        }
        catch (error) {
            callback === null || callback === void 0 ? void 0 : callback(createSnapshot(undefined, {
                origin: 'local',
                loading: false,
                error,
            }));
        }
        const shouldAbort = isCachable(local) && isFresh(local, lifeSpan);
        callback === null || callback === void 0 ? void 0 : callback(createSnapshot(local, {
            origin: 'local',
            loading: !(isFetcher(func) && shouldAbort),
        }));
        if (shouldAbort)
            return;
    }
    else {
        callback === null || callback === void 0 ? void 0 : callback(createSnapshot(undefined, {
            origin: 'local',
            loading: true,
        }));
    }
    func(...args)
        .then(fresh => {
        callback === null || callback === void 0 ? void 0 : callback(createSnapshot(fresh, {
            origin: 'server',
            loading: false,
        }));
    })
        .catch(error => {
        callback === null || callback === void 0 ? void 0 : callback(createSnapshot(undefined, {
            origin: 'server',
            loading: false,
            error,
        }));
    });
};
// eslint-disable-next-line no-redeclare
function createSnapshot(data, options) {
    if (isPaged(data) || isCachable(data))
        return Object.assign(Object.assign({}, options), data);
    return Object.assign(Object.assign({}, options), { data });
}

/** @hidden */
const idResolvers = {
    user: ({ userId }) => userId,
    file: ({ fileId }) => fileId,
    role: ({ roleId }) => roleId,
    channel: ({ channelInternalId }) => channelInternalId,
    subChannel: ({ subChannelId }) => subChannelId,
    channelUsers: ({ channelId, userId }) => `${channelId}#${userId}`,
    message: ({ messageId, referenceId }) => referenceId !== null && referenceId !== void 0 ? referenceId : messageId,
    messagePreviewChannel: ({ channelId }) => `${channelId}`,
    messagePreviewSubChannel: ({ subChannelId }) => `${subChannelId}`,
    channelUnreadInfo: ({ channelId }) => channelId,
    subChannelUnreadInfo: ({ subChannelId }) => subChannelId,
    channelUnread: ({ channelId }) => channelId,
    channelMarker: ({ entityId, userId }) => `${entityId}#${userId}`,
    subChannelMarker: ({ entityId, feedId, userId }) => `${entityId}#${feedId}#${userId}`,
    messageMarker: ({ feedId, contentId, creatorId }) => `${feedId}#${contentId}#${creatorId}`,
    feedMarker: ({ feedId, entityId }) => `${feedId}#${entityId}`,
    userMarker: ({ userId }) => userId,
    community: ({ communityId }) => communityId,
    category: ({ categoryId }) => categoryId,
    communityUsers: ({ communityId, userId }) => `${communityId}#${userId}`,
    post: ({ postId }) => postId,
    comment: ({ commentId }) => commentId,
    commentChildren: ({ commentId }) => commentId,
    poll: ({ pollId }) => pollId,
    reaction: ({ referenceType, referenceId }) => `${referenceType}#${referenceId}`,
    reactor: ({ reactionId }) => reactionId,
    stream: ({ streamId }) => streamId,
    streamModeration: ({ streamId }) => streamId,
    follow: ({ from, to }) => `${from}#${to}`,
    followInfo: ({ userId }) => userId,
    followCount: ({ userId }) => userId,
    feed: ({ targetId, feedId }) => `${targetId}#${feedId}`,
    story: ({ referenceId }) => referenceId,
    storyTarget: ({ targetId }) => targetId,
    ad: ({ adId }) => adId,
    advertiser: ({ advertiserId }) => advertiserId,
    pin: ({ placement, referenceId }) => `${placement}#${referenceId}`,
    pinTarget: ({ targetId }) => targetId,
    notificationTrayItem: ({ _id }) => _id,
    notificationTraySeen: ({ userId }) => userId,
};
/**
 * Retrieve the id resolver matching a domain name
 *
 * @param name the domain name for the resolve
 * @returns an idResolver function for the given domain name
 */
const getResolver = (name) => idResolvers[name];

/**
 * A map of v3 response keys to a store name.
 * @hidden
 */
const PAYLOAD2MODEL = {
    users: 'user',
    files: 'file',
    roles: 'role',
    stories: 'story',
    storyTargets: 'storyTarget',
    channels: 'channel',
    messageFeeds: 'subChannel',
    channelUsers: 'channelUsers',
    messages: 'message',
    messagePreviewChannel: 'messagePreviewChannel',
    messagePreviewSubChannel: 'messagePreviewSubChannel',
    channelUnreadInfo: 'channelUnreadInfo',
    subChannelUnreadInfo: 'subChannelUnreadInfo',
    userEntityMarkers: 'channelMarker',
    userFeedMarkers: 'subChannelMarker',
    contentMarkers: 'messageMarker',
    feedMarkers: 'feedMarker',
    userMarkers: 'userMarker',
    communities: 'community',
    categories: 'category',
    communityUsers: 'communityUsers',
    posts: 'post',
    postChildren: 'post',
    comments: 'comment',
    commentChildren: 'comment',
    polls: 'poll',
    reactors: 'reactor',
    reactions: 'reaction',
    videoStreamings: 'stream',
    videoStreamModerations: 'streamModeration',
    follows: 'follow',
    followCounts: 'followCount',
    feeds: 'feed',
    ads: 'ad',
    advertisers: 'advertiser',
    pinTargets: 'pinTarget',
    pins: 'pin',
    notificationTrayItems: 'notificationTrayItem',
};
/** hidden */
const isOutdated = (prevData, nextData) => {
    if ('updatedAt' in nextData && 'updatedAt' in nextData) {
        return new Date(nextData.updatedAt) < new Date(prevData.updatedAt);
    }
    return false;
};
/** hidden */
function getFutureDate(date = new Date().toISOString()) {
    return new Date(new Date(date).getTime() + 1).toISOString();
}

/* eslint-disable max-classes-per-file */
/**
 * Generic ASC error
 * @category Errors
 */
class ASCError extends Error {
    /**
     * @param message A custom error message
     * @param code A normalized error code
     * @param level A normalized failure level descriptor
     */
    constructor(message, code, level) {
        super(`Amity SDK (${code}): ${message}`);
        this.code = code;
        this.level = level;
        this.type = 'ASC';
        this.timestamp = Date.now();
        if (Error.captureStackTrace)
            Error.captureStackTrace(this, ASCError);
    }
}
/**
 * API level error
 * @category Errors
 */
class ASCApiError extends ASCError {
    /**
     * @param code A normalized error code
     * @param level A normalized failure level descriptor
     */
    // eslint-disable-next-line no-useless-constructor
    constructor(message, code, level) {
        super(message, code, level);
    }
}
/**
 * Unexpected error
 * @category Errors
 */
class ASCUnknownError extends ASCError {
    /**
     * @param code A normalized error code
     * @param level A normalized failure level descriptor
     */
    constructor(code = 800000 /* Amity.ClientError.UNKNOWN_ERROR */, level = "fatal" /* Amity.ErrorLevel.FATAL */) {
        super('Unexpected error', code, level);
    }
}
/**
 * Network related error
 * @category Errors
 */
class ASCConnectionError extends ASCError {
    /**
     * @param message A custom error message
     */
    constructor(event, message = 'SDK client is having connection issues') {
        super(`${message} (${event})`, event === 'disconnected'
            ? 800211 /* Amity.ClientError.DISCONNECTED */
            : 800210 /* Amity.ClientError.CONNECTION_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
        this.event = event;
    }
}

let activeClient = null;
/**
 * Get the active client
 *
 * @returns the active client instance
 *
 * @hidden
 */
const getActiveClient = () => {
    if (!activeClient) {
        throw new ASCError('There is no active client', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "fatal" /* Amity.ErrorLevel.FATAL */);
    }
    return activeClient;
};
/**
 * Sets the active client
 *
 * @param client the client to assume as currently active client
 *
 * @hidden
 */
const setActiveClient = (client) => {
    activeClient = client;
};

/**
 * ```js
 * import { enableCache } from '@amityco/ts-sdk'
 * enableCache()
 * ```
 *
 * Adds a new {@link Amity.Cache} object to
 * an {@link Amity.Client} instance
 *
 * @param prevState a previous state of cache instance (useful for SSR)
 * @param persistIf a function to determine if an entry inserted in cache
 * is destined to be also saved in the persistent storage when
 * calling {@link backupCache}
 *
 * @category Cache API
 */
const enableCache = (prevState = {}, persistIf) => {
    const client = getActiveClient();
    if (client.cache)
        return;
    client.log('cache/api/enableCache');
    client.cache = { data: prevState, persistIf };
};

/**
 * ```js
 * import { disableCache } from '@amityco/ts-sdk'
 * disableCache()
 * ```
 *
 * Wipes the existing {@link Amity.Cache} object attached to
 * an {@link Amity.Client} instance
 *
 * @category Cache API
 */
const disableCache = () => {
    const client = getActiveClient();
    if (!client.cache)
        return;
    client.log('cache/api/disableCache');
    // we do this so that testing if cache is enabled
    // is only `if (client.cache)
    delete client.cache;
};

/**
 * ```js
 * import { restoreCache } from '@amityco/ts-sdk'
 * const success = await restoreCache()
 * ```
 *
 * Reads a previously saved {@link Amity.Cache} from a persistent storage,
 * and inserts it into the current {@link Amity.Cache} instance.
 *
 * The strategy for persistent storage will depend on the runtime,
 * which is supported by @react-native-async-storage/async-storage.
 *
 * The current userId will be appended to the given storageKey to ensures
 * the cached data concerns only the current user.
 *
 * @param storageKey the name of the persistent storage
 * @returns a success boolean if the cache was dumped to persistent storage
 *
 * @category Cache API
 */
const restoreCache = async (storageKey = 'amitySdk') => {
    var _a;
    const client = getActiveClient();
    if (!client.cache)
        return false;
    client.log('cache/api/restoreCache', { storageKey });
    const serializedData = localStorage
        ? (_a = (await localStorage.getItem(`${storageKey}#${client.userId}`))) !== null && _a !== void 0 ? _a : '{}'
        : '{}';
    let cache = {};
    try {
        cache = JSON.parse(serializedData);
    }
    catch (err) {
        //
    }
    // current cache should override. in case there's something fresher.
    client.cache.data = Object.assign(Object.assign({}, cache), client.cache.data);
    return true;
};

/**
 * ```js
 * import { backupCache } from '@amityco/ts-sdk'
 * const success = await backupCache()
 * ```
 *
 * Writes the {@link Amity.Cache} to a persistent storage.
 *
 * The strategy for persistent storage will depend on the runtime,
 * which is supported by @react-native-async-storage/async-storage.
 *
 * The current userId will be appended to the given storageKey to avoid
 * collision between multiple client instances over time.
 *
 * @param storageKey the name of the persistent storage
 * @param persistIf a custom function to define the persistence policy. Default
 * will check the value of {@link Amity.CacheEntry["offline"]}, which can be
 * defined globally when customizing {@link Amity.Cache["persistIf"]}
 * @returns a success boolean if the cache was dumped to persistent storage
 *
 * @category Cache API
 */
const backupCache = async (storageKey = 'amitySdk', persistIf = (entry) => entry.offline) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/backupCache', { storageKey });
    // prepare a subset of the cache where only
    // objects to backup are there
    const offlineEntries = Object.fromEntries(Object.entries(cache.data).filter(([_, entry]) => persistIf(entry)));
    // nothing to backup, abort
    if (!Object.keys(offlineEntries).length)
        return false;
    if (localStorage) {
        await localStorage.setItem(`${storageKey}#${userId}`, JSON.stringify(offlineEntries));
    }
    return true;
};

/**
 * ```js
 * import { wipeCache } from '@amityco/ts-sdk'
 * const success = await wipeCache()
 * ```
 *
 * Wipes a persistent storage for the current {@link Amity.Cache} instance.
 *
 * The strategy for persistent storage will depend on the runtime,
 * which is supported by @react-native-async-storage/async-storage.
 *
 * The current userId will be appended to the given storageKey to avoid
 * collision between multiple client instances over time.
 *
 * @param storageKey the name of the persistent storage
 * @returns a success boolean if the persistent cache was wiped.
 *
 * @category Cache API
 */
const wipeCache = async (storageKey = 'amitySdk') => {
    const { log, cache, userId } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/wipeCache', { storageKey });
    cache.data = {};
    if (localStorage) {
        await localStorage.setItem(`${storageKey}#${userId}`, '{}');
    }
    return true;
};

/**
 * ```js
 * import { queryCache } from '@amityco/ts-sdk'
 * const entries = queryCache(["user"])
 * ```
 *
 * Retrieves a list of {@link Amity.CacheEntry} objects matching a
 * partial {@link Amity.CacheKey}. The cache entries can't be typed,
 * but the expected returned type can be passed manually.
 *
 * @param partialKey the partial key matching the objects to retrieve from cache
 * @returns the matching cache entries, or empty array.
 *
 * @category Cache API
 */
const queryCache = (key) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return;
    log('cache/api/queryCache', { key });
    return Object.keys(cache.data)
        .filter(stringKey => {
        const decodedKey = decodeKey(stringKey);
        return partialMatch(key, decodedKey);
    })
        .map(stringKey => cache.data[stringKey]);
};

/**
 * ```js
 * import { pullFromCache } from '@amityco/ts-sdk'
 * const user = pullFromCache<Amity.User>(["user", "foobar"])
 * ```
 *
 * Retrieves a {@link Amity.CacheEntry} object matching a given
 * {@link Amity.CacheKey}. The cache entry is not typed, so the
 * expected returned type must be passed manually.
 *
 * @param key the key matching the object to retrieve from cache
 * @returns the matching cache entry, or undefined.
 *
 * @category Cache API
 */
const pullFromCache = (key) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return;
    log('cache/api/pullFromCache', key);
    const str = encodeKey(key);
    return cache.data[str] ? cache.data[str] : undefined;
};

/**
 * ```js
 * import { pushToCache } from '@amityco/ts-sdk'
 * pushToCache<Amity.InternalUser>(["user", "foobar"], user)
 * ```
 *
 * Saves any provided value as {@link Amity.CacheEntry} for the matching {@link Amity.CacheKey}
 *
 * @param key the key to save the object to
 * @param data the object to save
 * @param options customisation object around cache behavior (default gives a 2mn lifespan)
 * @returns a success boolean if the object was saved in cache
 *
 * @category Cache API
 */
const pushToCache = (key, data, options = { cachedAt: Date.now() }) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/pushToCache', { key, data, options });
    // if consumer did not pass offline but a offline policy is
    // defined, use the fn to determine if the object needs to
    // be saved in persistent storage or not.
    if (!(options === null || options === void 0 ? void 0 : options.hasOwnProperty('offline')) && cache.persistIf) {
        // eslint-disable-next-line no-param-reassign
        options.offline = cache.persistIf(key, data);
    }
    const encodedKey = encodeKey(key);
    cache.data[encodedKey] = Object.assign({ key, data }, options);
    return true;
};

/**
 * ```js
 * import { mergeInCache } from '@amityco/ts-sdk'
 *
 * mergeInCache(
 *   ["foo", "bar"],
 *   (oldVal) => ({ ...oldVal, ...newVal }).
 * )
 * ```
 *
 * Merges a new {@link Amity.Cache} object to an {@link Amity.Client} instance
 *
 * @param key the key matching the object to retrieve from cache
 * @param mutation either a plain object to shallow merge, or a function.
 * @returns a success boolean if the object was updated
 *
 * @category Cache API
 */
const mergeInCache = (key, mutation, options) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/mergeInCache', { key, mutation });
    const oldVal = pullFromCache(key);
    if (!oldVal)
        return false;
    const newVal = typeof mutation === 'function' ? mutation(oldVal.data) : Object.assign(Object.assign({}, oldVal.data), mutation);
    if (isOutdated(oldVal.data, newVal)) {
        return false;
    }
    pushToCache(key, newVal, options);
    return true;
};

/**
 * ```js
 * import { upsertInCache } from '@amityco/ts-sdk'
 * upsertInCache<Amity.InternalUser>(["user", "foobar"], user)
 * ```
 *
 * Insert or update any provided value as {@link Amity.CacheEntry} for
 * the matching {@link Amity.CacheKey}
 *
 * @param key the key to save the object to
 * @param data the object to save
 * @param options customisation object around cache behavior (default gives a 2mn lifespan)
 * @returns a success boolean if the object was saved in cache
 *
 * @category Cache API
 * @hidden
 */
const upsertInCache = (key, data, options = { cachedAt: Date.now() }) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/upsertInCache', { key, data, options });
    const cached = pullFromCache(key);
    return cached ? mergeInCache(key, data, options) : pushToCache(key, data, options);
};

/**
 * ```js
 * import { dropFromCache } from '@amityco/ts-sdk'
 * const success = dropFromCache(['user', 'foobar'])
 * ```
 *
 * Removes an existing {@link Amity.CacheEntry} from the {@link Amity.Client}'s
 * {@link Amity.Cache} from a given {@link Amity.CacheKey}
 *
 * @param key The key of the object to delete
 * @param exact If false, the function will delete all keys satisfying the given key
 * @returns A success boolean if the object was deleted
 *
 * @category Cache API
 */
const dropFromCache = (key, exact = false) => {
    const { log, cache } = getActiveClient();
    if (!cache)
        return false;
    log('cache/api/dropFromCache', { key, exact });
    if (!exact) {
        return Object.keys(cache.data)
            .map(stringKey => decodeKey(stringKey))
            .filter(candidate => partialMatch(key, candidate))
            .map(filteredKey => dropFromCache(filteredKey, true))
            .every(returned => returned);
    }
    const encodedKey = encodeKey(key);
    if (encodedKey in cache.data) {
        delete cache.data[encodedKey];
        return true;
    }
    return false;
};

// Note:
// this file should contain a suite of filtering utilities to help the
// local version of the query functions.
/**
 * Filter a given collection with strict equality against a param
 *
 * @param collection the collection to filter
 * @param key the key of the collection's items to challenge
 * @param value the expected value
 * @returns a filtered collection with items only matching the criteria
 *
 * @hidden
 */
const filterByPropEquality = (collection, key, value) => value !== undefined
    ? collection.filter(item => JSON.stringify(item[key]) === JSON.stringify(value))
    : collection;
const filterByStringComparePartially = (collection, key, value) => value !== undefined
    ? collection.filter(item => {
        if (typeof item[key] === 'string' && typeof value === 'string') {
            return String(item[key]).toLowerCase().match(value.toLowerCase());
        }
        return false;
    })
    : collection;
const filterByPropInclusion = (collection, key, value) => (value !== undefined ? collection.filter(item => value.includes(item[key])) : collection);
const filterByPropIntersection = (collection, key, values) => {
    if (!(values === null || values === void 0 ? void 0 : values.length))
        return collection;
    return collection.filter(item => Array.isArray(item[key]) && values.some(value => item[key].includes(value)));
};
/**
 * Filter a channel collection by membership of the userId
 *
 * @param collection the channel collection to filter
 * @param membership the membership to be filtered by
 * @param userId user id to be filtered by
 * @returns a filtered collection with items only matching the criteria
 *
 * @hidden
 */
const filterByChannelMembership = (collection, membership, userId) => {
    if (membership === 'all') {
        return collection;
    }
    return collection.filter(c => {
        var _a;
        // if channel is a community, only member user must receive realtime event
        if (c.type === 'community')
            return true;
        // get resolver for the channel by user
        const channelUserCacheKey = getResolver('channelUsers')({
            channelId: c.channelPublicId,
            userId,
        });
        const channelUser = (_a = pullFromCache([
            'channelUsers',
            'get',
            channelUserCacheKey,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (membership === 'member') {
            return channelUser && channelUser.membership !== 'none';
        }
        // only membership value remainging is 'notMember'
        return !channelUser || channelUser.membership === 'none';
    });
};
/**
 * Filter a channel collection by membership of the userId
 *
 * @param collection the channel collection to filter
 * @param feedType to be filtered by
 * @returns a filtered collection with items only matching the criteria
 *
 * @hidden
 */
const filterByFeedType = (collection, feedType) => {
    /*
     * It is possible that the targetId & feedId are the same for most of the posts
     * But since cache is in-memory, i've avoided memoizing, to avoid premature
     * optimization. Can be revisited if performance issues arise
     */
    return collection.filter(({ targetId, feedId }) => {
        var _a;
        const feed = (_a = pullFromCache([
            'feed',
            'get',
            getResolver('feed')({ targetId, feedId }),
        ])) === null || _a === void 0 ? void 0 : _a.data;
        return feed && feed.feedType === feedType;
    });
};
/**
 * Filter a community collection by membership of the userId
 *
 * @param collection the community to filter
 * @param membership the membership to be filtered by
 * @param userId user id to be filtered by
 * @returns a filtered collection with items only matching the criteria
 *
 * @hidden
 */
const filterByCommunityMembership = (collection, membership, userId) => {
    if (membership === 'all') {
        return collection;
    }
    return collection.filter(c => {
        var _a;
        // get resolver for the community by user
        const communityUserCacheKey = getResolver('communityUsers')({
            communityId: c.communityId,
            userId,
        });
        const communityUser = (_a = pullFromCache([
            'communityUsers',
            'get',
            communityUserCacheKey,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (membership === 'member') {
            return communityUser && communityUser.communityMembership === 'member';
        }
        // only membership value remainging is 'notMember'
        return !communityUser || communityUser.communityMembership !== 'none';
    });
};
/**
 * Filter a post collection by dataType
 *
 * @param collection the post to filter
 * @param dataTypes of the post to be filtered by
 * @returns a filtered collection with items only matching the criteria
 *
 * @hidden
 */
const filterByPostDataTypes = (collection, dataTypes) => {
    return collection.reduce((acc, post) => {
        var _a;
        // Check dataType for current post
        if (dataTypes === null || dataTypes === void 0 ? void 0 : dataTypes.includes(post.dataType)) {
            return [...acc, post];
        }
        if (((post === null || post === void 0 ? void 0 : post.children) || []).length > 0) {
            const childPost = (_a = pullFromCache(['post', 'get', post.children[0]])) === null || _a === void 0 ? void 0 : _a.data;
            if (!(dataTypes === null || dataTypes === void 0 ? void 0 : dataTypes.includes(childPost === null || childPost === void 0 ? void 0 : childPost.dataType)))
                return [...acc, post];
            return acc;
        }
        return acc;
    }, []);
};
/**
 * Filter a collection by search term
 * Check if userId matches first if not filter by displayName
 *
 * @param collection to be filtered
 * @param searchTerm to filter collection by
 * @returns a filtered collection with items only matching the search term
 *
 * @hidden
 */
const filterBySearchTerm = (collection, searchTerm) => {
    /*
     * Search term should match regardless of the case.
     * Hence, the flag "i", is passed to the created regex
     */
    const containsMatcher = new RegExp(searchTerm, 'i');
    return collection.filter(m => {
        var _a;
        if (m.userId.match(containsMatcher))
            return true;
        return m.user && ((_a = m.user.displayName) === null || _a === void 0 ? void 0 : _a.match(containsMatcher));
    });
};

// Note:
// this file should contain a suite of sorting utilities to help the
// local version of the query functions.
/**
 * Alphabetic sorting of objects having a displayName
 */
const sortByDisplayName = ({ displayName: a }, { displayName: b }) => {
    if (a && b)
        return a.localeCompare(b);
    return a ? -1 : 1;
};
/**
 * Alphabetic sorting of objects having a name
 */
const sortByName = ({ name: a }, { name: b }) => {
    if (a && b)
        return a.localeCompare(b);
    return a ? -1 : 1;
};
/**
 * Sorting a collection by their apparition order (oldest first)
 */
const sortByChannelSegment = ({ channelSegment: a }, { channelSegment: b }) => a - b;
/**
 * Sorting a collection by their apparition order (oldest first)
 */
const sortBySegmentNumber = ({ segmentNumber: a }, { segmentNumber: b }) => a - b;
/**
 * Sorting a collection by its oldest items
 */
const sortByFirstCreated = ({ createdAt: a }, { createdAt: b }) => new Date(a).valueOf() - new Date(b).valueOf();
/**
 * Sorting a story-collection by its localSortingDate
 */
const sortByLocalSortingDate = ({ localSortingDate: a }, { localSortingDate: b }) => new Date(b).getTime() - new Date(a).getTime();
/**
 * Sorting a collection by its newest items
 */
const sortByLastCreated = ({ createdAt: a }, { createdAt: b }) => new Date(b).valueOf() - new Date(a).valueOf();
/**
 * Sorting a collection by its oldest items
 * -- Due to Amity.UpdatedAt is an optional type, we need to define a default value to 0 to prevent error
 */
const sortByFirstUpdated = ({ updatedAt: a = 0 }, { updatedAt: b = 0 }) => new Date(a).valueOf() - new Date(b).valueOf();
/**
 * Sorting a collection by its newest items
 * -- Due to Amity.UpdatedAt is an optional type, we need to define a default value to 0 to prevent error
 */
const sortByLastUpdated = ({ updatedAt: a = 0 }, { updatedAt: b = 0 }) => new Date(b).valueOf() - new Date(a).valueOf();
/**
 * Sorting a collection by the items with most recent activity
 */
const sortByLastActivity = ({ lastActivity: a }, { lastActivity: b }) => new Date(b).valueOf() - new Date(a).valueOf();

let activeUser = null;
/* begin_public_function
  id: client.get_current_user
*/
/**
 * for internal use
 */
const getActiveUser = () => {
    if (!activeUser) {
        throw new ASCError('Connect client first', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "fatal" /* Amity.ErrorLevel.FATAL */);
    }
    return activeUser;
};
/* end_public_function */
const setActiveUser = (user) => {
    activeUser = {
        _id: user._id,
        userId: user.userId,
        path: user.path,
    };
};

/* eslint-disable @typescript-eslint/ban-types */
let tasks = [];
let timer;
/**
 * Add a function to run just before the next tick
 *
 * @param task function to schedule for later execution
 */
const scheduleTask = (task) => {
    clearTimeout(timer);
    tasks.push(task);
    timer = setTimeout(() => {
        tasks.forEach(fn => fn());
        tasks = [];
    }, 0);
};

/* eslint-disable @typescript-eslint/no-unused-vars */
// need to sync up the list
const WS_EVENTS = [
    'disconnected',
    'error',
    'connect_error',
    'reconnect_error',
    'reconnect_failed',
    'sessionStateChange',
    // for internal use by accessTokenExpiryWatcher
    'tokenExpired',
];
const MQTT_EVENTS = [
    'connect',
    'message',
    'disconnect',
    'error',
    'close',
    'end',
    'reconnect',
    'video-streaming.didStart',
    'video-streaming.didRecord',
    'video-streaming.didStop',
    'video-streaming.didFlag',
    'video-streaming.didTerminate',
    // 'user.didGlobalBan' remove due to message event,
];
/** @hidden */
const createEventEmitter = () => {
    return mitt__default["default"]();
};
/**
 * Wraps the websocket events into the client's event emitter for
 * abstraction of transport.
 *
 * @param ws A websocket connection to listen from
 * @param emitter An event emitter to wire the events to
 *
 * @category Transport
 * @hidden
 */
const proxyWebsocketEvents = (ws, emitter) => {
    WS_EVENTS.forEach(event => {
        ws === null || ws === void 0 ? void 0 : ws.on(event, (param) => {
            emitter.emit(event, param);
        });
    });
};
const proxyMqttEvents = (mqttClient, emitter) => {
    MQTT_EVENTS.forEach(event => {
        mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.on(event, (...params) => {
            emitter.emit(event, params.length === 1 ? params[0] : params);
        });
    });
    // @ts-ignore
    mqttClient.on('message', (topic, payload) => {
        const message = JSON.parse(payload.toString());
        emitter.emit(message.eventType, message.data);
    });
};
/**
 * Standardize the subscription of SSE through web sockets
 *
 * @param client The current client for which to subscribe the event to
 * @param namespace A unique name for the logger
 * @param event The websocket event name
 * @param fn A wrapper for the callback.
 * @returns A dispose function to unsubscribe to the event
 *
 * @category Transport
 * @hidden
 */
const createEventSubscriber = (client, namespace, event, fn) => {
    const { log, emitter } = client;
    const timestamp = Date.now();
    log(`${namespace}(tmpid: ${timestamp}) > listen`);
    const handler = (...payload) => {
        log(`${namespace}(tmpid: ${timestamp}) > trigger`, payload);
        try {
            fn(...payload);
        }
        catch (e) {
            log(`${namespace}(tmpid: ${timestamp}) > error`, e);
        }
    };
    emitter.on(event, handler);
    return () => {
        log(`${namespace}(tmpid: ${timestamp}) > dispose`);
        emitter.off(event, handler);
    };
};
/**
 * Wrapper around dispatch event
 *
 * @hidden
 */
const fireEvent = (event, payload) => {
    const { emitter } = getActiveClient();
    scheduleTask(() => {
        emitter.emit(event, payload);
    });
};

let mqttAccessToken;
let mqttUserId;
async function modifyMqttConnection() {
    var _a;
    const { mqtt, emitter, token } = getActiveClient();
    if (!mqtt)
        return;
    const accessToken = (_a = token === null || token === void 0 ? void 0 : token.accessToken) !== null && _a !== void 0 ? _a : '';
    const user = getActiveUser();
    if (mqttAccessToken !== accessToken || mqttUserId !== user._id) {
        mqttAccessToken = accessToken;
        mqttUserId = user._id;
        await mqtt.connect({ accessToken: mqttAccessToken, userId: mqttUserId });
        proxyMqttEvents(mqtt, emitter);
    }
}

exports.SubscriptionLevels = void 0;
(function (SubscriptionLevels) {
    SubscriptionLevels["COMMUNITY"] = "community";
    SubscriptionLevels["POST"] = "post";
    SubscriptionLevels["COMMENT"] = "comment";
    SubscriptionLevels["POST_AND_COMMENT"] = "post_and_comment";
    SubscriptionLevels["USER"] = "user";
})(exports.SubscriptionLevels || (exports.SubscriptionLevels = {}));
const getCommunityUserTopic = (path, level) => {
    switch (level) {
        case 'post':
            return `${path}/post/+`;
        case 'comment':
            return `${path}/post/+/comment/+`;
        case 'post_and_comment':
            return `${path}/post/#`;
        default:
            return path;
    }
};
const getNetworkId = (user) => user.path.split('/user/')[0];
const getCommunityTopic = ({ path }, level = exports.SubscriptionLevels.COMMUNITY) => getCommunityUserTopic(path, level);
const getUserTopic = ({ path }, level = exports.SubscriptionLevels.USER) => getCommunityUserTopic(level === exports.SubscriptionLevels.USER ? path : path.replace(/^(\w*)/, '$1/social'), level);
const getPostTopic = ({ path }, level = exports.SubscriptionLevels.POST) => {
    switch (level) {
        case 'comment':
            return `${path}/comment/+`;
        default:
            return path;
    }
};
const getCommentTopic = ({ path }) => {
    return path;
};
// Subscribe on comment and story update on a single story
const getStoryTopic = ({ targetId, targetType, storyId, }) => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/social/${targetType}/${targetId}/story/${storyId}/#`;
};
// Subscribe on comment and story update on stories under community
const getCommunityStoriesTopic = ({ targetId, targetType, }) => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/social/${targetType}/${targetId}/story/#`;
};
const getMyFollowersTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/membership/${user._id}/+/+`;
};
const getMyFollowingsTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/membership/+/${user._id}/+`;
};
const getChannelTopic = (channel) => `${channel.path}/#`;
const getSubChannelTopic = (subChannel) => `${subChannel.path}/#`;
const getMessageTopic = (message) => message.path;
const getMarkedMessageTopic = ({ channelId, subChannelId, }) => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/marker/channel/${channelId}/message/${subChannelId}`;
};
const getMarkerUserFeedTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/marker/user/${user._id}`;
};
/**
 * @hidden
 *
 * Create a topic to subscribe to network level events like 'user is deleted from the network'
 */
const getNetworkTopic = () => {
    return getNetworkId(getActiveUser());
};
/**
 * @hidden
 *
 * Create a topic to subscribe to channel events for 'conversation', 'community' channel
 */
const getSmartFeedChannelTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/smartfeed/${user._id}/channels`;
};
/**
 * @hidden
 *
 * Create a topic to subscribe to sub channel events for 'conversation', 'community' channel
 */
const getSmartFeedSubChannelTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/smartfeed/${user._id}/messagefeeds`;
};
/**
 * @hidden
 *
 * Create a topic to subscribe to message events for 'conversation', 'community' channel
 */
const getSmartFeedMessageTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/smartfeed/${user._id}/messages`;
};
function subscribeTopic(topic, callback) {
    const { mqtt } = getActiveClient();
    if (!mqtt)
        return () => null;
    modifyMqttConnection();
    return mqtt.subscribe(topic, callback);
}
const getLiveStreamTopic = () => {
    const user = getActiveUser();
    return `${getNetworkId(user)}/videostreaming`;
};

var _a;
/* eslint-disable no-undef */
const theGlobal = 
// eslint-disable-next-line no-nested-ternary
typeof globalThis === 'object' ? globalThis : typeof global === 'object' ? global : window;
const { process: safeProcess = {} } = theGlobal;
const isProduction = ((_a = safeProcess.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) === 'production';

/**
 * Creates a pre-configured logger instance
 *
 * @param session The name of the debug session
 * @returns A pre-configured logger function
 *
 * @category Debug
 * @hidden
 */
const createLogger = (session) => {
    const active = `${session === null || session === void 0 ? void 0 : session.trim()}`.length > 0 && !isProduction;
    const logger = debug__default["default"](session);
    const print = (topic, ...args) => {
        active && logger(topic, args);
    };
    // eslint-disable-next-line no-underscore-dangle
    print.__instance__ = logger;
    return print;
};

const API_REGIONS = {
    EU: 'eu',
    SG: 'sg',
    US: 'us',
};
const URLS = {
    http: 'https://apix.{region}.amity.co',
    upload: 'https://upload.{region}.amity.co',
    mqtt: 'wss://sse.{region}.amity.co:443/mqtt',
};
function computeUrl(type, region) {
    return URLS[type].replace('{region}', region);
}

/**
 * Unwraps v3 server payload (for error handling and type extraction)
 *
 * @param response A typical "v3" response (related to backend's service strategy)
 *
 * @returns The data returned by the backend
 * @throws An error related to backend's rejection
 *
 * @category Transport
 * @hidden
 */
const unwrapPayload = (response) => {
    if (response.status === 'success') {
        return response.data;
    }
    if (response.status === 'fail') {
        throw new ASCUnknownError(response.code);
    }
    else if (response.status === 'error') {
        throw new ASCApiError(response.message, response.code, "error" /* Amity.ErrorLevel.ERROR */);
    }
    // unjust, but helps force uncast "T | undefined" to allow deconstruction without warnings
    return undefined;
};

class NetworkActivitiesWatcher {
    constructor() {
        this._listener = new Map();
    }
    onNetworkActivities(callback) {
        this._listener.set(callback, callback);
        return () => {
            this._listener.delete(callback);
        };
    }
    setNetworkActivities(request, response) {
        this._listener.forEach(cb => cb(request, response));
    }
    destroy() {
        this._listener.clear();
    }
}
let instance$6;
var NetworkActivitiesWatcher$1 = {
    getInstance: () => {
        if (!instance$6) {
            instance$6 = new NetworkActivitiesWatcher();
        }
        return instance$6;
    },
};

/*
 * Defined here as transport is a private module. Also, outside of this module
 * this enum holds no meaning.
 *
 * @private (exported for testing)
 */
var RequestCancelation;
(function (RequestCancelation) {
    RequestCancelation["UserDeleted"] = "User Deleted";
    RequestCancelation["UserGlobalBanned"] = "User Global Banned";
    RequestCancelation["TokenExpired"] = "Token Expired";
})(RequestCancelation || (RequestCancelation = {}));
/*
 * Axios no longer supports `cancelToken`, since v0.22.0, and is marked as
 * deprecated. The doc asks to use the abort controller that fetch uses instead
 *
 * More Info:
 * https://axios-http.com/docs/cancellation
 */
const controller = new AbortController();
/**
 * Handle Request Cancellation
 *
 * @param cancel Reason for cancelation
 *
 * @category Transport Util
 * @hidden
 */
const handleRequestCancelation = (cancel) => {
    switch (cancel) {
        case RequestCancelation.UserGlobalBanned:
            /*
             * Note:
             * Firing a virtual event (fireEvent) is not required as the metadata in
             * the request (isGlobalBanned) is only true once the user has been banned
             * and the SDK has recieved a global ban event
             */
            throw new ASCError(cancel, 400312 /* Amity.ServerError.GLOBAL_BAN */, "fatal" /* Amity.ErrorLevel.FATAL */);
        case RequestCancelation.UserDeleted:
            /*
             * Note:
             * Firing a virtual event (fireEvent) is not required. For same reason as
             * above. Only difference is that the event recieved is user deleted
             */
            throw new ASCError(cancel, 400100 /* Amity.ServerError.UNAUTHORIZED */, "fatal" /* Amity.ErrorLevel.FATAL */);
        case RequestCancelation.TokenExpired:
            fireEvent('tokenExpired', "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */);
            throw new ASCError(cancel, 800403 /* Amity.ClientError.TOKEN_EXPIRED */, "fatal" /* Amity.ErrorLevel.FATAL */);
        default:
            throw new ASCError('Request Aborted', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
    }
};
/**
 * Creates a pre-configured axios instance
 *
 * @param endpoint The ASC rest api server's URL
 * @returns A pre-configured axios instance
 *
 * @category Transport
 * @hidden
 */
const createHttpTransport = (endpoint) => {
    const options = {
        maxSockets: 100,
        maxFreeSockets: 10,
        timeout: 60000,
        freeSocketTimeout: 30000,
    };
    const instance = axios__default["default"].create({
        baseURL: endpoint,
        httpAgent: new HttpAgent__default["default"](options),
        httpsAgent: new HttpAgent.HttpsAgent(options),
        signal: controller.signal,
        /*
         * If paramSerializer is required, use the serialize option to stringify
         * params. The encode option will pass complex params as string only whereas
         * the serialize option will pass params in the format Record<string, any>
         *
         * For more details:
         * https://github.com/axios/axios#request-config
         */
    });
    instance.defaults.withCredentials = false;
    instance.interceptors.request.use(config => {
        // do not check expiration for token creation url
        if (config.url === '/api/v5/sessions') {
            return config;
        }
        // check global.ts for the extension of AxiosRequestConfig
        if (config.metadata) {
            const { tokenExpiry, isGlobalBanned, isUserDeleted } = config.metadata;
            if (isGlobalBanned) {
                controller.abort();
                handleRequestCancelation(RequestCancelation.UserGlobalBanned);
            }
            if (isUserDeleted) {
                controller.abort();
                handleRequestCancelation(RequestCancelation.UserDeleted);
            }
            if (tokenExpiry) {
                if (Date.now() >= Date.parse(tokenExpiry)) {
                    controller.abort(RequestCancelation.UserDeleted);
                    handleRequestCancelation(RequestCancelation.TokenExpired);
                }
            }
        }
        return config;
    });
    instance.interceptors.response.use(response => {
        const responseHeaders = new Headers();
        Object.entries(response.headers).forEach(([key, value]) => {
            if (typeof value === 'string') {
                responseHeaders.append(key, value);
            }
        });
        NetworkActivitiesWatcher$1.getInstance().setNetworkActivities(new Request(response.request.url, {
            method: response.request.method,
            headers: response.request.headers,
            body: response.request.data,
        }), {
            data: response.data,
            status: response.status,
            statusText: response.statusText,
            headers: responseHeaders,
        });
        return response;
    }, error => {
        var _a, _b;
        const { response } = error;
        // handle unauthorized request
        if ((response === null || response === void 0 ? void 0 : response.data.code) === 400100 /* Amity.ServerError.UNAUTHORIZED */) {
            fireEvent('tokenTerminated', "terminated" /* Amity.SessionStates.TERMINATED */);
        }
        // if it's an error with status in the response payload,
        // then it's an expected error.
        if ((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.status) {
            unwrapPayload(response === null || response === void 0 ? void 0 : response.data);
        }
        // as on request cancellation error is returned
        if (controller.signal.aborted) {
            throw error;
        }
        // unexpected error.
        throw new Error((_b = response === null || response === void 0 ? void 0 : response.data) !== null && _b !== void 0 ? _b : error);
    });
    instance.defaults.paramsSerializer = {
        encode: params => encodeURIComponent(params),
    };
    return instance;
};

/**
 * Creates a pre-configured socket.io instance
 *
 * @param endpoint The socket.io server's URL
 * @returns A pre-configured (non-connected) socket.io client instance
 *
 * @category Transport
 * @hidden
 */
const createWebsocketTransport = (endpoint) => {
    const socket = io__default["default"](endpoint, {
        autoConnect: false,
        reconnectionDelay: 2000,
        transports: ['websocket'],
    });
    // FIXME: disconnectClient removes this listener and client can get global ban event
    socket.on('disconnect', (reason) => {
        if (reason === 'io server disconnect')
            socket.connect();
    });
    return socket;
};

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var mqtt$1 = {exports: {}};

(function(module,exports){(function(f){{module.exports=f();}})(function(){return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a;}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r);},p,p.exports,r,e,n,t);}return n[i].exports;}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++){o(t[i]);}return o;}return r;}()({1:[function(require,module,exports){(function(process,global){(function(){/**
	 * Module dependencies
	 */var EventEmitter=require('events').EventEmitter;var Store=require('./store');var TopicAliasRecv=require('./topic-alias-recv');var TopicAliasSend=require('./topic-alias-send');var mqttPacket=require('mqtt-packet');var DefaultMessageIdProvider=require('./default-message-id-provider');var Writable=require('readable-stream').Writable;var inherits=require('inherits');var reInterval=require('reinterval');var clone=require('rfdc/default');var validations=require('./validations');var xtend=require('xtend');var debug=require('debug')('mqttjs:client');var nextTick=process?process.nextTick:function(callback){setTimeout(callback,0);};var setImmediate=global.setImmediate||function(callback){// works in node v0.8
nextTick(callback);};var defaultConnectOptions={keepalive:60,reschedulePings:true,protocolId:'MQTT',protocolVersion:4,reconnectPeriod:1000,connectTimeout:30*1000,clean:true,resubscribe:true};var socketErrors=['ECONNREFUSED','EADDRINUSE','ECONNRESET','ENOTFOUND'];// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.
var errors={0:'',1:'Unacceptable protocol version',2:'Identifier rejected',3:'Server unavailable',4:'Bad username or password',5:'Not authorized',16:'No matching subscribers',17:'No subscription existed',128:'Unspecified error',129:'Malformed Packet',130:'Protocol Error',131:'Implementation specific error',132:'Unsupported Protocol Version',133:'Client Identifier not valid',134:'Bad User Name or Password',135:'Not authorized',136:'Server unavailable',137:'Server busy',138:'Banned',139:'Server shutting down',140:'Bad authentication method',141:'Keep Alive timeout',142:'Session taken over',143:'Topic Filter invalid',144:'Topic Name invalid',145:'Packet identifier in use',146:'Packet Identifier not found',147:'Receive Maximum exceeded',148:'Topic Alias invalid',149:'Packet too large',150:'Message rate too high',151:'Quota exceeded',152:'Administrative action',153:'Payload format invalid',154:'Retain not supported',155:'QoS not supported',156:'Use another server',157:'Server moved',158:'Shared Subscriptions not supported',159:'Connection rate exceeded',160:'Maximum connect time',161:'Subscription Identifiers not supported',162:'Wildcard Subscriptions not supported'};function defaultId(){return 'mqttjs_'+Math.random().toString(16).substr(2,8);}function applyTopicAlias(client,packet){if(client.options.protocolVersion===5){if(packet.cmd==='publish'){var alias;if(packet.properties){alias=packet.properties.topicAlias;}var topic=packet.topic.toString();if(client.topicAliasSend){if(alias){if(topic.length!==0){// register topic alias
debug('applyTopicAlias :: register topic: %s - alias: %d',topic,alias);if(!client.topicAliasSend.put(topic,alias)){debug('applyTopicAlias :: error out of range. topic: %s - alias: %d',topic,alias);return new Error('Sending Topic Alias out of range');}}}else {if(topic.length!==0){if(client.options.autoAssignTopicAlias){alias=client.topicAliasSend.getAliasByTopic(topic);if(alias){packet.topic='';packet.properties=_objectSpread2(_objectSpread2({},packet.properties),{},{topicAlias:alias});debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d',topic,alias);}else {alias=client.topicAliasSend.getLruAlias();client.topicAliasSend.put(topic,alias);packet.properties=_objectSpread2(_objectSpread2({},packet.properties),{},{topicAlias:alias});debug('applyTopicAlias :: auto assign topic: %s - alias: %d',topic,alias);}}else if(client.options.autoUseTopicAlias){alias=client.topicAliasSend.getAliasByTopic(topic);if(alias){packet.topic='';packet.properties=_objectSpread2(_objectSpread2({},packet.properties),{},{topicAlias:alias});debug('applyTopicAlias :: auto use topic: %s - alias: %d',topic,alias);}}}}}else if(alias){debug('applyTopicAlias :: error out of range. topic: %s - alias: %d',topic,alias);return new Error('Sending Topic Alias out of range');}}}}function removeTopicAliasAndRecoverTopicName(client,packet){var alias;if(packet.properties){alias=packet.properties.topicAlias;}var topic=packet.topic.toString();if(topic.length===0){// restore topic from alias
if(typeof alias==='undefined'){return new Error('Unregistered Topic Alias');}else {topic=client.topicAliasSend.getTopicByAlias(alias);if(typeof topic==='undefined'){return new Error('Unregistered Topic Alias');}else {packet.topic=topic;}}}if(alias){delete packet.properties.topicAlias;}}function sendPacket(client,packet,cb){debug('sendPacket :: packet: %O',packet);debug('sendPacket :: emitting `packetsend`');client.emit('packetsend',packet);debug('sendPacket :: writing to stream');var result=mqttPacket.writeToStream(packet,client.stream,client.options);debug('sendPacket :: writeToStream result %s',result);if(!result&&cb&&cb!==nop){debug('sendPacket :: handle events on `drain` once through callback.');client.stream.once('drain',cb);}else if(cb){debug('sendPacket :: invoking cb');cb();}}function flush(queue){if(queue){debug('flush: queue exists? %b',!!queue);Object.keys(queue).forEach(function(messageId){if(typeof queue[messageId].cb==='function'){queue[messageId].cb(new Error('Connection closed'));// This is suspicious.  Why do we only delete this if we have a callbck?
// If this is by-design, then adding no as callback would cause this to get deleted unintentionally.
delete queue[messageId];}});}}function flushVolatile(queue){if(queue){debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');Object.keys(queue).forEach(function(messageId){if(queue[messageId]["volatile"]&&typeof queue[messageId].cb==='function'){queue[messageId].cb(new Error('Connection closed'));delete queue[messageId];}});}}function storeAndSend(client,packet,cb,cbStorePut){debug('storeAndSend :: store packet with cmd %s to outgoingStore',packet.cmd);var storePacket=packet;var err;if(storePacket.cmd==='publish'){// The original packet is for sending.
// The cloned storePacket is for storing to resend on reconnect.
// Topic Alias must not be used after disconnected.
storePacket=clone(packet);err=removeTopicAliasAndRecoverTopicName(client,storePacket);if(err){return cb&&cb(err);}}client.outgoingStore.put(storePacket,function storedPacket(err){if(err){return cb&&cb(err);}cbStorePut();sendPacket(client,packet,cb);});}function nop(error){debug('nop ::',error);}/**
	 * MqttClient constructor
	 *
	 * @param {Stream} stream - stream
	 * @param {Object} [options] - connection options
	 * (see Connection#connect)
	 */function MqttClient(streamBuilder,options){var k;var that=this;if(!(this instanceof MqttClient)){return new MqttClient(streamBuilder,options);}this.options=options||{};// Defaults
for(k in defaultConnectOptions){if(typeof this.options[k]==='undefined'){this.options[k]=defaultConnectOptions[k];}else {this.options[k]=options[k];}}debug('MqttClient :: options.protocol',options.protocol);debug('MqttClient :: options.protocolVersion',options.protocolVersion);debug('MqttClient :: options.username',options.username);debug('MqttClient :: options.keepalive',options.keepalive);debug('MqttClient :: options.reconnectPeriod',options.reconnectPeriod);debug('MqttClient :: options.rejectUnauthorized',options.rejectUnauthorized);debug('MqttClient :: options.topicAliasMaximum',options.topicAliasMaximum);this.options.clientId=typeof options.clientId==='string'?options.clientId:defaultId();debug('MqttClient :: clientId',this.options.clientId);this.options.customHandleAcks=options.protocolVersion===5&&options.customHandleAcks?options.customHandleAcks:function(){arguments[3](0);};this.streamBuilder=streamBuilder;this.messageIdProvider=typeof this.options.messageIdProvider==='undefined'?new DefaultMessageIdProvider():this.options.messageIdProvider;// Inflight message storages
this.outgoingStore=options.outgoingStore||new Store();this.incomingStore=options.incomingStore||new Store();// Should QoS zero messages be queued when the connection is broken?
this.queueQoSZero=options.queueQoSZero===undefined?true:options.queueQoSZero;// map of subscribed topics to support reconnection
this._resubscribeTopics={};// map of a subscribe messageId and a topic
this.messageIdToTopic={};// Ping timer, setup in _setupPingTimer
this.pingTimer=null;// Is the client connected?
this.connected=false;// Are we disconnecting?
this.disconnecting=false;// Packet queue
this.queue=[];// connack timer
this.connackTimer=null;// Reconnect timer
this.reconnectTimer=null;// Is processing store?
this._storeProcessing=false;// Packet Ids are put into the store during store processing
this._packetIdsDuringStoreProcessing={};// Store processing queue
this._storeProcessingQueue=[];// Inflight callbacks
this.outgoing={};// True if connection is first time.
this._firstConnection=true;if(options.topicAliasMaximum>0){if(options.topicAliasMaximum>0xffff){debug('MqttClient :: options.topicAliasMaximum is out of range');}else {this.topicAliasRecv=new TopicAliasRecv(options.topicAliasMaximum);}}// Send queued packets
this.on('connect',function(){var queue=this.queue;function deliver(){var entry=queue.shift();debug('deliver :: entry %o',entry);var packet=null;if(!entry){that._resubscribe();return;}packet=entry.packet;debug('deliver :: call _sendPacket for %o',packet);var send=true;if(packet.messageId&&packet.messageId!==0){if(!that.messageIdProvider.register(packet.messageId)){send=false;}}if(send){that._sendPacket(packet,function(err){if(entry.cb){entry.cb(err);}deliver();});}else {debug('messageId: %d has already used. The message is skipped and removed.',packet.messageId);deliver();}}debug('connect :: sending queued packets');deliver();});this.on('close',function(){debug('close :: connected set to `false`');this.connected=false;debug('close :: clearing connackTimer');clearTimeout(this.connackTimer);debug('close :: clearing ping timer');if(that.pingTimer!==null){that.pingTimer.clear();that.pingTimer=null;}if(this.topicAliasRecv){this.topicAliasRecv.clear();}debug('close :: calling _setupReconnect');this._setupReconnect();});EventEmitter.call(this);debug('MqttClient :: setting up stream');this._setupStream();}inherits(MqttClient,EventEmitter);/**
	 * setup the event handlers in the inner stream.
	 *
	 * @api private
	 */MqttClient.prototype._setupStream=function(){var _this3=this;var that=this;var writable=new Writable();var parser=mqttPacket.parser(this.options);var completeParse=null;var packets=[];debug('_setupStream :: calling method to clear reconnect');this._clearReconnect();debug('_setupStream :: using streamBuilder provided to client to create stream');this.stream=this.streamBuilder(this);parser.on('packet',function(packet){debug('parser :: on packet push to packets array.');packets.push(packet);});function nextTickWork(){if(packets.length){nextTick(work);}else {var done=completeParse;completeParse=null;done();}}function work(){debug('work :: getting next packet in queue');var packet=packets.shift();if(packet){debug('work :: packet pulled from queue');that._handlePacket(packet,nextTickWork);}else {debug('work :: no packets in queue');var done=completeParse;completeParse=null;debug('work :: done flag is %s',!!done);if(done)done();}}writable._write=function(buf,enc,done){completeParse=done;debug('writable stream :: parsing buffer');parser.parse(buf);work();};function streamErrorHandler(error){debug('streamErrorHandler :: error',error.message);if(socketErrors.includes(error.code)){// handle error
debug('streamErrorHandler :: emitting error');that.emit('error',error);}else {nop(error);}}debug('_setupStream :: pipe stream to writable stream');this.stream.pipe(writable);// Suppress connection errors
this.stream.on('error',streamErrorHandler);// Echo stream close
this.stream.on('close',function(){debug('(%s)stream :: on close',that.options.clientId);flushVolatile(that.outgoing);debug('stream: emit close to MqttClient');that.emit('close');});// Send a connect packet
debug('_setupStream: sending packet `connect`');var connectPacket=Object.create(this.options);connectPacket.cmd='connect';if(this.topicAliasRecv){if(!connectPacket.properties){connectPacket.properties={};}if(this.topicAliasRecv){connectPacket.properties.topicAliasMaximum=this.topicAliasRecv.max;}}// avoid message queue
sendPacket(this,connectPacket);// Echo connection errors
parser.on('error',this.emit.bind(this,'error'));// auth
if(this.options.properties){if(!this.options.properties.authenticationMethod&&this.options.properties.authenticationData){that.end(function(){return _this3.emit('error',new Error('Packet has no Authentication Method'));});return this;}if(this.options.properties.authenticationMethod&&this.options.authPacket&&_typeof(this.options.authPacket)==='object'){var authPacket=xtend({cmd:'auth',reasonCode:0},this.options.authPacket);sendPacket(this,authPacket);}}// many drain listeners are needed for qos 1 callbacks if the connection is intermittent
this.stream.setMaxListeners(1000);clearTimeout(this.connackTimer);this.connackTimer=setTimeout(function(){debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');that._cleanUp(true);},this.options.connectTimeout);};MqttClient.prototype._handlePacket=function(packet,done){var options=this.options;if(options.protocolVersion===5&&options.properties&&options.properties.maximumPacketSize&&options.properties.maximumPacketSize<packet.length){this.emit('error',new Error('exceeding packets size '+packet.cmd));this.end({reasonCode:149,properties:{reasonString:'Maximum packet size was exceeded'}});return this;}debug('_handlePacket :: emitting packetreceive');this.emit('packetreceive',packet);switch(packet.cmd){case'publish':this._handlePublish(packet,done);break;case'puback':case'pubrec':case'pubcomp':case'suback':case'unsuback':this._handleAck(packet);done();break;case'pubrel':this._handlePubrel(packet,done);break;case'connack':this._handleConnack(packet);done();break;case'auth':this._handleAuth(packet);done();break;case'pingresp':this._handlePingresp(packet);done();break;case'disconnect':this._handleDisconnect(packet);done();break;}};MqttClient.prototype._checkDisconnecting=function(callback){if(this.disconnecting){if(callback&&callback!==nop){callback(new Error('client disconnecting'));}else {this.emit('error',new Error('client disconnecting'));}}return this.disconnecting;};/**
	 * publish - publish <message> to <topic>
	 *
	 * @param {String} topic - topic to publish to
	 * @param {String, Buffer} message - message to publish
	 * @param {Object} [opts] - publish options, includes:
	 *    {Number} qos - qos level to publish on
	 *    {Boolean} retain - whether or not to retain the message
	 *    {Boolean} dup - whether or not mark a message as duplicate
	 *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`
	 * @param {Function} [callback] - function(err){}
	 *    called when publish succeeds or fails
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 *
	 * @example client.publish('topic', 'message');
	 * @example
	 *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});
	 * @example client.publish('topic', 'message', console.log);
	 */MqttClient.prototype.publish=function(topic,message,opts,callback){debug('publish :: message `%s` to topic `%s`',message,topic);var options=this.options;// .publish(topic, payload, cb);
if(typeof opts==='function'){callback=opts;opts=null;}// default opts
var defaultOpts={qos:0,retain:false,dup:false};opts=xtend(defaultOpts,opts);if(this._checkDisconnecting(callback)){return this;}var that=this;var publishProc=function publishProc(){var messageId=0;if(opts.qos===1||opts.qos===2){messageId=that._nextId();if(messageId===null){debug('No messageId left');return false;}}var packet={cmd:'publish',topic:topic,payload:message,qos:opts.qos,retain:opts.retain,messageId:messageId,dup:opts.dup};if(options.protocolVersion===5){packet.properties=opts.properties;}debug('publish :: qos',opts.qos);switch(opts.qos){case 1:case 2:// Add to callbacks
that.outgoing[packet.messageId]={"volatile":false,cb:callback||nop};debug('MqttClient:publish: packet cmd: %s',packet.cmd);that._sendPacket(packet,undefined,opts.cbStorePut);break;default:debug('MqttClient:publish: packet cmd: %s',packet.cmd);that._sendPacket(packet,callback,opts.cbStorePut);break;}return true;};if(this._storeProcessing||this._storeProcessingQueue.length>0||!publishProc()){this._storeProcessingQueue.push({invoke:publishProc,cbStorePut:opts.cbStorePut,callback:callback});}return this;};/**
	 * subscribe - subscribe to <topic>
	 *
	 * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}
	 * @param {Object} [opts] - optional subscription options, includes:
	 *    {Number} qos - subscribe qos level
	 * @param {Function} [callback] - function(err, granted){} where:
	 *    {Error} err - subscription error (none at the moment!)
	 *    {Array} granted - array of {topic: 't', qos: 0}
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.subscribe('topic');
	 * @example client.subscribe('topic', {qos: 1});
	 * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);
	 * @example client.subscribe('topic', console.log);
	 */MqttClient.prototype.subscribe=function(){var that=this;var args=new Array(arguments.length);for(var i=0;i<arguments.length;i++){args[i]=arguments[i];}var subs=[];var obj=args.shift();var resubscribe=obj.resubscribe;var callback=args.pop()||nop;var opts=args.pop();var version=this.options.protocolVersion;delete obj.resubscribe;if(typeof obj==='string'){obj=[obj];}if(typeof callback!=='function'){opts=callback;callback=nop;}var invalidTopic=validations.validateTopics(obj);if(invalidTopic!==null){setImmediate(callback,new Error('Invalid topic '+invalidTopic));return this;}if(this._checkDisconnecting(callback)){debug('subscribe: discconecting true');return this;}var defaultOpts={qos:0};if(version===5){defaultOpts.nl=false;defaultOpts.rap=false;defaultOpts.rh=0;}opts=xtend(defaultOpts,opts);if(Array.isArray(obj)){obj.forEach(function(topic){debug('subscribe: array topic %s',topic);if(!Object.prototype.hasOwnProperty.call(that._resubscribeTopics,topic)||that._resubscribeTopics[topic].qos<opts.qos||resubscribe){var currentOpts={topic:topic,qos:opts.qos};if(version===5){currentOpts.nl=opts.nl;currentOpts.rap=opts.rap;currentOpts.rh=opts.rh;currentOpts.properties=opts.properties;}debug('subscribe: pushing topic `%s` and qos `%s` to subs list',currentOpts.topic,currentOpts.qos);subs.push(currentOpts);}});}else {Object.keys(obj).forEach(function(k){debug('subscribe: object topic %s',k);if(!Object.prototype.hasOwnProperty.call(that._resubscribeTopics,k)||that._resubscribeTopics[k].qos<obj[k].qos||resubscribe){var currentOpts={topic:k,qos:obj[k].qos};if(version===5){currentOpts.nl=obj[k].nl;currentOpts.rap=obj[k].rap;currentOpts.rh=obj[k].rh;currentOpts.properties=opts.properties;}debug('subscribe: pushing `%s` to subs list',currentOpts);subs.push(currentOpts);}});}if(!subs.length){callback(null,[]);return this;}var subscribeProc=function subscribeProc(){var messageId=that._nextId();if(messageId===null){debug('No messageId left');return false;}var packet={cmd:'subscribe',subscriptions:subs,qos:1,retain:false,dup:false,messageId:messageId};if(opts.properties){packet.properties=opts.properties;}// subscriptions to resubscribe to in case of disconnect
if(that.options.resubscribe){debug('subscribe :: resubscribe true');var topics=[];subs.forEach(function(sub){if(that.options.reconnectPeriod>0){var topic={qos:sub.qos};if(version===5){topic.nl=sub.nl||false;topic.rap=sub.rap||false;topic.rh=sub.rh||0;topic.properties=sub.properties;}that._resubscribeTopics[sub.topic]=topic;topics.push(sub.topic);}});that.messageIdToTopic[packet.messageId]=topics;}that.outgoing[packet.messageId]={"volatile":true,cb:function cb(err,packet){if(!err){var granted=packet.granted;for(var _i=0;_i<granted.length;_i+=1){subs[_i].qos=granted[_i];}}callback(err,subs);}};debug('subscribe :: call _sendPacket');that._sendPacket(packet);return true;};if(this._storeProcessing||this._storeProcessingQueue.length>0||!subscribeProc()){this._storeProcessingQueue.push({invoke:subscribeProc,callback:callback});}return this;};/**
	 * unsubscribe - unsubscribe from topic(s)
	 *
	 * @param {String, Array} topic - topics to unsubscribe from
	 * @param {Object} [opts] - optional subscription options, includes:
	 *    {Object} properties - properties of unsubscribe packet
	 * @param {Function} [callback] - callback fired on unsuback
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 * @example client.unsubscribe('topic');
	 * @example client.unsubscribe('topic', console.log);
	 */MqttClient.prototype.unsubscribe=function(){var that=this;var args=new Array(arguments.length);for(var i=0;i<arguments.length;i++){args[i]=arguments[i];}var topic=args.shift();var callback=args.pop()||nop;var opts=args.pop();if(typeof topic==='string'){topic=[topic];}if(typeof callback!=='function'){opts=callback;callback=nop;}var invalidTopic=validations.validateTopics(topic);if(invalidTopic!==null){setImmediate(callback,new Error('Invalid topic '+invalidTopic));return this;}if(that._checkDisconnecting(callback)){return this;}var unsubscribeProc=function unsubscribeProc(){var messageId=that._nextId();if(messageId===null){debug('No messageId left');return false;}var packet={cmd:'unsubscribe',qos:1,messageId:messageId};if(typeof topic==='string'){packet.unsubscriptions=[topic];}else if(Array.isArray(topic)){packet.unsubscriptions=topic;}if(that.options.resubscribe){packet.unsubscriptions.forEach(function(topic){delete that._resubscribeTopics[topic];});}if(_typeof(opts)==='object'&&opts.properties){packet.properties=opts.properties;}that.outgoing[packet.messageId]={"volatile":true,cb:callback};debug('unsubscribe: call _sendPacket');that._sendPacket(packet);return true;};if(this._storeProcessing||this._storeProcessingQueue.length>0||!unsubscribeProc()){this._storeProcessingQueue.push({invoke:unsubscribeProc,callback:callback});}return this;};/**
	 * end - close connection
	 *
	 * @returns {MqttClient} this - for chaining
	 * @param {Boolean} force - do not wait for all in-flight messages to be acked
	 * @param {Object} opts - added to the disconnect packet
	 * @param {Function} cb - called when the client has been closed
	 *
	 * @api public
	 */MqttClient.prototype.end=function(force,opts,cb){var that=this;debug('end :: (%s)',this.options.clientId);if(force==null||typeof force!=='boolean'){cb=opts||nop;opts=force;force=false;if(_typeof(opts)!=='object'){cb=opts;opts=null;if(typeof cb!=='function'){cb=nop;}}}if(_typeof(opts)!=='object'){cb=opts;opts=null;}debug('end :: cb? %s',!!cb);cb=cb||nop;function closeStores(){debug('end :: closeStores: closing incoming and outgoing stores');that.disconnected=true;that.incomingStore.close(function(e1){that.outgoingStore.close(function(e2){debug('end :: closeStores: emitting end');that.emit('end');if(cb){var err=e1||e2;debug('end :: closeStores: invoking callback with args');cb(err);}});});if(that._deferredReconnect){that._deferredReconnect();}}function finish(){// defer closesStores of an I/O cycle,
// just to make sure things are
// ok for websockets
debug('end :: (%s) :: finish :: calling _cleanUp with force %s',that.options.clientId,force);that._cleanUp(force,function(){debug('end :: finish :: calling process.nextTick on closeStores');// const boundProcess = nextTick.bind(null, closeStores)
nextTick(closeStores.bind(that));},opts);}if(this.disconnecting){cb();return this;}this._clearReconnect();this.disconnecting=true;if(!force&&Object.keys(this.outgoing).length>0){// wait 10ms, just to be sure we received all of it
debug('end :: (%s) :: calling finish in 10ms once outgoing is empty',that.options.clientId);this.once('outgoingEmpty',setTimeout.bind(null,finish,10));}else {debug('end :: (%s) :: immediately calling finish',that.options.clientId);finish();}return this;};/**
	 * removeOutgoingMessage - remove a message in outgoing store
	 * the outgoing callback will be called withe Error('Message removed') if the message is removed
	 *
	 * @param {Number} messageId - messageId to remove message
	 * @returns {MqttClient} this - for chaining
	 * @api public
	 *
	 * @example client.removeOutgoingMessage(client.getLastAllocated());
	 */MqttClient.prototype.removeOutgoingMessage=function(messageId){var cb=this.outgoing[messageId]?this.outgoing[messageId].cb:null;delete this.outgoing[messageId];this.outgoingStore.del({messageId:messageId},function(){cb(new Error('Message removed'));});return this;};/**
	 * reconnect - connect again using the same options as connect()
	 *
	 * @param {Object} [opts] - optional reconnect options, includes:
	 *    {Store} incomingStore - a store for the incoming packets
	 *    {Store} outgoingStore - a store for the outgoing packets
	 *    if opts is not given, current stores are used
	 * @returns {MqttClient} this - for chaining
	 *
	 * @api public
	 */MqttClient.prototype.reconnect=function(opts){debug('client reconnect');var that=this;var f=function f(){if(opts){that.options.incomingStore=opts.incomingStore;that.options.outgoingStore=opts.outgoingStore;}else {that.options.incomingStore=null;that.options.outgoingStore=null;}that.incomingStore=that.options.incomingStore||new Store();that.outgoingStore=that.options.outgoingStore||new Store();that.disconnecting=false;that.disconnected=false;that._deferredReconnect=null;that._reconnect();};if(this.disconnecting&&!this.disconnected){this._deferredReconnect=f;}else {f();}return this;};/**
	 * _reconnect - implement reconnection
	 * @api privateish
	 */MqttClient.prototype._reconnect=function(){var _this4=this;debug('_reconnect: emitting reconnect to client');this.emit('reconnect');if(this.connected){this.end(function(){_this4._setupStream();});debug('client already connected. disconnecting first.');}else {debug('_reconnect: calling _setupStream');this._setupStream();}};/**
	 * _setupReconnect - setup reconnect timer
	 */MqttClient.prototype._setupReconnect=function(){var that=this;if(!that.disconnecting&&!that.reconnectTimer&&that.options.reconnectPeriod>0){if(!this.reconnecting){debug('_setupReconnect :: emit `offline` state');this.emit('offline');debug('_setupReconnect :: set `reconnecting` to `true`');this.reconnecting=true;}debug('_setupReconnect :: setting reconnectTimer for %d ms',that.options.reconnectPeriod);that.reconnectTimer=setInterval(function(){debug('reconnectTimer :: reconnect triggered!');that._reconnect();},that.options.reconnectPeriod);}else {debug('_setupReconnect :: doing nothing...');}};/**
	 * _clearReconnect - clear the reconnect timer
	 */MqttClient.prototype._clearReconnect=function(){debug('_clearReconnect : clearing reconnect timer');if(this.reconnectTimer){clearInterval(this.reconnectTimer);this.reconnectTimer=null;}};/**
	 * _cleanUp - clean up on connection end
	 * @api private
	 */MqttClient.prototype._cleanUp=function(forced,done){var opts=arguments[2];if(done){debug('_cleanUp :: done callback provided for on stream close');this.stream.on('close',done);}debug('_cleanUp :: forced? %s',forced);if(forced){if(this.options.reconnectPeriod===0&&this.options.clean){flush(this.outgoing);}debug('_cleanUp :: (%s) :: destroying stream',this.options.clientId);this.stream.destroy();}else {var packet=xtend({cmd:'disconnect'},opts);debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet',this.options.clientId);this._sendPacket(packet,setImmediate.bind(null,this.stream.end.bind(this.stream)));}if(!this.disconnecting){debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');this._clearReconnect();this._setupReconnect();}if(this.pingTimer!==null){debug('_cleanUp :: clearing pingTimer');this.pingTimer.clear();this.pingTimer=null;}if(done&&!this.connected){debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener',this.options.clientId);this.stream.removeListener('close',done);done();}};/**
	 * _sendPacket - send or queue a packet
	 * @param {Object} packet - packet options
	 * @param {Function} cb - callback when the packet is sent
	 * @param {Function} cbStorePut - called when message is put into outgoingStore
	 * @api private
	 */MqttClient.prototype._sendPacket=function(packet,cb,cbStorePut){debug('_sendPacket :: (%s) ::  start',this.options.clientId);cbStorePut=cbStorePut||nop;cb=cb||nop;var err=applyTopicAlias(this,packet);if(err){cb(err);return;}if(!this.connected){// allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)
if(packet.cmd==='auth'){this._shiftPingInterval();sendPacket(this,packet,cb);return;}debug('_sendPacket :: client not connected. Storing packet offline.');this._storePacket(packet,cb,cbStorePut);return;}// When sending a packet, reschedule the ping timer
this._shiftPingInterval();switch(packet.cmd){case'publish':break;case'pubrel':storeAndSend(this,packet,cb,cbStorePut);return;default:sendPacket(this,packet,cb);return;}switch(packet.qos){case 2:case 1:storeAndSend(this,packet,cb,cbStorePut);break;/**
	     * no need of case here since it will be caught by default
	     * and jshint comply that before default it must be a break
	     * anyway it will result in -1 evaluation
	     */case 0:/* falls through */default:sendPacket(this,packet,cb);break;}debug('_sendPacket :: (%s) ::  end',this.options.clientId);};/**
	 * _storePacket - queue a packet
	 * @param {Object} packet - packet options
	 * @param {Function} cb - callback when the packet is sent
	 * @param {Function} cbStorePut - called when message is put into outgoingStore
	 * @api private
	 */MqttClient.prototype._storePacket=function(packet,cb,cbStorePut){debug('_storePacket :: packet: %o',packet);debug('_storePacket :: cb? %s',!!cb);cbStorePut=cbStorePut||nop;var storePacket=packet;if(storePacket.cmd==='publish'){// The original packet is for sending.
// The cloned storePacket is for storing to resend on reconnect.
// Topic Alias must not be used after disconnected.
storePacket=clone(packet);var err=removeTopicAliasAndRecoverTopicName(this,storePacket);if(err){return cb&&cb(err);}}// check that the packet is not a qos of 0, or that the command is not a publish
if((storePacket.qos||0)===0&&this.queueQoSZero||storePacket.cmd!=='publish'){this.queue.push({packet:storePacket,cb:cb});}else if(storePacket.qos>0){cb=this.outgoing[storePacket.messageId]?this.outgoing[storePacket.messageId].cb:null;this.outgoingStore.put(storePacket,function(err){if(err){return cb&&cb(err);}cbStorePut();});}else if(cb){cb(new Error('No connection to broker'));}};/**
	 * _setupPingTimer - setup the ping timer
	 *
	 * @api private
	 */MqttClient.prototype._setupPingTimer=function(){debug('_setupPingTimer :: keepalive %d (seconds)',this.options.keepalive);var that=this;if(!this.pingTimer&&this.options.keepalive){this.pingResp=true;this.pingTimer=reInterval(function(){that._checkPing();},this.options.keepalive*1000);}};/**
	 * _shiftPingInterval - reschedule the ping interval
	 *
	 * @api private
	 */MqttClient.prototype._shiftPingInterval=function(){if(this.pingTimer&&this.options.keepalive&&this.options.reschedulePings){this.pingTimer.reschedule(this.options.keepalive*1000);}};/**
	 * _checkPing - check if a pingresp has come back, and ping the server again
	 *
	 * @api private
	 */MqttClient.prototype._checkPing=function(){debug('_checkPing :: checking ping...');if(this.pingResp){debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');this.pingResp=false;this._sendPacket({cmd:'pingreq'});}else {// do a forced cleanup since socket will be in bad shape
debug('_checkPing :: calling _cleanUp with force true');this._cleanUp(true);}};/**
	 * _handlePingresp - handle a pingresp
	 *
	 * @api private
	 */MqttClient.prototype._handlePingresp=function(){this.pingResp=true;};/**
	 * _handleConnack
	 *
	 * @param {Object} packet
	 * @api private
	 */MqttClient.prototype._handleConnack=function(packet){debug('_handleConnack');var options=this.options;var version=options.protocolVersion;var rc=version===5?packet.reasonCode:packet.returnCode;clearTimeout(this.connackTimer);delete this.topicAliasSend;if(packet.properties){if(packet.properties.topicAliasMaximum){if(packet.properties.topicAliasMaximum>0xffff){this.emit('error',new Error('topicAliasMaximum from broker is out of range'));return;}if(packet.properties.topicAliasMaximum>0){this.topicAliasSend=new TopicAliasSend(packet.properties.topicAliasMaximum);}}if(packet.properties.serverKeepAlive&&options.keepalive){options.keepalive=packet.properties.serverKeepAlive;this._shiftPingInterval();}if(packet.properties.maximumPacketSize){if(!options.properties){options.properties={};}options.properties.maximumPacketSize=packet.properties.maximumPacketSize;}}if(rc===0){this.reconnecting=false;this._onConnect(packet);}else if(rc>0){var err=new Error('Connection refused: '+errors[rc]);err.code=rc;this.emit('error',err);}};MqttClient.prototype._handleAuth=function(packet){var options=this.options;var version=options.protocolVersion;var rc=version===5?packet.reasonCode:packet.returnCode;if(version!==5){var err=new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:'+version);err.code=rc;this.emit('error',err);return;}var that=this;this.handleAuth(packet,function(err,packet){if(err){that.emit('error',err);return;}if(rc===24){that.reconnecting=false;that._sendPacket(packet);}else {var error=new Error('Connection refused: '+errors[rc]);err.code=rc;that.emit('error',error);}});};/**
	 * @param packet the packet received by the broker
	 * @return the auth packet to be returned to the broker
	 * @api public
	 */MqttClient.prototype.handleAuth=function(packet,callback){callback();};/**
	 * _handlePublish
	 *
	 * @param {Object} packet
	 * @api private
	 */ /*
	those late 2 case should be rewrite to comply with coding style:

	case 1:
	case 0:
	  // do not wait sending a puback
	  // no callback passed
	  if (1 === qos) {
	    this._sendPacket({
	      cmd: 'puback',
	      messageId: messageId
	    });
	  }
	  // emit the message event for both qos 1 and 0
	  this.emit('message', topic, message, packet);
	  this.handleMessage(packet, done);
	  break;
	default:
	  // do nothing but every switch mus have a default
	  // log or throw an error about unknown qos
	  break;

	for now i just suppressed the warnings
	*/MqttClient.prototype._handlePublish=function(packet,done){debug('_handlePublish: packet %o',packet);done=typeof done!=='undefined'?done:nop;var topic=packet.topic.toString();var message=packet.payload;var qos=packet.qos;var messageId=packet.messageId;var that=this;var options=this.options;var validReasonCodes=[0,16,128,131,135,144,145,151,153];if(this.options.protocolVersion===5){var alias;if(packet.properties){alias=packet.properties.topicAlias;}if(typeof alias!=='undefined'){if(topic.length===0){if(alias>0&&alias<=0xffff){var gotTopic=this.topicAliasRecv.getTopicByAlias(alias);if(gotTopic){topic=gotTopic;debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d',topic,alias);}else {debug('_handlePublish :: unregistered topic alias. alias: %d',alias);this.emit('error',new Error('Received unregistered Topic Alias'));return;}}else {debug('_handlePublish :: topic alias out of range. alias: %d',alias);this.emit('error',new Error('Received Topic Alias is out of range'));return;}}else {if(this.topicAliasRecv.put(topic,alias)){debug('_handlePublish :: registered topic: %s - alias: %d',topic,alias);}else {debug('_handlePublish :: topic alias out of range. alias: %d',alias);this.emit('error',new Error('Received Topic Alias is out of range'));return;}}}}debug('_handlePublish: qos %d',qos);switch(qos){case 2:{options.customHandleAcks(topic,message,packet,function(error,code){if(!(error instanceof Error)){code=error;error=null;}if(error){return that.emit('error',error);}if(validReasonCodes.indexOf(code)===-1){return that.emit('error',new Error('Wrong reason code for pubrec'));}if(code){that._sendPacket({cmd:'pubrec',messageId:messageId,reasonCode:code},done);}else {that.incomingStore.put(packet,function(){that._sendPacket({cmd:'pubrec',messageId:messageId},done);});}});break;}case 1:{// emit the message event
options.customHandleAcks(topic,message,packet,function(error,code){if(!(error instanceof Error)){code=error;error=null;}if(error){return that.emit('error',error);}if(validReasonCodes.indexOf(code)===-1){return that.emit('error',new Error('Wrong reason code for puback'));}if(!code){that.emit('message',topic,message,packet);}that.handleMessage(packet,function(err){if(err){return done&&done(err);}that._sendPacket({cmd:'puback',messageId:messageId,reasonCode:code},done);});});break;}case 0:// emit the message event
this.emit('message',topic,message,packet);this.handleMessage(packet,done);break;default:// do nothing
debug('_handlePublish: unknown QoS. Doing nothing.');// log or throw an error about unknown qos
break;}};/**
	 * Handle messages with backpressure support, one at a time.
	 * Override at will.
	 *
	 * @param Packet packet the packet
	 * @param Function callback call when finished
	 * @api public
	 */MqttClient.prototype.handleMessage=function(packet,callback){callback();};/**
	 * _handleAck
	 *
	 * @param {Object} packet
	 * @api private
	 */MqttClient.prototype._handleAck=function(packet){/* eslint no-fallthrough: "off" */var messageId=packet.messageId;var type=packet.cmd;var response=null;var cb=this.outgoing[messageId]?this.outgoing[messageId].cb:null;var that=this;var err;// Checking `!cb` happens to work, but it's not technically "correct".
//
// Why? This code assumes that "no callback" is the same as that "we're not
// waiting for responses" (puback, pubrec, pubcomp, suback, or unsuback).
//
// It would be better to check `if (!this.outgoing[messageId])` here, but
// there's no reason to change it and risk (another) regression.
//
// The only reason this code works is becaues code in MqttClient.publish,
// MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will
// have a callback even if the user doesn't pass one in.)
if(!cb){debug('_handleAck :: Server sent an ack in error. Ignoring.');// Server sent an ack in error, ignore it.
return;}// Process
debug('_handleAck :: packet type',type);switch(type){case'pubcomp':// same thing as puback for QoS 2
case'puback':{var pubackRC=packet.reasonCode;// Callback - we're done
if(pubackRC&&pubackRC>0&&pubackRC!==16){err=new Error('Publish error: '+errors[pubackRC]);err.code=pubackRC;cb(err,packet);}delete this.outgoing[messageId];this.outgoingStore.del(packet,cb);this.messageIdProvider.deallocate(messageId);this._invokeStoreProcessingQueue();break;}case'pubrec':{response={cmd:'pubrel',qos:2,messageId:messageId};var pubrecRC=packet.reasonCode;if(pubrecRC&&pubrecRC>0&&pubrecRC!==16){err=new Error('Publish error: '+errors[pubrecRC]);err.code=pubrecRC;cb(err,packet);}else {this._sendPacket(response);}break;}case'suback':{delete this.outgoing[messageId];this.messageIdProvider.deallocate(messageId);for(var grantedI=0;grantedI<packet.granted.length;grantedI++){if((packet.granted[grantedI]&0x80)!==0){// suback with Failure status
var topics=this.messageIdToTopic[messageId];if(topics){topics.forEach(function(topic){delete that._resubscribeTopics[topic];});}}}this._invokeStoreProcessingQueue();cb(null,packet);break;}case'unsuback':{delete this.outgoing[messageId];this.messageIdProvider.deallocate(messageId);this._invokeStoreProcessingQueue();cb(null);break;}default:that.emit('error',new Error('unrecognized packet type'));}if(this.disconnecting&&Object.keys(this.outgoing).length===0){this.emit('outgoingEmpty');}};/**
	 * _handlePubrel
	 *
	 * @param {Object} packet
	 * @api private
	 */MqttClient.prototype._handlePubrel=function(packet,callback){debug('handling pubrel packet');callback=typeof callback!=='undefined'?callback:nop;var messageId=packet.messageId;var that=this;var comp={cmd:'pubcomp',messageId:messageId};that.incomingStore.get(packet,function(err,pub){if(!err){that.emit('message',pub.topic,pub.payload,pub);that.handleMessage(pub,function(err){if(err){return callback(err);}that.incomingStore.del(pub,nop);that._sendPacket(comp,callback);});}else {that._sendPacket(comp,callback);}});};/**
	 * _handleDisconnect
	 *
	 * @param {Object} packet
	 * @api private
	 */MqttClient.prototype._handleDisconnect=function(packet){this.emit('disconnect',packet);};/**
	 * _nextId
	 * @return unsigned int
	 */MqttClient.prototype._nextId=function(){return this.messageIdProvider.allocate();};/**
	 * getLastMessageId
	 * @return unsigned int
	 */MqttClient.prototype.getLastMessageId=function(){return this.messageIdProvider.getLastAllocated();};/**
	 * _resubscribe
	 * @api private
	 */MqttClient.prototype._resubscribe=function(){debug('_resubscribe');var _resubscribeTopicsKeys=Object.keys(this._resubscribeTopics);if(!this._firstConnection&&(this.options.clean||this.options.protocolVersion===5&&!this.connackPacket.sessionPresent)&&_resubscribeTopicsKeys.length>0){if(this.options.resubscribe){if(this.options.protocolVersion===5){debug('_resubscribe: protocolVersion 5');for(var topicI=0;topicI<_resubscribeTopicsKeys.length;topicI++){var resubscribeTopic={};resubscribeTopic[_resubscribeTopicsKeys[topicI]]=this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];resubscribeTopic.resubscribe=true;this.subscribe(resubscribeTopic,{properties:resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties});}}else {this._resubscribeTopics.resubscribe=true;this.subscribe(this._resubscribeTopics);}}else {this._resubscribeTopics={};}}this._firstConnection=false;};/**
	 * _onConnect
	 *
	 * @api private
	 */MqttClient.prototype._onConnect=function(packet){if(this.disconnected){this.emit('connect',packet);return;}var that=this;this.connackPacket=packet;this.messageIdProvider.clear();this._setupPingTimer();this.connected=true;function startStreamProcess(){var outStore=that.outgoingStore.createStream();function clearStoreProcessing(){that._storeProcessing=false;that._packetIdsDuringStoreProcessing={};}that.once('close',remove);outStore.on('error',function(err){clearStoreProcessing();that._flushStoreProcessingQueue();that.removeListener('close',remove);that.emit('error',err);});function remove(){outStore.destroy();outStore=null;that._flushStoreProcessingQueue();clearStoreProcessing();}function storeDeliver(){// edge case, we wrapped this twice
if(!outStore){return;}that._storeProcessing=true;var packet=outStore.read(1);var _cb;if(!packet){// read when data is available in the future
outStore.once('readable',storeDeliver);return;}// Skip already processed store packets
if(that._packetIdsDuringStoreProcessing[packet.messageId]){storeDeliver();return;}// Avoid unnecessary stream read operations when disconnected
if(!that.disconnecting&&!that.reconnectTimer){_cb=that.outgoing[packet.messageId]?that.outgoing[packet.messageId].cb:null;that.outgoing[packet.messageId]={"volatile":false,cb:function cb(err,status){// Ensure that the original callback passed in to publish gets invoked
if(_cb){_cb(err,status);}storeDeliver();}};that._packetIdsDuringStoreProcessing[packet.messageId]=true;if(that.messageIdProvider.register(packet.messageId)){that._sendPacket(packet);}else {debug('messageId: %d has already used.',packet.messageId);}}else if(outStore.destroy){outStore.destroy();}}outStore.on('end',function(){var allProcessed=true;for(var id in that._packetIdsDuringStoreProcessing){if(!that._packetIdsDuringStoreProcessing[id]){allProcessed=false;break;}}if(allProcessed){clearStoreProcessing();that.removeListener('close',remove);that._invokeAllStoreProcessingQueue();that.emit('connect',packet);}else {startStreamProcess();}});storeDeliver();}// start flowing
startStreamProcess();};MqttClient.prototype._invokeStoreProcessingQueue=function(){if(this._storeProcessingQueue.length>0){var f=this._storeProcessingQueue[0];if(f&&f.invoke()){this._storeProcessingQueue.shift();return true;}}return false;};MqttClient.prototype._invokeAllStoreProcessingQueue=function(){while(this._invokeStoreProcessingQueue()){/* empty */}};MqttClient.prototype._flushStoreProcessingQueue=function(){var _iterator=_createForOfIteratorHelper(this._storeProcessingQueue),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var f=_step.value;if(f.cbStorePut)f.cbStorePut(new Error('Connection closed'));if(f.callback)f.callback(new Error('Connection closed'));}}catch(err){_iterator.e(err);}finally{_iterator.f();}this._storeProcessingQueue.splice(0);};module.exports=MqttClient;}).call(this);}).call(this,require('_process'),typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"./default-message-id-provider":7,"./store":8,"./topic-alias-recv":9,"./topic-alias-send":10,"./validations":11,"_process":50,"debug":18,"events":22,"inherits":24,"mqtt-packet":40,"readable-stream":69,"reinterval":70,"rfdc/default":71,"xtend":81}],2:[function(require,module,exports){var _require3=require('buffer'),Buffer=_require3.Buffer;var Transform=require('readable-stream').Transform;var duplexify=require('duplexify');/* global FileReader */var my;var proxy;var stream;var isInitialized=false;function buildProxy(){var proxy=new Transform();proxy._write=function(chunk,encoding,next){my.sendSocketMessage({data:chunk.buffer,success:function success(){next();},fail:function fail(){next(new Error());}});};proxy._flush=function socketEnd(done){my.closeSocket({success:function success(){done();}});};return proxy;}function setDefaultOpts(opts){if(!opts.hostname){opts.hostname='localhost';}if(!opts.path){opts.path='/';}if(!opts.wsOptions){opts.wsOptions={};}}function buildUrl(opts,client){var protocol=opts.protocol==='alis'?'wss':'ws';var url=protocol+'://'+opts.hostname+opts.path;if(opts.port&&opts.port!==80&&opts.port!==443){url=protocol+'://'+opts.hostname+':'+opts.port+opts.path;}if(typeof opts.transformWsUrl==='function'){url=opts.transformWsUrl(url,opts,client);}return url;}function bindEventHandler(){if(isInitialized)return;isInitialized=true;my.onSocketOpen(function(){stream.setReadable(proxy);stream.setWritable(proxy);stream.emit('connect');});my.onSocketMessage(function(res){if(typeof res.data==='string'){var buffer=Buffer.from(res.data,'base64');proxy.push(buffer);}else {var reader=new FileReader();reader.addEventListener('load',function(){var data=reader.result;if(data instanceof ArrayBuffer)data=Buffer.from(data);else data=Buffer.from(data,'utf8');proxy.push(data);});reader.readAsArrayBuffer(res.data);}});my.onSocketClose(function(){stream.end();stream.destroy();});my.onSocketError(function(res){stream.destroy(res);});}function buildStream(client,opts){opts.hostname=opts.hostname||opts.host;if(!opts.hostname){throw new Error('Could not determine host. Specify host manually.');}var websocketSubProtocol=opts.protocolId==='MQIsdp'&&opts.protocolVersion===3?'mqttv3.1':'mqtt';setDefaultOpts(opts);var url=buildUrl(opts,client);my=opts.my;my.connectSocket({url:url,protocols:websocketSubProtocol});proxy=buildProxy();stream=duplexify.obj();bindEventHandler();return stream;}module.exports=buildStream;},{"buffer":17,"duplexify":20,"readable-stream":69}],3:[function(require,module,exports){var net=require('net');var debug=require('debug')('mqttjs:tcp');/*
	  variables port and host can be removed since
	  you have all required information in opts object
	*/function streamBuilder(client,opts){opts.port=opts.port||1883;opts.hostname=opts.hostname||opts.host||'localhost';var port=opts.port;var host=opts.hostname;debug('port %d and host %s',port,host);return net.createConnection(port,host);}module.exports=streamBuilder;},{"debug":18,"net":16}],4:[function(require,module,exports){var tls=require('tls');var net=require('net');var debug=require('debug')('mqttjs:tls');function buildBuilder(mqttClient,opts){opts.port=opts.port||8883;opts.host=opts.hostname||opts.host||'localhost';if(net.isIP(opts.host)===0){opts.servername=opts.host;}opts.rejectUnauthorized=opts.rejectUnauthorized!==false;delete opts.path;debug('port %d host %s rejectUnauthorized %b',opts.port,opts.host,opts.rejectUnauthorized);var connection=tls.connect(opts);/* eslint no-use-before-define: [2, "nofunc"] */connection.on('secureConnect',function(){if(opts.rejectUnauthorized&&!connection.authorized){connection.emit('error',new Error('TLS not authorized'));}else {connection.removeListener('error',handleTLSerrors);}});function handleTLSerrors(err){// How can I get verify this error is a tls error?
if(opts.rejectUnauthorized){mqttClient.emit('error',err);}// close this connection to match the behaviour of net
// otherwise all we get is an error from the connection
// and close event doesn't fire. This is a work around
// to enable the reconnect code to work the same as with
// net.createConnection
connection.end();}connection.on('error',handleTLSerrors);return connection;}module.exports=buildBuilder;},{"debug":18,"net":16,"tls":16}],5:[function(require,module,exports){(function(process){(function(){var _require4=require('buffer'),Buffer=_require4.Buffer;var WS=require('ws');var debug=require('debug')('mqttjs:ws');var duplexify=require('duplexify');var Transform=require('readable-stream').Transform;var WSS_OPTIONS=['rejectUnauthorized','ca','cert','key','pfx','passphrase'];// eslint-disable-next-line camelcase
var IS_BROWSER=typeof process!=='undefined'&&process.title==='browser'||typeof __webpack_require__==='function';function buildUrl(opts,client){var url=opts.protocol+'://'+opts.hostname+':'+opts.port+opts.path;if(typeof opts.transformWsUrl==='function'){url=opts.transformWsUrl(url,opts,client);}return url;}function setDefaultOpts(opts){var options=opts;if(!opts.hostname){options.hostname='localhost';}if(!opts.port){if(opts.protocol==='wss'){options.port=443;}else {options.port=80;}}if(!opts.path){options.path='/';}if(!opts.wsOptions){options.wsOptions={};}if(!IS_BROWSER&&opts.protocol==='wss'){// Add cert/key/ca etc options
WSS_OPTIONS.forEach(function(prop){if(Object.prototype.hasOwnProperty.call(opts,prop)&&!Object.prototype.hasOwnProperty.call(opts.wsOptions,prop)){options.wsOptions[prop]=opts[prop];}});}return options;}function setDefaultBrowserOpts(opts){var options=setDefaultOpts(opts);if(!options.hostname){options.hostname=options.host;}if(!options.hostname){// Throwing an error in a Web Worker if no `hostname` is given, because we
// can not determine the `hostname` automatically.  If connecting to
// localhost, please supply the `hostname` as an argument.
if(typeof document==='undefined'){throw new Error('Could not determine host. Specify host manually.');}var parsed=new URL(document.URL);options.hostname=parsed.hostname;if(!options.port){options.port=parsed.port;}}// objectMode should be defined for logic
if(options.objectMode===undefined){options.objectMode=!(options.binary===true||options.binary===undefined);}return options;}function createWebSocket(client,url,opts){debug('createWebSocket');debug('protocol: '+opts.protocolId+' '+opts.protocolVersion);var websocketSubProtocol=opts.protocolId==='MQIsdp'&&opts.protocolVersion===3?'mqttv3.1':'mqtt';debug('creating new Websocket for url: '+url+' and protocol: '+websocketSubProtocol);var socket=new WS(url,[websocketSubProtocol],opts.wsOptions);return socket;}function createBrowserWebSocket(client,opts){var websocketSubProtocol=opts.protocolId==='MQIsdp'&&opts.protocolVersion===3?'mqttv3.1':'mqtt';var url=buildUrl(opts,client);/* global WebSocket */var socket=new WebSocket(url,[websocketSubProtocol]);socket.binaryType='arraybuffer';return socket;}function streamBuilder(client,opts){debug('streamBuilder');var options=setDefaultOpts(opts);var url=buildUrl(options,client);var socket=createWebSocket(client,url,options);var webSocketStream=WS.createWebSocketStream(socket,options.wsOptions);webSocketStream.url=url;socket.on('close',function(){webSocketStream.destroy();});return webSocketStream;}function browserStreamBuilder(client,opts){debug('browserStreamBuilder');var stream;var options=setDefaultBrowserOpts(opts);// sets the maximum socket buffer size before throttling
var bufferSize=options.browserBufferSize||1024*512;var bufferTimeout=opts.browserBufferTimeout||1000;var coerceToBuffer=!opts.objectMode;var socket=createBrowserWebSocket(client,opts);var proxy=buildProxy(opts,socketWriteBrowser,socketEndBrowser);if(!opts.objectMode){proxy._writev=writev;}proxy.on('close',function(){socket.close();});var eventListenerSupport=typeof socket.addEventListener!=='undefined';// was already open when passed in
if(socket.readyState===socket.OPEN){stream=proxy;}else {stream=stream=duplexify(undefined,undefined,opts);if(!opts.objectMode){stream._writev=writev;}if(eventListenerSupport){socket.addEventListener('open',onopen);}else {socket.onopen=onopen;}}stream.socket=socket;if(eventListenerSupport){socket.addEventListener('close',onclose);socket.addEventListener('error',onerror);socket.addEventListener('message',onmessage);}else {socket.onclose=onclose;socket.onerror=onerror;socket.onmessage=onmessage;}// methods for browserStreamBuilder
function buildProxy(options,socketWrite,socketEnd){var proxy=new Transform({objectModeMode:options.objectMode});proxy._write=socketWrite;proxy._flush=socketEnd;return proxy;}function onopen(){stream.setReadable(proxy);stream.setWritable(proxy);stream.emit('connect');}function onclose(){stream.end();stream.destroy();}function onerror(err){stream.destroy(err);}function onmessage(event){var data=event.data;if(data instanceof ArrayBuffer)data=Buffer.from(data);else data=Buffer.from(data,'utf8');proxy.push(data);}// this is to be enabled only if objectMode is false
function writev(chunks,cb){var buffers=new Array(chunks.length);for(var i=0;i<chunks.length;i++){if(typeof chunks[i].chunk==='string'){buffers[i]=Buffer.from(chunks[i],'utf8');}else {buffers[i]=chunks[i].chunk;}}this._write(Buffer.concat(buffers),'binary',cb);}function socketWriteBrowser(chunk,enc,next){if(socket.bufferedAmount>bufferSize){// throttle data until buffered amount is reduced.
setTimeout(socketWriteBrowser,bufferTimeout,chunk,enc,next);}if(coerceToBuffer&&typeof chunk==='string'){chunk=Buffer.from(chunk,'utf8');}try{socket.send(chunk);}catch(err){return next(err);}next();}function socketEndBrowser(done){socket.close();done();}// end methods for browserStreamBuilder
return stream;}if(IS_BROWSER){module.exports=browserStreamBuilder;}else {module.exports=streamBuilder;}}).call(this);}).call(this,require('_process'));},{"_process":50,"buffer":17,"debug":18,"duplexify":20,"readable-stream":69,"ws":80}],6:[function(require,module,exports){var _require5=require('buffer'),Buffer=_require5.Buffer;var Transform=require('readable-stream').Transform;var duplexify=require('duplexify');/* global wx */var socketTask,proxy,stream;function buildProxy(){var proxy=new Transform();proxy._write=function(chunk,encoding,next){socketTask.send({data:chunk.buffer,success:function success(){next();},fail:function fail(errMsg){next(new Error(errMsg));}});};proxy._flush=function socketEnd(done){socketTask.close({success:function success(){done();}});};return proxy;}function setDefaultOpts(opts){if(!opts.hostname){opts.hostname='localhost';}if(!opts.path){opts.path='/';}if(!opts.wsOptions){opts.wsOptions={};}}function buildUrl(opts,client){var protocol=opts.protocol==='wxs'?'wss':'ws';var url=protocol+'://'+opts.hostname+opts.path;if(opts.port&&opts.port!==80&&opts.port!==443){url=protocol+'://'+opts.hostname+':'+opts.port+opts.path;}if(typeof opts.transformWsUrl==='function'){url=opts.transformWsUrl(url,opts,client);}return url;}function bindEventHandler(){socketTask.onOpen(function(){stream.setReadable(proxy);stream.setWritable(proxy);stream.emit('connect');});socketTask.onMessage(function(res){var data=res.data;if(data instanceof ArrayBuffer)data=Buffer.from(data);else data=Buffer.from(data,'utf8');proxy.push(data);});socketTask.onClose(function(){stream.end();stream.destroy();});socketTask.onError(function(res){stream.destroy(new Error(res.errMsg));});}function buildStream(client,opts){opts.hostname=opts.hostname||opts.host;if(!opts.hostname){throw new Error('Could not determine host. Specify host manually.');}var websocketSubProtocol=opts.protocolId==='MQIsdp'&&opts.protocolVersion===3?'mqttv3.1':'mqtt';setDefaultOpts(opts);var url=buildUrl(opts,client);socketTask=wx.connectSocket({url:url,protocols:[websocketSubProtocol]});proxy=buildProxy();stream=duplexify.obj();stream._destroy=function(err,cb){socketTask.close({success:function success(){cb&&cb(err);}});};var destroyRef=stream.destroy;stream.destroy=function(){stream.destroy=destroyRef;var self=this;setTimeout(function(){socketTask.close({fail:function fail(){self._destroy(new Error());}});},0);}.bind(stream);bindEventHandler();return stream;}module.exports=buildStream;},{"buffer":17,"duplexify":20,"readable-stream":69}],7:[function(require,module,exports){/**
	 * DefaultMessageAllocator constructor
	 * @constructor
	 */function DefaultMessageIdProvider(){if(!(this instanceof DefaultMessageIdProvider)){return new DefaultMessageIdProvider();}/**
	   * MessageIDs starting with 1
	   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810
	   */this.nextId=Math.max(1,Math.floor(Math.random()*65535));}/**
	 * allocate
	 *
	 * Get the next messageId.
	 * @return unsigned int
	 */DefaultMessageIdProvider.prototype.allocate=function(){// id becomes current state of this.nextId and increments afterwards
var id=this.nextId++;// Ensure 16 bit unsigned int (max 65535, nextId got one higher)
if(this.nextId===65536){this.nextId=1;}return id;};/**
	 * getLastAllocated
	 * Get the last allocated messageId.
	 * @return unsigned int
	 */DefaultMessageIdProvider.prototype.getLastAllocated=function(){return this.nextId===1?65535:this.nextId-1;};/**
	 * register
	 * Register messageId. If success return true, otherwise return false.
	 * @param { unsigned int } - messageId to register,
	 * @return boolean
	 */DefaultMessageIdProvider.prototype.register=function(messageId){return true;};/**
	 * deallocate
	 * Deallocate messageId.
	 * @param { unsigned int } - messageId to deallocate,
	 */DefaultMessageIdProvider.prototype.deallocate=function(messageId){};/**
	 * clear
	 * Deallocate all messageIds.
	 */DefaultMessageIdProvider.prototype.clear=function(){};module.exports=DefaultMessageIdProvider;},{}],8:[function(require,module,exports){/**
	 * Module dependencies
	 */var xtend=require('xtend');var Readable=require('readable-stream').Readable;var streamsOpts={objectMode:true};var defaultStoreOptions={clean:true};/**
	 * In-memory implementation of the message store
	 * This can actually be saved into files.
	 *
	 * @param {Object} [options] - store options
	 */function Store(options){if(!(this instanceof Store)){return new Store(options);}this.options=options||{};// Defaults
this.options=xtend(defaultStoreOptions,options);this._inflights=new Map();}/**
	 * Adds a packet to the store, a packet is
	 * anything that has a messageId property.
	 *
	 */Store.prototype.put=function(packet,cb){this._inflights.set(packet.messageId,packet);if(cb){cb();}return this;};/**
	 * Creates a stream with all the packets in the store
	 *
	 */Store.prototype.createStream=function(){var stream=new Readable(streamsOpts);var values=[];var destroyed=false;var i=0;this._inflights.forEach(function(value,key){values.push(value);});stream._read=function(){if(!destroyed&&i<values.length){this.push(values[i++]);}else {this.push(null);}};stream.destroy=function(){if(destroyed){return;}var self=this;destroyed=true;setTimeout(function(){self.emit('close');},0);};return stream;};/**
	 * deletes a packet from the store.
	 */Store.prototype.del=function(packet,cb){packet=this._inflights.get(packet.messageId);if(packet){this._inflights["delete"](packet.messageId);cb(null,packet);}else if(cb){cb(new Error('missing packet'));}return this;};/**
	 * get a packet from the store.
	 */Store.prototype.get=function(packet,cb){packet=this._inflights.get(packet.messageId);if(packet){cb(null,packet);}else if(cb){cb(new Error('missing packet'));}return this;};/**
	 * Close the store
	 */Store.prototype.close=function(cb){if(this.options.clean){this._inflights=null;}if(cb){cb();}};module.exports=Store;},{"readable-stream":69,"xtend":81}],9:[function(require,module,exports){/**
	 * Topic Alias receiving manager
	 * This holds alias to topic map
	 * @param {Number} [max] - topic alias maximum entries
	 */function TopicAliasRecv(max){if(!(this instanceof TopicAliasRecv)){return new TopicAliasRecv(max);}this.aliasToTopic={};this.max=max;}/**
	 * Insert or update topic - alias entry.
	 * @param {String} [topic] - topic
	 * @param {Number} [alias] - topic alias
	 * @returns {Boolean} - if success return true otherwise false
	 */TopicAliasRecv.prototype.put=function(topic,alias){if(alias===0||alias>this.max){return false;}this.aliasToTopic[alias]=topic;this.length=Object.keys(this.aliasToTopic).length;return true;};/**
	 * Get topic by alias
	 * @param {String} [topic] - topic
	 * @returns {Number} - if mapped topic exists return topic alias, otherwise return undefined
	 */TopicAliasRecv.prototype.getTopicByAlias=function(alias){return this.aliasToTopic[alias];};/**
	 * Clear all entries
	 */TopicAliasRecv.prototype.clear=function(){this.aliasToTopic={};};module.exports=TopicAliasRecv;},{}],10:[function(require,module,exports){/**
	 * Module dependencies
	 */var LruMap=require('lru-cache');var NumberAllocator=require('number-allocator').NumberAllocator;/**
	 * Topic Alias sending manager
	 * This holds both topic to alias and alias to topic map
	 * @param {Number} [max] - topic alias maximum entries
	 */function TopicAliasSend(max){if(!(this instanceof TopicAliasSend)){return new TopicAliasSend(max);}if(max>0){this.aliasToTopic=new LruMap({max:max});this.topicToAlias={};this.numberAllocator=new NumberAllocator(1,max);this.max=max;this.length=0;}}/**
	 * Insert or update topic - alias entry.
	 * @param {String} [topic] - topic
	 * @param {Number} [alias] - topic alias
	 * @returns {Boolean} - if success return true otherwise false
	 */TopicAliasSend.prototype.put=function(topic,alias){if(alias===0||alias>this.max){return false;}var entry=this.aliasToTopic.get(alias);if(entry){delete this.topicToAlias[entry];}this.aliasToTopic.set(alias,topic);this.topicToAlias[topic]=alias;this.numberAllocator.use(alias);this.length=this.aliasToTopic.length;return true;};/**
	 * Get topic by alias
	 * @param {Number} [alias] - topic alias
	 * @returns {String} - if mapped topic exists return topic, otherwise return undefined
	 */TopicAliasSend.prototype.getTopicByAlias=function(alias){return this.aliasToTopic.get(alias);};/**
	 * Get topic by alias
	 * @param {String} [topic] - topic
	 * @returns {Number} - if mapped topic exists return topic alias, otherwise return undefined
	 */TopicAliasSend.prototype.getAliasByTopic=function(topic){var alias=this.topicToAlias[topic];if(typeof alias!=='undefined'){this.aliasToTopic.get(alias);// LRU update
}return alias;};/**
	 * Clear all entries
	 */TopicAliasSend.prototype.clear=function(){this.aliasToTopic.reset();this.topicToAlias={};this.numberAllocator.clear();this.length=0;};/**
	 * Get Least Recently Used (LRU) topic alias
	 * @returns {Number} - if vacant alias exists then return it, otherwise then return LRU alias
	 */TopicAliasSend.prototype.getLruAlias=function(){var alias=this.numberAllocator.firstVacant();if(alias)return alias;return this.aliasToTopic.keys()[this.aliasToTopic.length-1];};module.exports=TopicAliasSend;},{"lru-cache":37,"number-allocator":46}],11:[function(require,module,exports){/**
	 * Validate a topic to see if it's valid or not.
	 * A topic is valid if it follow below rules:
	 * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'
	 * - Rule #2: Part `#` must be located at the end of the mailbox
	 *
	 * @param {String} topic - A topic
	 * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.
	 */function validateTopic(topic){var parts=topic.split('/');for(var i=0;i<parts.length;i++){if(parts[i]==='+'){continue;}if(parts[i]==='#'){// for Rule #2
return i===parts.length-1;}if(parts[i].indexOf('+')!==-1||parts[i].indexOf('#')!==-1){return false;}}return true;}/**
	 * Validate an array of topics to see if any of them is valid or not
	  * @param {Array} topics - Array of topics
	 * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one
	 */function validateTopics(topics){if(topics.length===0){return 'empty_topic_list';}for(var i=0;i<topics.length;i++){if(!validateTopic(topics[i])){return topics[i];}}return null;}module.exports={validateTopics:validateTopics};},{}],12:[function(require,module,exports){(function(process){(function(){var MqttClient=require('../client');var Store=require('../store');var url=require('url');var xtend=require('xtend');var debug=require('debug')('mqttjs');var protocols={};// eslint-disable-next-line camelcase
if(typeof process!=='undefined'&&process.title!=='browser'||typeof __webpack_require__!=='function'){protocols.mqtt=require('./tcp');protocols.tcp=require('./tcp');protocols.ssl=require('./tls');protocols.tls=require('./tls');protocols.mqtts=require('./tls');}else {protocols.wx=require('./wx');protocols.wxs=require('./wx');protocols.ali=require('./ali');protocols.alis=require('./ali');}protocols.ws=require('./ws');protocols.wss=require('./ws');/**
	 * Parse the auth attribute and merge username and password in the options object.
	 *
	 * @param {Object} [opts] option object
	 */function parseAuthOptions(opts){var matches;if(opts.auth){matches=opts.auth.match(/^(.+):(.+)$/);if(matches){opts.username=matches[1];opts.password=matches[2];}else {opts.username=opts.auth;}}}/**
	 * connect - connect to an MQTT broker.
	 *
	 * @param {String} [brokerUrl] - url of the broker, optional
	 * @param {Object} opts - see MqttClient#constructor
	 */function connect(brokerUrl,opts){debug('connecting to an MQTT broker...');if(_typeof(brokerUrl)==='object'&&!opts){opts=brokerUrl;brokerUrl=null;}opts=opts||{};if(brokerUrl){// eslint-disable-next-line
var parsed=url.parse(brokerUrl,true);if(parsed.port!=null){parsed.port=Number(parsed.port);}opts=xtend(parsed,opts);if(opts.protocol===null){throw new Error('Missing protocol');}opts.protocol=opts.protocol.replace(/:$/,'');}// merge in the auth options if supplied
parseAuthOptions(opts);// support clientId passed in the query string of the url
if(opts.query&&typeof opts.query.clientId==='string'){opts.clientId=opts.query.clientId;}if(opts.cert&&opts.key){if(opts.protocol){if(['mqtts','wss','wxs','alis'].indexOf(opts.protocol)===-1){switch(opts.protocol){case'mqtt':opts.protocol='mqtts';break;case'ws':opts.protocol='wss';break;case'wx':opts.protocol='wxs';break;case'ali':opts.protocol='alis';break;default:throw new Error('Unknown protocol for secure connection: "'+opts.protocol+'"!');}}}else {// A cert and key was provided, however no protocol was specified, so we will throw an error.
throw new Error('Missing secure protocol key');}}if(!protocols[opts.protocol]){var isSecure=['mqtts','wss'].indexOf(opts.protocol)!==-1;opts.protocol=['mqtt','mqtts','ws','wss','wx','wxs','ali','alis'].filter(function(key,index){if(isSecure&&index%2===0){// Skip insecure protocols when requesting a secure one.
return false;}return typeof protocols[key]==='function';})[0];}if(opts.clean===false&&!opts.clientId){throw new Error('Missing clientId for unclean clients');}if(opts.protocol){opts.defaultProtocol=opts.protocol;}function wrapper(client){if(opts.servers){if(!client._reconnectCount||client._reconnectCount===opts.servers.length){client._reconnectCount=0;}opts.host=opts.servers[client._reconnectCount].host;opts.port=opts.servers[client._reconnectCount].port;opts.protocol=!opts.servers[client._reconnectCount].protocol?opts.defaultProtocol:opts.servers[client._reconnectCount].protocol;opts.hostname=opts.host;client._reconnectCount++;}debug('calling streambuilder for',opts.protocol);return protocols[opts.protocol](client,opts);}var client=new MqttClient(wrapper,opts);client.on('error',function(){/* Automatically set up client error handling */});return client;}module.exports=connect;module.exports.connect=connect;module.exports.MqttClient=MqttClient;module.exports.Store=Store;}).call(this);}).call(this,require('_process'));},{"../client":1,"../store":8,"./ali":2,"./tcp":3,"./tls":4,"./ws":5,"./wx":6,"_process":50,"debug":18,"url":76,"xtend":81}],13:[function(require,module,exports){exports.byteLength=byteLength;exports.toByteArray=toByteArray;exports.fromByteArray=fromByteArray;var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;function getLens(b64){var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var validLen=b64.indexOf('=');if(validLen===-1)validLen=len;var placeHoldersLen=validLen===len?0:4-validLen%4;return [validLen,placeHoldersLen];}// base64 is 4/3 + up to two characters of the original data
function byteLength(b64){var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];return (validLen+placeHoldersLen)*3/4-placeHoldersLen;}function _byteLength(b64,validLen,placeHoldersLen){return (validLen+placeHoldersLen)*3/4-placeHoldersLen;}function toByteArray(b64){var tmp;var lens=getLens(b64);var validLen=lens[0];var placeHoldersLen=lens[1];var arr=new Arr(_byteLength(b64,validLen,placeHoldersLen));var curByte=0;// if there are placeholders, only get up to the last complete 4 chars
var len=placeHoldersLen>0?validLen-4:validLen;var i;for(i=0;i<len;i+=4){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[curByte++]=tmp>>16&0xFF;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[curByte++]=tmp&0xFF;}if(placeHoldersLen===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[curByte++]=tmp>>8&0xFF;arr[curByte++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16&0xFF0000)+(uint8[i+1]<<8&0xFF00)+(uint8[i+2]&0xFF);output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes
var parts=[];var maxChunkLength=16383;// must be multiple of 3
// go through the array every three bytes, we'll deal with trailing stuff later
for(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes
if(extraBytes===1){tmp=uint8[len-1];parts.push(lookup[tmp>>2]+lookup[tmp<<4&0x3F]+'==');}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];parts.push(lookup[tmp>>10]+lookup[tmp>>4&0x3F]+lookup[tmp<<2&0x3F]+'=');}return parts.join('');}},{}],14:[function(require,module,exports){var _require6=require('buffer'),Buffer=_require6.Buffer;var symbol=Symbol["for"]('BufferList');function BufferList(buf){if(!(this instanceof BufferList)){return new BufferList(buf);}BufferList._init.call(this,buf);}BufferList._init=function _init(buf){Object.defineProperty(this,symbol,{value:true});this._bufs=[];this.length=0;if(buf){this.append(buf);}};BufferList.prototype._new=function _new(buf){return new BufferList(buf);};BufferList.prototype._offset=function _offset(offset){if(offset===0){return [0,0];}var tot=0;for(var i=0;i<this._bufs.length;i++){var _t=tot+this._bufs[i].length;if(offset<_t||i===this._bufs.length-1){return [i,offset-tot];}tot=_t;}};BufferList.prototype._reverseOffset=function(blOffset){var bufferId=blOffset[0];var offset=blOffset[1];for(var i=0;i<bufferId;i++){offset+=this._bufs[i].length;}return offset;};BufferList.prototype.get=function get(index){if(index>this.length||index<0){return undefined;}var offset=this._offset(index);return this._bufs[offset[0]][offset[1]];};BufferList.prototype.slice=function slice(start,end){if(typeof start==='number'&&start<0){start+=this.length;}if(typeof end==='number'&&end<0){end+=this.length;}return this.copy(null,0,start,end);};BufferList.prototype.copy=function copy(dst,dstStart,srcStart,srcEnd){if(typeof srcStart!=='number'||srcStart<0){srcStart=0;}if(typeof srcEnd!=='number'||srcEnd>this.length){srcEnd=this.length;}if(srcStart>=this.length){return dst||Buffer.alloc(0);}if(srcEnd<=0){return dst||Buffer.alloc(0);}var copy=!!dst;var off=this._offset(srcStart);var len=srcEnd-srcStart;var bytes=len;var bufoff=copy&&dstStart||0;var start=off[1];// copy/slice everything
if(srcStart===0&&srcEnd===this.length){if(!copy){// slice, but full concat if multiple buffers
return this._bufs.length===1?this._bufs[0]:Buffer.concat(this._bufs,this.length);}// copy, need to copy individual buffers
for(var i=0;i<this._bufs.length;i++){this._bufs[i].copy(dst,bufoff);bufoff+=this._bufs[i].length;}return dst;}// easy, cheap case where it's a subset of one of the buffers
if(bytes<=this._bufs[off[0]].length-start){return copy?this._bufs[off[0]].copy(dst,dstStart,start,start+bytes):this._bufs[off[0]].slice(start,start+bytes);}if(!copy){// a slice, we need something to copy in to
dst=Buffer.allocUnsafe(len);}for(var _i2=off[0];_i2<this._bufs.length;_i2++){var l=this._bufs[_i2].length-start;if(bytes>l){this._bufs[_i2].copy(dst,bufoff,start);bufoff+=l;}else {this._bufs[_i2].copy(dst,bufoff,start,start+bytes);bufoff+=l;break;}bytes-=l;if(start){start=0;}}// safeguard so that we don't return uninitialized memory
if(dst.length>bufoff)return dst.slice(0,bufoff);return dst;};BufferList.prototype.shallowSlice=function shallowSlice(start,end){start=start||0;end=typeof end!=='number'?this.length:end;if(start<0){start+=this.length;}if(end<0){end+=this.length;}if(start===end){return this._new();}var startOffset=this._offset(start);var endOffset=this._offset(end);var buffers=this._bufs.slice(startOffset[0],endOffset[0]+1);if(endOffset[1]===0){buffers.pop();}else {buffers[buffers.length-1]=buffers[buffers.length-1].slice(0,endOffset[1]);}if(startOffset[1]!==0){buffers[0]=buffers[0].slice(startOffset[1]);}return this._new(buffers);};BufferList.prototype.toString=function toString(encoding,start,end){return this.slice(start,end).toString(encoding);};BufferList.prototype.consume=function consume(bytes){// first, normalize the argument, in accordance with how Buffer does it
bytes=Math.trunc(bytes);// do nothing if not a positive number
if(Number.isNaN(bytes)||bytes<=0)return this;while(this._bufs.length){if(bytes>=this._bufs[0].length){bytes-=this._bufs[0].length;this.length-=this._bufs[0].length;this._bufs.shift();}else {this._bufs[0]=this._bufs[0].slice(bytes);this.length-=bytes;break;}}return this;};BufferList.prototype.duplicate=function duplicate(){var copy=this._new();for(var i=0;i<this._bufs.length;i++){copy.append(this._bufs[i]);}return copy;};BufferList.prototype.append=function append(buf){if(buf==null){return this;}if(buf.buffer){// append a view of the underlying ArrayBuffer
this._appendBuffer(Buffer.from(buf.buffer,buf.byteOffset,buf.byteLength));}else if(Array.isArray(buf)){for(var i=0;i<buf.length;i++){this.append(buf[i]);}}else if(this._isBufferList(buf)){// unwrap argument into individual BufferLists
for(var _i3=0;_i3<buf._bufs.length;_i3++){this.append(buf._bufs[_i3]);}}else {// coerce number arguments to strings, since Buffer(number) does
// uninitialized memory allocation
if(typeof buf==='number'){buf=buf.toString();}this._appendBuffer(Buffer.from(buf));}return this;};BufferList.prototype._appendBuffer=function appendBuffer(buf){this._bufs.push(buf);this.length+=buf.length;};BufferList.prototype.indexOf=function(search,offset,encoding){if(encoding===undefined&&typeof offset==='string'){encoding=offset;offset=undefined;}if(typeof search==='function'||Array.isArray(search)){throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');}else if(typeof search==='number'){search=Buffer.from([search]);}else if(typeof search==='string'){search=Buffer.from(search,encoding);}else if(this._isBufferList(search)){search=search.slice();}else if(Array.isArray(search.buffer)){search=Buffer.from(search.buffer,search.byteOffset,search.byteLength);}else if(!Buffer.isBuffer(search)){search=Buffer.from(search);}offset=Number(offset||0);if(isNaN(offset)){offset=0;}if(offset<0){offset=this.length+offset;}if(offset<0){offset=0;}if(search.length===0){return offset>this.length?this.length:offset;}var blOffset=this._offset(offset);var blIndex=blOffset[0];// index of which internal buffer we're working on
var buffOffset=blOffset[1];// offset of the internal buffer we're working on
// scan over each buffer
for(;blIndex<this._bufs.length;blIndex++){var buff=this._bufs[blIndex];while(buffOffset<buff.length){var availableWindow=buff.length-buffOffset;if(availableWindow>=search.length){var nativeSearchResult=buff.indexOf(search,buffOffset);if(nativeSearchResult!==-1){return this._reverseOffset([blIndex,nativeSearchResult]);}buffOffset=buff.length-search.length+1;// end of native search window
}else {var revOffset=this._reverseOffset([blIndex,buffOffset]);if(this._match(revOffset,search)){return revOffset;}buffOffset++;}}buffOffset=0;}return -1;};BufferList.prototype._match=function(offset,search){if(this.length-offset<search.length){return false;}for(var searchOffset=0;searchOffset<search.length;searchOffset++){if(this.get(offset+searchOffset)!==search[searchOffset]){return false;}}return true;};(function(){var methods={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(var m in methods){(function(m){if(methods[m]===null){BufferList.prototype[m]=function(offset,byteLength){return this.slice(offset,offset+byteLength)[m](0,byteLength);};}else {BufferList.prototype[m]=function(){var offset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return this.slice(offset,offset+methods[m])[m](0);};}})(m);}})();// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList=function _isBufferList(b){return b instanceof BufferList||BufferList.isBufferList(b);};BufferList.isBufferList=function isBufferList(b){return b!=null&&b[symbol];};module.exports=BufferList;},{"buffer":17}],15:[function(require,module,exports){var DuplexStream=require('readable-stream').Duplex;var inherits=require('inherits');var BufferList=require('./BufferList');function BufferListStream(callback){if(!(this instanceof BufferListStream)){return new BufferListStream(callback);}if(typeof callback==='function'){this._callback=callback;var piper=function piper(err){if(this._callback){this._callback(err);this._callback=null;}}.bind(this);this.on('pipe',function onPipe(src){src.on('error',piper);});this.on('unpipe',function onUnpipe(src){src.removeListener('error',piper);});callback=null;}BufferList._init.call(this,callback);DuplexStream.call(this);}inherits(BufferListStream,DuplexStream);Object.assign(BufferListStream.prototype,BufferList.prototype);BufferListStream.prototype._new=function _new(callback){return new BufferListStream(callback);};BufferListStream.prototype._write=function _write(buf,encoding,callback){this._appendBuffer(buf);if(typeof callback==='function'){callback();}};BufferListStream.prototype._read=function _read(size){if(!this.length){return this.push(null);}size=Math.min(size,this.length);this.push(this.slice(0,size));this.consume(size);};BufferListStream.prototype.end=function end(chunk){DuplexStream.prototype.end.call(this,chunk);if(this._callback){this._callback(null,this.slice());this._callback=null;}};BufferListStream.prototype._destroy=function _destroy(err,cb){this._bufs.length=0;this.length=0;cb(err);};BufferListStream.prototype._isBufferList=function _isBufferList(b){return b instanceof BufferListStream||b instanceof BufferList||BufferListStream.isBufferList(b);};BufferListStream.isBufferList=BufferList.isBufferList;module.exports=BufferListStream;module.exports.BufferListStream=BufferListStream;module.exports.BufferList=BufferList;},{"./BufferList":14,"inherits":24,"readable-stream":69}],16:[function(require,module,exports){},{}],17:[function(require,module,exports){(function(Buffer){(function(){var base64=require('base64-js');var ieee754=require('ieee754');exports.Buffer=Buffer;exports.SlowBuffer=SlowBuffer;exports.INSPECT_MAX_BYTES=50;var K_MAX_LENGTH=0x7fffffff;exports.kMaxLength=K_MAX_LENGTH;/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
	 *               implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * We report that the browser does not support typed arrays if the are not subclassable
	 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
	 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
	 * for __proto__ and has a buggy typed array implementation.
	 */Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!=='undefined'&&typeof console.error==='function'){console.error('This browser lacks typed array (Uint8Array) support which is required by '+'`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');}function typedArraySupport(){// Can typed array instances can be augmented?
try{var arr=new Uint8Array(1);arr.__proto__={__proto__:Uint8Array.prototype,foo:function foo(){return 42;}};return arr.foo()===42;}catch(e){return false;}}Object.defineProperty(Buffer.prototype,'parent',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.buffer;}});Object.defineProperty(Buffer.prototype,'offset',{enumerable:true,get:function get(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset;}});function createBuffer(length){if(length>K_MAX_LENGTH){throw new RangeError('The value "'+length+'" is invalid for option "size"');}// Return an augmented `Uint8Array` instance
var buf=new Uint8Array(length);buf.__proto__=Buffer.prototype;return buf;}/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */function Buffer(arg,encodingOrOffset,length){// Common case.
if(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new TypeError('The "string" argument must be of type string. Received type number');}return allocUnsafe(arg);}return from(arg,encodingOrOffset,length);}// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if(typeof Symbol!=='undefined'&&Symbol.species!=null&&Buffer[Symbol.species]===Buffer){Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:true,enumerable:false,writable:false});}Buffer.poolSize=8192;// not used by this implementation
function from(value,encodingOrOffset,length){if(typeof value==='string'){return fromString(value,encodingOrOffset);}if(ArrayBuffer.isView(value)){return fromArrayLike(value);}if(value==null){throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}if(isInstance(value,ArrayBuffer)||value&&isInstance(value.buffer,ArrayBuffer)){return fromArrayBuffer(value,encodingOrOffset,length);}if(typeof value==='number'){throw new TypeError('The "value" argument must not be of type number. Received type number');}var valueOf=value.valueOf&&value.valueOf();if(valueOf!=null&&valueOf!==value){return Buffer.from(valueOf,encodingOrOffset,length);}var b=fromObject(value);if(b)return b;if(typeof Symbol!=='undefined'&&Symbol.toPrimitive!=null&&typeof value[Symbol.toPrimitive]==='function'){return Buffer.from(value[Symbol.toPrimitive]('string'),encodingOrOffset,length);}throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, '+'or Array-like Object. Received type '+_typeof(value));}/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/Buffer.from=function(value,encodingOrOffset,length){return from(value,encodingOrOffset,length);};// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__=Uint8Array.prototype;Buffer.__proto__=Uint8Array;function assertSize(size){if(typeof size!=='number'){throw new TypeError('"size" argument must be of type number');}else if(size<0){throw new RangeError('The value "'+size+'" is invalid for option "size"');}}function alloc(size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This
// prevents accidentally sending in a number that would
// be interpretted as a start offset.
return typeof encoding==='string'?createBuffer(size).fill(fill,encoding):createBuffer(size).fill(fill);}return createBuffer(size);}/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/Buffer.alloc=function(size,fill,encoding){return alloc(size,fill,encoding);};function allocUnsafe(size){assertSize(size);return createBuffer(size<0?0:checked(size)|0);}/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */Buffer.allocUnsafe=function(size){return allocUnsafe(size);};/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(size);};function fromString(string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}var length=byteLength(string,encoding)|0;var buf=createBuffer(length);var actual=buf.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will
// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
buf=buf.slice(0,actual);}return buf;}function fromArrayLike(array){var length=array.length<0?0:checked(array.length)|0;var buf=createBuffer(length);for(var i=0;i<length;i+=1){buf[i]=array[i]&255;}return buf;}function fromArrayBuffer(array,byteOffset,length){if(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('"offset" is outside of buffer bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('"length" is outside of buffer bounds');}var buf;if(byteOffset===undefined&&length===undefined){buf=new Uint8Array(array);}else if(length===undefined){buf=new Uint8Array(array,byteOffset);}else {buf=new Uint8Array(array,byteOffset,length);}// Return an augmented `Uint8Array` instance
buf.__proto__=Buffer.prototype;return buf;}function fromObject(obj){if(Buffer.isBuffer(obj)){var len=checked(obj.length)|0;var buf=createBuffer(len);if(buf.length===0){return buf;}obj.copy(buf,0,0,len);return buf;}if(obj.length!==undefined){if(typeof obj.length!=='number'||numberIsNaN(obj.length)){return createBuffer(0);}return fromArrayLike(obj);}if(obj.type==='Buffer'&&Array.isArray(obj.data)){return fromArrayLike(obj.data);}}function checked(length){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(length>=K_MAX_LENGTH){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+K_MAX_LENGTH.toString(16)+' bytes');}return length|0;}function SlowBuffer(length){if(+length!=length){// eslint-disable-line eqeqeq
length=0;}return Buffer.alloc(+length);}Buffer.isBuffer=function isBuffer(b){return b!=null&&b._isBuffer===true&&b!==Buffer.prototype;// so Buffer.isBuffer(Buffer.prototype) will be false
};Buffer.compare=function compare(a,b){if(isInstance(a,Uint8Array))a=Buffer.from(a,a.offset,a.byteLength);if(isInstance(b,Uint8Array))b=Buffer.from(b,b.offset,b.byteLength);if(!Buffer.isBuffer(a)||!Buffer.isBuffer(b)){throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return -1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!Array.isArray(list)){throw new TypeError('"list" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(isInstance(buf,Uint8Array)){buf=Buffer.from(buf);}if(!Buffer.isBuffer(buf)){throw new TypeError('"list" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(Buffer.isBuffer(string)){return string.length;}if(ArrayBuffer.isView(string)||isInstance(string,ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. '+'Received type '+_typeof(string));}var len=string.length;var mustMatch=arguments.length>2&&arguments[2]===true;if(!mustMatch&&len===0)return 0;// Use a for loop to avoid recursion
var loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase){return mustMatch?-1:utf8ToBytes(string).length;// assume utf8
}encoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
// property of a typed array.
// This behaves neither like String nor Uint8Array in that we set start/end
// to their upper/lower bounds if the value passed is out of range.
// undefined is handled specially as per ECMA-262 6th Edition,
// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
if(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if(start>this.length){return '';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return '';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
end>>>=0;start>>>=0;if(end<=start){return '';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length;if(length===0)return '';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(b){if(!Buffer.isBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=exports.INSPECT_MAX_BYTES;str=this.toString('hex',0,max).replace(/(.{2})/g,'$1 ').trim();if(this.length>max)str+=' ... ';return '<Buffer '+str+'>';};Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(isInstance(target,Uint8Array)){target=Buffer.from(target,target.offset,target.byteLength);}if(!Buffer.isBuffer(target)){throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. '+'Received type '+_typeof(target));}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return -1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return -1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match
if(buffer.length===0)return -1;// Normalize byteOffset
if(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.
if(numberIsNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
byteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer
if(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return -1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return -1;}// Normalize val
if(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf
if(Buffer.isBuffer(val)){// Special case: looking for empty string/buffer always fails
if(val.length===0){return -1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]
if(typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else {return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return -1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else {return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else {if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else {if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return -1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else {length=Number(length);if(length>remaining){length=remaining;}}var strLen=string.length;if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(numberIsNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)
if(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)
}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])
}else if(isFinite(offset)){offset=offset>>>0;if(isFinite(length)){length=length>>>0;if(encoding===undefined)encoding='utf8';}else {encoding=length;length=undefined;}}else {throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write
return base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return {type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return base64.fromByteArray(buf);}else {return base64.fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
codePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)
codePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()
}// Decode in chunks to avoid "call stack size exceeded".
var res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=toHex(buf[i]);}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf=this.subarray(start,end);// Return an augmented `Uint8Array` instance
newBuf.__proto__=Buffer.prototype;return newBuf;};/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return (this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return (0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,4,this.length);return ieee754.read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){offset=offset>>>0;if(!noAssert)checkOffset(offset,8,this.length);return ieee754.read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!Buffer.isBuffer(buf))throw new TypeError('"buffer" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('"value" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;byteLength=byteLength>>>0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset>>>0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value&0xff;this[offset+1]=value>>>8;return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);this[offset]=value>>>8;this[offset+1]=value&0xff;return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset>>>0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,4);}ieee754.write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){value=+value;offset=offset>>>0;if(!noAssert){checkIEEE754(buf,value,offset,8);}ieee754.write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy=function copy(target,targetStart,start,end){if(!Buffer.isBuffer(target))throw new TypeError('argument should be a Buffer');if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done
if(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions
if(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('Index out of range');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?
if(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;if(this===target&&typeof Uint8Array.prototype.copyWithin==='function'){// Use built-in when available, missing from IE11
this.copyWithin(targetStart,start,end);}else if(this===target&&start<targetStart&&targetStart<end){// descending copy from end
for(var i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else {Uint8Array.prototype.set.call(target,this.subarray(start,end),targetStart);}return len;};// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:
if(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}if(val.length===1){var code=val.charCodeAt(0);if(encoding==='utf8'&&code<128||encoding==='latin1'){// Fast path: If `val` fits into a single byte, use that numeric value.
val=code;}}}else if(typeof val==='number'){val=val&255;}// Invalid ranges are not set to a default, so can range check early.
if(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else {var bytes=Buffer.isBuffer(val)?val:Buffer.from(val,encoding);var len=bytes.length;if(len===0){throw new TypeError('The value "'+val+'" is invalid for argument "value"');}for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function base64clean(str){// Node takes equal signs as end of the Base64 encoding
str=str.split('=')[0];// Node strips out invalid characters like \n and \t from the string, base64-js does not
str=str.trim().replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''
if(str.length<2)return '';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
while(str.length%4!==0){str=str+'=';}return str;}function toHex(n){if(n<16)return '0'+n.toString(16);return n.toString(16);}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component
if(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead
if(!leadSurrogate){// no lead yet
if(codePoint>0xDBFF){// unexpected trail
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead
leadSurrogate=codePoint;continue;}// 2 leads in a row
if(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair
codePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead
if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8
if(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else {throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..
byteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return base64.toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj,type){return obj instanceof type||obj!=null&&obj.constructor!=null&&obj.constructor.name!=null&&obj.constructor.name===type.name;}function numberIsNaN(obj){// For IE11 support
return obj!==obj;// eslint-disable-line no-self-compare
}}).call(this);}).call(this,require("buffer").Buffer);},{"base64-js":13,"buffer":17,"ieee754":23}],18:[function(require,module,exports){(function(process){(function(){/* eslint-env browser */ /**
	 * This is the web browser implementation of `debug()`.
	 */exports.formatArgs=formatArgs;exports.save=save;exports.load=load;exports.useColors=useColors;exports.storage=localstorage();exports.destroy=function(){var warned=false;return function(){if(!warned){warned=true;console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');}};}();/**
	 * Colors.
	 */exports.colors=['#0000CC','#0000FF','#0033CC','#0033FF','#0066CC','#0066FF','#0099CC','#0099FF','#00CC00','#00CC33','#00CC66','#00CC99','#00CCCC','#00CCFF','#3300CC','#3300FF','#3333CC','#3333FF','#3366CC','#3366FF','#3399CC','#3399FF','#33CC00','#33CC33','#33CC66','#33CC99','#33CCCC','#33CCFF','#6600CC','#6600FF','#6633CC','#6633FF','#66CC00','#66CC33','#9900CC','#9900FF','#9933CC','#9933FF','#99CC00','#99CC33','#CC0000','#CC0033','#CC0066','#CC0099','#CC00CC','#CC00FF','#CC3300','#CC3333','#CC3366','#CC3399','#CC33CC','#CC33FF','#CC6600','#CC6633','#CC9900','#CC9933','#CCCC00','#CCCC33','#FF0000','#FF0033','#FF0066','#FF0099','#FF00CC','#FF00FF','#FF3300','#FF3333','#FF3366','#FF3399','#FF33CC','#FF33FF','#FF6600','#FF6633','#FF9900','#FF9933','#FFCC00','#FFCC33'];/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */ // eslint-disable-next-line complexity
function useColors(){// NB: In an Electron preload script, document will be defined but not fully
// initialized. Since we know we're in Chrome, we'll just detect this case
// explicitly
if(typeof window!=='undefined'&&window.process&&(window.process.type==='renderer'||window.process.__nwjs)){return true;}// Internet Explorer and Edge do not support colors.
if(typeof navigator!=='undefined'&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)){return false;}// Is webkit? http://stackoverflow.com/a/16459606/376773
// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
return typeof document!=='undefined'&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||// Is firebug? http://stackoverflow.com/a/398120/376773
typeof window!=='undefined'&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||// Is firefox >= v31?
// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
typeof navigator!=='undefined'&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||// Double check webkit in userAgent just in case we are in a worker
typeof navigator!=='undefined'&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);}/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */function formatArgs(args){args[0]=(this.useColors?'%c':'')+this.namespace+(this.useColors?' %c':' ')+args[0]+(this.useColors?'%c ':' ')+'+'+module.exports.humanize(this.diff);if(!this.useColors){return;}var c='color: '+this.color;args.splice(1,0,c,'color: inherit');// The final "%c" is somewhat tricky, because there could be other
// arguments passed either before or after the %c, so we need to
// figure out the correct index to insert the CSS into
var index=0;var lastC=0;args[0].replace(/%[a-zA-Z%]/g,function(match){if(match==='%%'){return;}index++;if(match==='%c'){// We only are interested in the *last* %c
// (the user may have provided their own)
lastC=index;}});args.splice(lastC,0,c);}/**
	 * Invokes `console.debug()` when available.
	 * No-op when `console.debug` is not a "function".
	 * If `console.debug` is not available, falls back
	 * to `console.log`.
	 *
	 * @api public
	 */exports.log=console.debug||console.log||function(){};/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */function save(namespaces){try{if(namespaces){exports.storage.setItem('debug',namespaces);}else {exports.storage.removeItem('debug');}}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}}/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */function load(){var r;try{r=exports.storage.getItem('debug');}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
if(!r&&typeof process!=='undefined'&&'env'in process){r=process.env.DEBUG;}return r;}/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */function localstorage(){try{// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
// The Browser also has localStorage in the global context.
return localStorage;}catch(error){// Swallow
// XXX (@Qix-) should we be logging these?
}}module.exports=require('./common')(exports);var formatters=module.exports.formatters;/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */formatters.j=function(v){try{return JSON.stringify(v);}catch(error){return '[UnexpectedJSONParseError]: '+error.message;}};}).call(this);}).call(this,require('_process'));},{"./common":19,"_process":50}],19:[function(require,module,exports){/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */function setup(env){createDebug.debug=createDebug;createDebug["default"]=createDebug;createDebug.coerce=coerce;createDebug.disable=disable;createDebug.enable=enable;createDebug.enabled=enabled;createDebug.humanize=require('ms');createDebug.destroy=destroy;Object.keys(env).forEach(function(key){createDebug[key]=env[key];});/**
		* The currently active debug mode names, and names to skip.
		*/createDebug.names=[];createDebug.skips=[];/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/createDebug.formatters={};/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/function selectColor(namespace){var hash=0;for(var i=0;i<namespace.length;i++){hash=(hash<<5)-hash+namespace.charCodeAt(i);hash|=0;// Convert to 32bit integer
}return createDebug.colors[Math.abs(hash)%createDebug.colors.length];}createDebug.selectColor=selectColor;/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/function createDebug(namespace){var prevTime;var enableOverride=null;var namespacesCache;var enabledCache;function debug(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}// Disabled?
if(!debug.enabled){return;}var self=debug;// Set `diff` timestamp
var curr=Number(new Date());var ms=curr-(prevTime||curr);self.diff=ms;self.prev=prevTime;self.curr=curr;prevTime=curr;args[0]=createDebug.coerce(args[0]);if(typeof args[0]!=='string'){// Anything else let's inspect with %O
args.unshift('%O');}// Apply any `formatters` transformations
var index=0;args[0]=args[0].replace(/%([a-zA-Z%])/g,function(match,format){// If we encounter an escaped % then don't increase the array index
if(match==='%%'){return '%';}index++;var formatter=createDebug.formatters[format];if(typeof formatter==='function'){var val=args[index];match=formatter.call(self,val);// Now we need to remove `args[index]` since it's inlined in the `format`
args.splice(index,1);index--;}return match;});// Apply env-specific formatting (colors, etc.)
createDebug.formatArgs.call(self,args);var logFn=self.log||createDebug.log;logFn.apply(self,args);}debug.namespace=namespace;debug.useColors=createDebug.useColors();debug.color=createDebug.selectColor(namespace);debug.extend=extend;debug.destroy=createDebug.destroy;// XXX Temporary. Will be removed in the next major release.
Object.defineProperty(debug,'enabled',{enumerable:true,configurable:false,get:function get(){if(enableOverride!==null){return enableOverride;}if(namespacesCache!==createDebug.namespaces){namespacesCache=createDebug.namespaces;enabledCache=createDebug.enabled(namespace);}return enabledCache;},set:function set(v){enableOverride=v;}});// Env-specific initialization logic for debug instances
if(typeof createDebug.init==='function'){createDebug.init(debug);}return debug;}function extend(namespace,delimiter){var newDebug=createDebug(this.namespace+(typeof delimiter==='undefined'?':':delimiter)+namespace);newDebug.log=this.log;return newDebug;}/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/function enable(namespaces){createDebug.save(namespaces);createDebug.namespaces=namespaces;createDebug.names=[];createDebug.skips=[];var i;var split=(typeof namespaces==='string'?namespaces:'').split(/[\s,]+/);var len=split.length;for(i=0;i<len;i++){if(!split[i]){// ignore empty strings
continue;}namespaces=split[i].replace(/\*/g,'.*?');if(namespaces[0]==='-'){createDebug.skips.push(new RegExp('^'+namespaces.substr(1)+'$'));}else {createDebug.names.push(new RegExp('^'+namespaces+'$'));}}}/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/function disable(){var namespaces=[].concat(_toConsumableArray(createDebug.names.map(toNamespace)),_toConsumableArray(createDebug.skips.map(toNamespace).map(function(namespace){return '-'+namespace;}))).join(',');createDebug.enable('');return namespaces;}/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/function enabled(name){if(name[name.length-1]==='*'){return true;}var i;var len;for(i=0,len=createDebug.skips.length;i<len;i++){if(createDebug.skips[i].test(name)){return false;}}for(i=0,len=createDebug.names.length;i<len;i++){if(createDebug.names[i].test(name)){return true;}}return false;}/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/function toNamespace(regexp){return regexp.toString().substring(2,regexp.toString().length-2).replace(/\.\*\?$/,'*');}/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/function coerce(val){if(val instanceof Error){return val.stack||val.message;}return val;}/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/function destroy(){console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');}createDebug.enable(createDebug.load());return createDebug;}module.exports=setup;},{"ms":45}],20:[function(require,module,exports){(function(process,Buffer){(function(){var stream=require('readable-stream');var eos=require('end-of-stream');var inherits=require('inherits');var shift=require('stream-shift');var SIGNAL_FLUSH=Buffer.from&&Buffer.from!==Uint8Array.from?Buffer.from([0]):new Buffer([0]);var onuncork=function onuncork(self,fn){if(self._corked)self.once('uncork',fn);else fn();};var autoDestroy=function autoDestroy(self,err){if(self._autoDestroy)self.destroy(err);};var destroyer=function destroyer(self,end){return function(err){if(err)autoDestroy(self,err.message==='premature close'?null:err);else if(end&&!self._ended)self.end();};};var end=function end(ws,fn){if(!ws)return fn();if(ws._writableState&&ws._writableState.finished)return fn();if(ws._writableState)return ws.end(fn);ws.end();fn();};var noop=function noop(){};var toStreams2=function toStreams2(rs){return new stream.Readable({objectMode:true,highWaterMark:16}).wrap(rs);};var Duplexify=function Duplexify(writable,readable,opts){if(!(this instanceof Duplexify))return new Duplexify(writable,readable,opts);stream.Duplex.call(this,opts);this._writable=null;this._readable=null;this._readable2=null;this._autoDestroy=!opts||opts.autoDestroy!==false;this._forwardDestroy=!opts||opts.destroy!==false;this._forwardEnd=!opts||opts.end!==false;this._corked=1;// start corked
this._ondrain=null;this._drained=false;this._forwarding=false;this._unwrite=null;this._unread=null;this._ended=false;this.destroyed=false;if(writable)this.setWritable(writable);if(readable)this.setReadable(readable);};inherits(Duplexify,stream.Duplex);Duplexify.obj=function(writable,readable,opts){if(!opts)opts={};opts.objectMode=true;opts.highWaterMark=16;return new Duplexify(writable,readable,opts);};Duplexify.prototype.cork=function(){if(++this._corked===1)this.emit('cork');};Duplexify.prototype.uncork=function(){if(this._corked&&--this._corked===0)this.emit('uncork');};Duplexify.prototype.setWritable=function(writable){if(this._unwrite)this._unwrite();if(this.destroyed){if(writable&&writable.destroy)writable.destroy();return;}if(writable===null||writable===false){this.end();return;}var self=this;var unend=eos(writable,{writable:true,readable:false},destroyer(this,this._forwardEnd));var ondrain=function ondrain(){var ondrain=self._ondrain;self._ondrain=null;if(ondrain)ondrain();};var clear=function clear(){self._writable.removeListener('drain',ondrain);unend();};if(this._unwrite)process.nextTick(ondrain);// force a drain on stream reset to avoid livelocks
this._writable=writable;this._writable.on('drain',ondrain);this._unwrite=clear;this.uncork();// always uncork setWritable
};Duplexify.prototype.setReadable=function(readable){if(this._unread)this._unread();if(this.destroyed){if(readable&&readable.destroy)readable.destroy();return;}if(readable===null||readable===false){this.push(null);this.resume();return;}var self=this;var unend=eos(readable,{writable:false,readable:true},destroyer(this));var onreadable=function onreadable(){self._forward();};var onend=function onend(){self.push(null);};var clear=function clear(){self._readable2.removeListener('readable',onreadable);self._readable2.removeListener('end',onend);unend();};this._drained=true;this._readable=readable;this._readable2=readable._readableState?readable:toStreams2(readable);this._readable2.on('readable',onreadable);this._readable2.on('end',onend);this._unread=clear;this._forward();};Duplexify.prototype._read=function(){this._drained=true;this._forward();};Duplexify.prototype._forward=function(){if(this._forwarding||!this._readable2||!this._drained)return;this._forwarding=true;var data;while(this._drained&&(data=shift(this._readable2))!==null){if(this.destroyed)continue;this._drained=this.push(data);}this._forwarding=false;};Duplexify.prototype.destroy=function(err,cb){if(!cb)cb=noop;if(this.destroyed)return cb(null);this.destroyed=true;var self=this;process.nextTick(function(){self._destroy(err);cb(null);});};Duplexify.prototype._destroy=function(err){if(err){var ondrain=this._ondrain;this._ondrain=null;if(ondrain)ondrain(err);else this.emit('error',err);}if(this._forwardDestroy){if(this._readable&&this._readable.destroy)this._readable.destroy();if(this._writable&&this._writable.destroy)this._writable.destroy();}this.emit('close');};Duplexify.prototype._write=function(data,enc,cb){if(this.destroyed)return;if(this._corked)return onuncork(this,this._write.bind(this,data,enc,cb));if(data===SIGNAL_FLUSH)return this._finish(cb);if(!this._writable)return cb();if(this._writable.write(data)===false)this._ondrain=cb;else if(!this.destroyed)cb();};Duplexify.prototype._finish=function(cb){var self=this;this.emit('preend');onuncork(this,function(){end(self._forwardEnd&&self._writable,function(){// haxx to not emit prefinish twice
if(self._writableState.prefinished===false)self._writableState.prefinished=true;self.emit('prefinish');onuncork(self,cb);});});};Duplexify.prototype.end=function(data,enc,cb){if(typeof data==='function')return this.end(null,null,data);if(typeof enc==='function')return this.end(data,null,enc);this._ended=true;if(data)this.write(data);if(!this._writableState.ending&&!this._writableState.destroyed)this.write(SIGNAL_FLUSH);return stream.Writable.prototype.end.call(this,cb);};module.exports=Duplexify;}).call(this);}).call(this,require('_process'),require("buffer").Buffer);},{"_process":50,"buffer":17,"end-of-stream":21,"inherits":24,"readable-stream":69,"stream-shift":74}],21:[function(require,module,exports){(function(process){(function(){var once=require('once');var noop=function noop(){};var isRequest=function isRequest(stream){return stream.setHeader&&typeof stream.abort==='function';};var isChildProcess=function isChildProcess(stream){return stream.stdio&&Array.isArray(stream.stdio)&&stream.stdio.length===3;};var eos=function eos(stream,opts,callback){if(typeof opts==='function')return eos(stream,null,opts);if(!opts)opts={};callback=once(callback||noop);var ws=stream._writableState;var rs=stream._readableState;var readable=opts.readable||opts.readable!==false&&stream.readable;var writable=opts.writable||opts.writable!==false&&stream.writable;var cancelled=false;var onlegacyfinish=function onlegacyfinish(){if(!stream.writable)onfinish();};var onfinish=function onfinish(){writable=false;if(!readable)callback.call(stream);};var onend=function onend(){readable=false;if(!writable)callback.call(stream);};var onexit=function onexit(exitCode){callback.call(stream,exitCode?new Error('exited with error code: '+exitCode):null);};var onerror=function onerror(err){callback.call(stream,err);};var onclose=function onclose(){process.nextTick(onclosenexttick);};var onclosenexttick=function onclosenexttick(){if(cancelled)return;if(readable&&!(rs&&rs.ended&&!rs.destroyed))return callback.call(stream,new Error('premature close'));if(writable&&!(ws&&ws.ended&&!ws.destroyed))return callback.call(stream,new Error('premature close'));};var onrequest=function onrequest(){stream.req.on('finish',onfinish);};if(isRequest(stream)){stream.on('complete',onfinish);stream.on('abort',onclose);if(stream.req)onrequest();else stream.on('request',onrequest);}else if(writable&&!ws){// legacy streams
stream.on('end',onlegacyfinish);stream.on('close',onlegacyfinish);}if(isChildProcess(stream))stream.on('exit',onexit);stream.on('end',onend);stream.on('finish',onfinish);if(opts.error!==false)stream.on('error',onerror);stream.on('close',onclose);return function(){cancelled=true;stream.removeListener('complete',onfinish);stream.removeListener('abort',onclose);stream.removeListener('request',onrequest);if(stream.req)stream.req.removeListener('finish',onfinish);stream.removeListener('end',onlegacyfinish);stream.removeListener('close',onlegacyfinish);stream.removeListener('finish',onfinish);stream.removeListener('exit',onexit);stream.removeListener('end',onend);stream.removeListener('error',onerror);stream.removeListener('close',onclose);};};module.exports=eos;}).call(this);}).call(this,require('_process'));},{"_process":50,"once":48}],22:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var objectCreate=Object.create||objectCreatePolyfill;var objectKeys=Object.keys||objectKeysPolyfill;var bind=Function.prototype.bind||functionBindPolyfill;function EventEmitter(){if(!this._events||!Object.prototype.hasOwnProperty.call(this,'_events')){this._events=objectCreate(null);this._eventsCount=0;}this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners=10;var hasDefineProperty;try{var o={};if(Object.defineProperty)Object.defineProperty(o,'x',{value:0});hasDefineProperty=o.x===0;}catch(err){hasDefineProperty=false;}if(hasDefineProperty){Object.defineProperty(EventEmitter,'defaultMaxListeners',{enumerable:true,get:function get(){return defaultMaxListeners;},set:function set(arg){// check whether the input is a positive number (whose value is zero or
// greater and not a NaN).
if(typeof arg!=='number'||arg<0||arg!==arg)throw new TypeError('"defaultMaxListeners" must be a positive number');defaultMaxListeners=arg;}});}else {EventEmitter.defaultMaxListeners=defaultMaxListeners;}// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function setMaxListeners(n){if(typeof n!=='number'||n<0||isNaN(n))throw new TypeError('"n" argument must be a positive number');this._maxListeners=n;return this;};function $getMaxListeners(that){if(that._maxListeners===undefined)return EventEmitter.defaultMaxListeners;return that._maxListeners;}EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return $getMaxListeners(this);};// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler,isFn,self){if(isFn)handler.call(self);else {var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self);}}}function emitOne(handler,isFn,self,arg1){if(isFn)handler.call(self,arg1);else {var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1);}}}function emitTwo(handler,isFn,self,arg1,arg2){if(isFn)handler.call(self,arg1,arg2);else {var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2);}}}function emitThree(handler,isFn,self,arg1,arg2,arg3){if(isFn)handler.call(self,arg1,arg2,arg3);else {var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].call(self,arg1,arg2,arg3);}}}function emitMany(handler,isFn,self,args){if(isFn)handler.apply(self,args);else {var len=handler.length;var listeners=arrayClone(handler,len);for(var i=0;i<len;++i){listeners[i].apply(self,args);}}}EventEmitter.prototype.emit=function emit(type){var er,handler,len,args,i,events;var doError=type==='error';events=this._events;if(events)doError=doError&&events.error==null;else if(!doError)return false;// If there is no 'error' event listener then throw.
if(doError){if(arguments.length>1)er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else {// At least give some kind of context to the user
var err=new Error('Unhandled "error" event. ('+er+')');err.context=er;throw err;}}handler=events[type];if(!handler)return false;var isFn=typeof handler==='function';len=arguments.length;switch(len){// fast cases
case 1:emitNone(handler,isFn,this);break;case 2:emitOne(handler,isFn,this,arguments[1]);break;case 3:emitTwo(handler,isFn,this,arguments[1],arguments[2]);break;case 4:emitThree(handler,isFn,this,arguments[1],arguments[2],arguments[3]);break;// slower
default:args=new Array(len-1);for(i=1;i<len;i++){args[i-1]=arguments[i];}emitMany(handler,isFn,this,args);}return true;};function _addListener(target,type,listener,prepend){var m;var events;var existing;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=target._events;if(!events){events=target._events=objectCreate(null);target._eventsCount=0;}else {// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(events.newListener){target.emit('newListener',type,listener.listener?listener.listener:listener);// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
events=target._events;}existing=events[type];}if(!existing){// Optimize the case of one listener. Don't need the extra array object.
existing=events[type]=listener;++target._eventsCount;}else {if(typeof existing==='function'){// Adding the second element, need to change to array.
existing=events[type]=prepend?[listener,existing]:[existing,listener];}else {// If we've already got an array, just append.
if(prepend){existing.unshift(listener);}else {existing.push(listener);}}// Check for listener leak
if(!existing.warned){m=$getMaxListeners(target);if(m&&m>0&&existing.length>m){existing.warned=true;var w=new Error('Possible EventEmitter memory leak detected. '+existing.length+' "'+String(type)+'" listeners '+'added. Use emitter.setMaxListeners() to '+'increase limit.');w.name='MaxListenersExceededWarning';w.emitter=target;w.type=type;w.count=existing.length;if((typeof console==="undefined"?"undefined":_typeof(console))==='object'&&console.warn){console.warn('%s: %s',w.name,w.message);}}}}return target;}EventEmitter.prototype.addListener=function addListener(type,listener){return _addListener(this,type,listener,false);};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.prependListener=function prependListener(type,listener){return _addListener(this,type,listener,true);};function onceWrapper(){if(!this.fired){this.target.removeListener(this.type,this.wrapFn);this.fired=true;switch(arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:var args=new Array(arguments.length);for(var i=0;i<args.length;++i){args[i]=arguments[i];}this.listener.apply(this.target,args);}}}function _onceWrap(target,type,listener){var state={fired:false,wrapFn:undefined,target:target,type:type,listener:listener};var wrapped=bind.call(onceWrapper,state);wrapped.listener=listener;state.wrapFn=wrapped;return wrapped;}EventEmitter.prototype.once=function once(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.on(type,_onceWrap(this,type,listener));return this;};EventEmitter.prototype.prependOnceListener=function prependOnceListener(type,listener){if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');this.prependListener(type,_onceWrap(this,type,listener));return this;};// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener=function removeListener(type,listener){var list,events,position,i,originalListener;if(typeof listener!=='function')throw new TypeError('"listener" argument must be a function');events=this._events;if(!events)return this;list=events[type];if(!list)return this;if(list===listener||list.listener===listener){if(--this._eventsCount===0)this._events=objectCreate(null);else {delete events[type];if(events.removeListener)this.emit('removeListener',type,list.listener||listener);}}else if(typeof list!=='function'){position=-1;for(i=list.length-1;i>=0;i--){if(list[i]===listener||list[i].listener===listener){originalListener=list[i].listener;position=i;break;}}if(position<0)return this;if(position===0)list.shift();else spliceOne(list,position);if(list.length===1)events[type]=list[0];if(events.removeListener)this.emit('removeListener',type,originalListener||listener);}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(type){var listeners,events,i;events=this._events;if(!events)return this;// not listening for removeListener, no need to emit
if(!events.removeListener){if(arguments.length===0){this._events=objectCreate(null);this._eventsCount=0;}else if(events[type]){if(--this._eventsCount===0)this._events=objectCreate(null);else delete events[type];}return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){var keys=objectKeys(events);var key;for(i=0;i<keys.length;++i){key=keys[i];if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events=objectCreate(null);this._eventsCount=0;return this;}listeners=events[type];if(typeof listeners==='function'){this.removeListener(type,listeners);}else if(listeners){// LIFO order
for(i=listeners.length-1;i>=0;i--){this.removeListener(type,listeners[i]);}}return this;};function _listeners(target,type,unwrap){var events=target._events;if(!events)return [];var evlistener=events[type];if(!evlistener)return [];if(typeof evlistener==='function')return unwrap?[evlistener.listener||evlistener]:[evlistener];return unwrap?unwrapListeners(evlistener):arrayClone(evlistener,evlistener.length);}EventEmitter.prototype.listeners=function listeners(type){return _listeners(this,type,true);};EventEmitter.prototype.rawListeners=function rawListeners(type){return _listeners(this,type,false);};EventEmitter.listenerCount=function(emitter,type){if(typeof emitter.listenerCount==='function'){return emitter.listenerCount(type);}else {return listenerCount.call(emitter,type);}};EventEmitter.prototype.listenerCount=listenerCount;function listenerCount(type){var events=this._events;if(events){var evlistener=events[type];if(typeof evlistener==='function'){return 1;}else if(evlistener){return evlistener.length;}}return 0;}EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?Reflect.ownKeys(this._events):[];};// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list,index){for(var i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k];}list.pop();}function arrayClone(arr,n){var copy=new Array(n);for(var i=0;i<n;++i){copy[i]=arr[i];}return copy;}function unwrapListeners(arr){var ret=new Array(arr.length);for(var i=0;i<ret.length;++i){ret[i]=arr[i].listener||arr[i];}return ret;}function objectCreatePolyfill(proto){var F=function F(){};F.prototype=proto;return new F();}function objectKeysPolyfill(obj){for(var k in obj){if(Object.prototype.hasOwnProperty.call(obj,k));}return k;}function functionBindPolyfill(context){var fn=this;return function(){return fn.apply(context,arguments);};}},{}],23:[function(require,module,exports){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */exports.read=function(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else {m=m+Math.pow(2,mLen);e=e-eBias;}return (s?-1:1)*m*Math.pow(2,e-mLen);};exports.write=function(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else {e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else {value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else {m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;};},{}],24:[function(require,module,exports){if(typeof Object.create==='function'){// implementation from standard node.js 'util' module
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:false,writable:true,configurable:true}});}};}else {// old school shim for old browsers
module.exports=function inherits(ctor,superCtor){if(superCtor){ctor.super_=superCtor;var TempCtor=function TempCtor(){};TempCtor.prototype=superCtor.prototype;ctor.prototype=new TempCtor();ctor.prototype.constructor=ctor;}};}},{}],25:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});var TreeNode=/** @class */function(){function TreeNode(key,value){this.color=true;this.key=undefined;this.value=undefined;this.parent=undefined;this.brother=undefined;this.leftChild=undefined;this.rightChild=undefined;this.key=key;this.value=value;}TreeNode.prototype.rotateLeft=function(){var PP=this.parent;var PB=this.brother;var F=this.leftChild;var V=this.rightChild;if(!V)throw new Error("unknown error");var R=V.leftChild;var X=V.rightChild;if(PP){if(PP.leftChild===this)PP.leftChild=V;else if(PP.rightChild===this)PP.rightChild=V;}V.parent=PP;V.brother=PB;V.leftChild=this;V.rightChild=X;if(PB)PB.brother=V;this.parent=V;this.brother=X;this.leftChild=F;this.rightChild=R;if(X){X.parent=V;X.brother=this;}if(F){F.parent=this;F.brother=R;}if(R){R.parent=this;R.brother=F;}return V;};TreeNode.prototype.rotateRight=function(){var PP=this.parent;var PB=this.brother;var F=this.leftChild;if(!F)throw new Error("unknown error");var V=this.rightChild;var D=F.leftChild;var K=F.rightChild;if(PP){if(PP.leftChild===this)PP.leftChild=F;else if(PP.rightChild===this)PP.rightChild=F;}F.parent=PP;F.brother=PB;F.leftChild=D;F.rightChild=this;if(PB)PB.brother=F;if(D){D.parent=F;D.brother=this;}this.parent=F;this.brother=D;this.leftChild=K;this.rightChild=V;if(K){K.parent=this;K.brother=V;}if(V){V.parent=this;V.brother=K;}return F;};TreeNode.prototype.remove=function(){if(this.leftChild||this.rightChild)throw new Error("can only remove leaf node");if(this.parent){if(this===this.parent.leftChild)this.parent.leftChild=undefined;else if(this===this.parent.rightChild)this.parent.rightChild=undefined;}if(this.brother)this.brother.brother=undefined;this.key=undefined;this.value=undefined;this.parent=undefined;this.brother=undefined;};TreeNode.TreeNodeColorType={red:true,black:false};return TreeNode;}();Object.freeze(TreeNode);exports["default"]=TreeNode;},{}],26:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});Deque.sigma=3;// growth factor
Deque.bucketSize=5000;function Deque(container){var _this=this;if(container===void 0){container=[];}var map=[];var first=0;var curFirst=0;var last=0;var curLast=0;var bucketNum=0;var len=0;this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){first=last=curFirst=curLast=bucketNum=len=0;reAllocate.call(this,Deque.bucketSize);len=0;};this.front=function(){return map[first][curFirst];};this.back=function(){return map[last][curLast];};this.forEach=function(callback){if(this.empty())return;var index=0;if(first===last){for(var i=curFirst;i<=curLast;++i){callback(map[first][i],index++);}return;}for(var i=curFirst;i<Deque.bucketSize;++i){callback(map[first][i],index++);}for(var i=first+1;i<last;++i){for(var j=0;j<Deque.bucketSize;++j){callback(map[i][j],index++);}}for(var i=0;i<=curLast;++i){callback(map[last][i],index++);}};var getElementIndex=function getElementIndex(pos){var curFirstIndex=first*Deque.bucketSize+curFirst;var curNodeIndex=curFirstIndex+pos;var curLastIndex=last*Deque.bucketSize+curLast;if(curNodeIndex<curFirstIndex||curNodeIndex>curLastIndex)throw new Error("pos should more than 0 and less than queue's size");var curNodeBucketIndex=Math.floor(curNodeIndex/Deque.bucketSize);var curNodePointerIndex=curNodeIndex%Deque.bucketSize;return {curNodeBucketIndex:curNodeBucketIndex,curNodePointerIndex:curNodePointerIndex};};/**
	     * @param pos index from 0 to size - 1
	     */this.getElementByPos=function(pos){var _a=getElementIndex(pos),curNodeBucketIndex=_a.curNodeBucketIndex,curNodePointerIndex=_a.curNodePointerIndex;return map[curNodeBucketIndex][curNodePointerIndex];};this.eraseElementByPos=function(pos){var _this=this;if(pos<0||pos>len)throw new Error("pos should more than 0 and less than queue's size");if(pos===0)this.popFront();else if(pos===this.size())this.popBack();else {var arr=[];for(var i=pos+1;i<len;++i){arr.push(this.getElementByPos(i));}this.cut(pos);this.popBack();arr.forEach(function(element){return _this.pushBack(element);});}};this.eraseElementByValue=function(value){if(this.empty())return;var arr=[];this.forEach(function(element){if(element!==value){arr.push(element);}});var _len=arr.length;for(var i=0;i<_len;++i){this.setElementByPos(i,arr[i]);}this.cut(_len-1);};var reAllocate=function reAllocate(originalSize){var newMap=[];var needSize=originalSize*Deque.sigma;var newBucketNum=Math.max(Math.ceil(needSize/Deque.bucketSize),2);for(var i=0;i<newBucketNum;++i){newMap.push(new Array(Deque.bucketSize));}var needBucketNum=Math.ceil(originalSize/Deque.bucketSize);var newFirst=Math.floor(newBucketNum/2)-Math.floor(needBucketNum/2);var newLast=newFirst,newCurLast=0;if(this.size()){for(var i=0;i<needBucketNum;++i){for(var j=0;j<Deque.bucketSize;++j){newMap[newFirst+i][j]=this.front();this.popFront();if(this.empty()){newLast=newFirst+i;newCurLast=j;break;}}if(this.empty())break;}}map=newMap;first=newFirst;curFirst=0;last=newLast;curLast=newCurLast;bucketNum=newBucketNum;len=originalSize;};this.pushBack=function(element){if(!this.empty()){if(last===bucketNum-1&&curLast===Deque.bucketSize-1){reAllocate.call(this,this.size());}if(curLast<Deque.bucketSize-1){++curLast;}else if(last<bucketNum-1){++last;curLast=0;}}++len;map[last][curLast]=element;};this.popBack=function(){if(this.empty())return;if(this.size()!==1){if(curLast>0){--curLast;}else if(first<last){--last;curLast=Deque.bucketSize-1;}}if(len>0)--len;};this.setElementByPos=function(pos,element){var _a=getElementIndex(pos),curNodeBucketIndex=_a.curNodeBucketIndex,curNodePointerIndex=_a.curNodePointerIndex;map[curNodeBucketIndex][curNodePointerIndex]=element;};/**
	     * @param {number} pos insert element before pos, should in [0, queue.size]
	     * @param {any} element the element you want to insert
	     * @param {number} [num = 1] the nums you want to insert
	     */this.insert=function(pos,element,num){var _this=this;if(num===void 0){num=1;}if(pos===0){while(num--){this.pushFront(element);}}else if(pos===this.size()){while(num--){this.pushBack(element);}}else {var arr=[];for(var i=pos;i<len;++i){arr.push(this.getElementByPos(i));}this.cut(pos-1);for(var i=0;i<num;++i){this.pushBack(element);}arr.forEach(function(element){return _this.pushBack(element);});}};this.find=function(element){if(first===last){for(var i=curFirst;i<=curLast;++i){if(map[first][i]===element)return true;}return false;}for(var i=curFirst;i<Deque.bucketSize;++i){if(map[first][i]===element)return true;}for(var i=first+1;i<last;++i){for(var j=0;j<Deque.bucketSize;++j){if(map[i][j]===element)return true;}}for(var i=0;i<=curLast;++i){if(map[last][i]===element)return true;}return false;};this.reverse=function(){var l=0,r=len-1;while(l<r){var tmp=this.getElementByPos(l);this.setElementByPos(l,this.getElementByPos(r));this.setElementByPos(r,tmp);++l;--r;}};this.unique=function(){if(this.empty())return;var arr=[];var pre=this.front();this.forEach(function(element,index){if(index===0||element!==pre){arr.push(element);pre=element;}});for(var i=0;i<len;++i){this.setElementByPos(i,arr[i]);}this.cut(arr.length-1);};this.sort=function(cmp){var arr=[];this.forEach(function(element){arr.push(element);});arr.sort(cmp);for(var i=0;i<len;++i){this.setElementByPos(i,arr[i]);}};this.pushFront=function(element){if(!this.empty()){if(first===0&&curFirst===0){reAllocate.call(this,this.size());}if(curFirst>0){--curFirst;}else if(first>0){--first;curFirst=Deque.bucketSize-1;}}++len;map[first][curFirst]=element;};this.popFront=function(){if(this.empty())return;if(this.size()!==1){if(curFirst<Deque.bucketSize-1){++curFirst;}else if(first<last){++first;curFirst=0;}}if(len>0)--len;};/**
	     * reduces memory usage by freeing unused memory
	     */this.shrinkToFit=function(){var _this=this;var arr=[];this.forEach(function(element){arr.push(element);});var _len=arr.length;map=[];var bucketNum=Math.ceil(_len/Deque.bucketSize);for(var i=0;i<bucketNum;++i){map.push(new Array(Deque.bucketSize));}this.clear();arr.forEach(function(element){return _this.pushBack(element);});};/**
	     * @param pos cut elements after pos
	     */this.cut=function(pos){if(pos<0){this.clear();return;}var _a=getElementIndex(pos),curNodeBucketIndex=_a.curNodeBucketIndex,curNodePointerIndex=_a.curNodePointerIndex;last=curNodeBucketIndex;curLast=curNodePointerIndex;len=pos+1;};this[Symbol.iterator]=function(){return function(){var i,i,i,j,i;return __generator(this,function(_a){switch(_a.label){case 0:if(len===0)return [2/*return*/];if(!(first===last))return [3/*break*/,5];i=curFirst;_a.label=1;case 1:if(!(i<=curLast))return [3/*break*/,4];return [4/*yield*/,map[first][i]];case 2:_a.sent();_a.label=3;case 3:++i;return [3/*break*/,1];case 4:return [2/*return*/];case 5:i=curFirst;_a.label=6;case 6:if(!(i<Deque.bucketSize))return [3/*break*/,9];return [4/*yield*/,map[first][i]];case 7:_a.sent();_a.label=8;case 8:++i;return [3/*break*/,6];case 9:i=first+1;_a.label=10;case 10:if(!(i<last))return [3/*break*/,15];j=0;_a.label=11;case 11:if(!(j<Deque.bucketSize))return [3/*break*/,14];return [4/*yield*/,map[i][j]];case 12:_a.sent();_a.label=13;case 13:++j;return [3/*break*/,11];case 14:++i;return [3/*break*/,10];case 15:i=0;_a.label=16;case 16:if(!(i<=curLast))return [3/*break*/,19];return [4/*yield*/,map[last][i]];case 17:_a.sent();_a.label=18;case 18:++i;return [3/*break*/,16];case 19:return [2/*return*/];}});}();};(function(){var _len=Deque.bucketSize;if(container.size){_len=container.size();}else if(container.length){_len=container.length;}var needSize=_len*Deque.sigma;bucketNum=Math.ceil(needSize/Deque.bucketSize);bucketNum=Math.max(bucketNum,3);for(var i=0;i<bucketNum;++i){map.push(new Array(Deque.bucketSize));}var needBucketNum=Math.ceil(_len/Deque.bucketSize);first=Math.floor(bucketNum/2)-Math.floor(needBucketNum/2);last=first;container.forEach(function(element){return _this.pushBack(element);});})();Object.freeze(this);}Object.freeze(Deque);exports["default"]=Deque;},{}],27:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};var __values=this&&this.__values||function(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return {next:function next(){if(o&&i>=o.length)o=void 0;return {value:o&&o[i++],done:!o};}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",{value:true});var LinkList_1=require("../LinkList/LinkList");var Map_1=require("../Map/Map");HashMap.initSize=1<<4;HashMap.maxSize=1<<30;HashMap.sigma=0.75;// default load factor
HashMap.treeifyThreshold=8;HashMap.untreeifyThreshold=6;HashMap.minTreeifySize=64;/**
	 * Note that resize is a time-consuming operation, please try to determine the number of buckets before use.
	 * @param container Initialize the container
	 * @param initBucketNum Initialize the bucket num, must be 2 to the power of n
	 * @param hashFunc Function to map elements to numbers
	 * @constructor
	 */function HashMap(container,initBucketNum,hashFunc){var _this=this;if(container===void 0){container=[];}if(initBucketNum===void 0){initBucketNum=HashMap.initSize;}hashFunc=hashFunc||function(x){var e_1,_a;var hashCode=0;var str='';if(typeof x==="number"){hashCode=Math.floor(x);hashCode=(hashCode<<5)-hashCode;hashCode=hashCode&hashCode;}else {if(typeof x!=="string"){str=JSON.stringify(x);}else str=x;try{for(var str_1=__values(str),str_1_1=str_1.next();!str_1_1.done;str_1_1=str_1.next()){var ch=str_1_1.value;var character=ch.charCodeAt(0);hashCode=(hashCode<<5)-hashCode+character;hashCode=hashCode&hashCode;}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(str_1_1&&!str_1_1.done&&(_a=str_1["return"]))_a.call(str_1);}finally{if(e_1)throw e_1.error;}}}hashCode^=hashCode>>>16;return hashCode;};if((initBucketNum&initBucketNum-1)!==0){throw new Error("initBucketNum must be 2 to the power of n");}var len=0;var hashTable=[];var bucketNum=Math.max(HashMap.initSize,Math.min(HashMap.maxSize,initBucketNum));this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;bucketNum=initBucketNum;hashTable=[];};this.forEach=function(callback){var index=0;hashTable.forEach(function(container){container.forEach(function(element){callback(element,index++);});});};var reAllocate=function reAllocate(originalBucketNum){if(originalBucketNum>=HashMap.maxSize)return;bucketNum=originalBucketNum*2;var newHashTable=[];hashTable.forEach(function(container,index){if(container.empty())return;if(container instanceof LinkList_1["default"]&&container.size()===1){var _a=container.front(),key=_a.key,value=_a.value;newHashTable[hashFunc(key)&bucketNum-1]=new LinkList_1["default"]([{key:key,value:value}]);}else if(container instanceof Map_1["default"]){var lowList_1=new LinkList_1["default"]();var highList_1=new LinkList_1["default"]();container.forEach(function(pair){var hashCode=hashFunc(pair.key);if((hashCode&originalBucketNum)===0){lowList_1.pushBack(pair);}else highList_1.pushBack(pair);});if(lowList_1.size()>HashMap.untreeifyThreshold)newHashTable[index]=new Map_1["default"](lowList_1);else if(lowList_1.size())newHashTable[index]=lowList_1;if(highList_1.size()>HashMap.untreeifyThreshold)newHashTable[index+originalBucketNum]=new Map_1["default"](highList_1);else if(highList_1.size())newHashTable[index+originalBucketNum]=highList_1;}else {var lowList_2=new LinkList_1["default"]();var highList_2=new LinkList_1["default"]();container.forEach(function(pair){var hashCode=hashFunc(pair.key);if((hashCode&originalBucketNum)===0){lowList_2.pushBack(pair);}else highList_2.pushBack(pair);});if(lowList_2.size())newHashTable[index]=lowList_2;if(highList_2.size())newHashTable[index+originalBucketNum]=highList_2;}hashTable[index].clear();});hashTable=newHashTable;};this.setElement=function(key,value){var e_2,_a;if(key===null||key===undefined){throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");}if(value===null||value===undefined){this.eraseElementByKey(key);return;}var index=hashFunc(key)&bucketNum-1;if(!hashTable[index]){++len;hashTable[index]=new LinkList_1["default"]([{key:key,value:value}]);}else {var preSize=hashTable[index].size();if(hashTable[index]instanceof LinkList_1["default"]){try{for(var _b=__values(hashTable[index]),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;if(pair.key===key){pair.value=value;return;}}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_2)throw e_2.error;}}hashTable[index].pushBack({key:key,value:value});if(hashTable[index].size()>=HashMap.treeifyThreshold){hashTable[index]=new Map_1["default"](hashTable[index]);}}else hashTable[index].setElement(key,value);var curSize=hashTable[index].size();len+=curSize-preSize;}if(len>bucketNum*HashMap.sigma){reAllocate.call(this,bucketNum);}};this.getElementByKey=function(key){var e_3,_a;var index=hashFunc(key)&bucketNum-1;if(!hashTable[index])return undefined;if(hashTable[index]instanceof Map_1["default"])return hashTable[index].getElementByKey(key);else {try{for(var _b=__values(hashTable[index]),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;if(pair.key===key)return pair.value;}}catch(e_3_1){e_3={error:e_3_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_3)throw e_3.error;}}return undefined;}};this.eraseElementByKey=function(key){var e_4,_a;var index=hashFunc(key)&bucketNum-1;if(!hashTable[index])return;var preSize=hashTable[index].size();if(hashTable[index]instanceof Map_1["default"]){hashTable[index].eraseElementByKey(key);if(hashTable[index].size()<=HashMap.untreeifyThreshold){hashTable[index]=new LinkList_1["default"](hashTable[index]);}}else {var pos=-1;try{for(var _b=__values(hashTable[index]),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;++pos;if(pair.key===key){hashTable[index].eraseElementByPos(pos);break;}}}catch(e_4_1){e_4={error:e_4_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_4)throw e_4.error;}}}var curSize=hashTable[index].size();len+=curSize-preSize;};this.find=function(key){var e_5,_a;var index=hashFunc(key)&bucketNum-1;if(!hashTable[index])return false;if(hashTable[index]instanceof Map_1["default"])return hashTable[index].find(key);try{for(var _b=__values(hashTable[index]),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;if(pair.key===key)return true;}}catch(e_5_1){e_5={error:e_5_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_5)throw e_5.error;}}return false;};this[Symbol.iterator]=function(){return function(){var index,_a,_b,pair,e_6_1;var e_6,_c;return __generator(this,function(_d){switch(_d.label){case 0:index=0;_d.label=1;case 1:if(!(index<bucketNum))return [3/*break*/,10];while(index<bucketNum&&!hashTable[index]){++index;}if(index>=bucketNum)return [3/*break*/,10];_d.label=2;case 2:_d.trys.push([2,7,8,9]);_a=(e_6=void 0,__values(hashTable[index])),_b=_a.next();_d.label=3;case 3:if(!!_b.done)return [3/*break*/,6];pair=_b.value;return [4/*yield*/,pair];case 4:_d.sent();_d.label=5;case 5:_b=_a.next();return [3/*break*/,3];case 6:return [3/*break*/,9];case 7:e_6_1=_d.sent();e_6={error:e_6_1};return [3/*break*/,9];case 8:try{if(_b&&!_b.done&&(_c=_a["return"]))_c.call(_a);}finally{if(e_6)throw e_6.error;}return [7/*endfinally*/];case 9:++index;return [3/*break*/,1];case 10:return [2/*return*/];}});}();};container.forEach(function(_a){var key=_a.key,value=_a.value;return _this.setElement(key,value);});Object.freeze(this);}Object.freeze(HashMap);exports["default"]=HashMap;},{"../LinkList/LinkList":29,"../Map/Map":30}],28:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};var __values=this&&this.__values||function(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return {next:function next(){if(o&&i>=o.length)o=void 0;return {value:o&&o[i++],done:!o};}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",{value:true});var Set_1=require("../Set/Set");var LinkList_1=require("../LinkList/LinkList");HashSet.initSize=1<<4;HashSet.maxSize=1<<30;HashSet.sigma=0.75;// default load factor
HashSet.treeifyThreshold=8;HashSet.untreeifyThreshold=6;HashSet.minTreeifySize=64;/**
	 * Note that resize is a time-consuming operation, please try to determine the number of buckets before use.
	 * @param container Initialize the container
	 * @param initBucketNum Initialize the bucket num
	 * @param hashFunc Function to map elements to numbers
	 * @constructor
	 */function HashSet(container,initBucketNum,hashFunc){var _this=this;if(container===void 0){container=[];}if(initBucketNum===void 0){initBucketNum=HashSet.initSize;}hashFunc=hashFunc||function(x){var hashCode=0;var str='';if(typeof x==="number"){hashCode=Math.floor(x);hashCode=(hashCode<<5)-hashCode;hashCode=hashCode&hashCode;}else {if(typeof x!=="string"){str=JSON.stringify(x);}else str=x;for(var i=0;i<str.length;i++){var character=str.charCodeAt(i);hashCode=(hashCode<<5)-hashCode+character;hashCode=hashCode&hashCode;}}hashCode^=hashCode>>>16;return hashCode;};if((initBucketNum&initBucketNum-1)!==0){throw new Error("initBucketNum must be 2 to the power of n");}var len=0;var hashTable=[];var bucketNum=Math.max(HashSet.initSize,Math.min(HashSet.maxSize,initBucketNum));this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;bucketNum=initBucketNum;hashTable=[];};this.forEach=function(callback){var index=0;hashTable.forEach(function(container){container.forEach(function(element){callback(element,index++);});});};var reAllocate=function reAllocate(originalBucketNum){if(originalBucketNum>=HashSet.maxSize)return;bucketNum=originalBucketNum*2;var newHashTable=[];hashTable.forEach(function(container,index){if(container.empty())return;if(container instanceof LinkList_1["default"]&&container.size()===1){var element=container.front();if(element===undefined)throw new Error("unknown error");newHashTable[hashFunc(element)&bucketNum-1]=new LinkList_1["default"]([element]);}else if(container instanceof Set_1["default"]){var lowList_1=new LinkList_1["default"]();var highList_1=new LinkList_1["default"]();container.forEach(function(element){var hashCode=hashFunc(element);if((hashCode&originalBucketNum)===0){lowList_1.pushBack(element);}else highList_1.pushBack(element);});if(lowList_1.size()>HashSet.untreeifyThreshold)newHashTable[index]=new Set_1["default"](lowList_1);else if(lowList_1.size())newHashTable[index]=lowList_1;if(highList_1.size()>HashSet.untreeifyThreshold)newHashTable[index+originalBucketNum]=new Set_1["default"](highList_1);else if(highList_1.size())newHashTable[index+originalBucketNum]=highList_1;}else {var lowList_2=new LinkList_1["default"]();var highList_2=new LinkList_1["default"]();container.forEach(function(element){var hashCode=hashFunc(element);if((hashCode&originalBucketNum)===0){lowList_2.pushBack(element);}else highList_2.pushBack(element);});if(lowList_2.size())newHashTable[index]=lowList_2;if(highList_2.size())newHashTable[index+originalBucketNum]=highList_2;}hashTable[index].clear();});hashTable=newHashTable;};this.insert=function(element){if(element===null||element===undefined){throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");}var index=hashFunc(element)&bucketNum-1;if(!hashTable[index]){hashTable[index]=new LinkList_1["default"]([element]);++len;}else {var preSize=hashTable[index].size();if(hashTable[index]instanceof LinkList_1["default"]){if(hashTable[index].find(element))return;hashTable[index].pushBack(element);if(hashTable[index].size()>=HashSet.treeifyThreshold){hashTable[index]=new Set_1["default"](hashTable[index]);}}else hashTable[index].insert(element);var curSize=hashTable[index].size();len+=curSize-preSize;}if(len>bucketNum*HashSet.sigma){reAllocate.call(this,bucketNum);}};this.eraseElementByValue=function(element){var index=hashFunc(element)&bucketNum-1;if(!hashTable[index])return;var preSize=hashTable[index].size();hashTable[index].eraseElementByValue(element);if(hashTable[index]instanceof Set_1["default"]){if(hashTable[index].size()<=HashSet.untreeifyThreshold){hashTable[index]=new LinkList_1["default"](hashTable[index]);}}var curSize=hashTable[index].size();len+=curSize-preSize;};this.find=function(element){var index=hashFunc(element)&bucketNum-1;if(!hashTable[index])return false;return hashTable[index].find(element);};this[Symbol.iterator]=function(){return function(){var index,_a,_b,element,e_1_1;var e_1,_c;return __generator(this,function(_d){switch(_d.label){case 0:index=0;_d.label=1;case 1:if(!(index<bucketNum))return [3/*break*/,10];while(index<bucketNum&&!hashTable[index]){++index;}if(index>=bucketNum)return [3/*break*/,10];_d.label=2;case 2:_d.trys.push([2,7,8,9]);_a=(e_1=void 0,__values(hashTable[index])),_b=_a.next();_d.label=3;case 3:if(!!_b.done)return [3/*break*/,6];element=_b.value;return [4/*yield*/,element];case 4:_d.sent();_d.label=5;case 5:_b=_a.next();return [3/*break*/,3];case 6:return [3/*break*/,9];case 7:e_1_1=_d.sent();e_1={error:e_1_1};return [3/*break*/,9];case 8:try{if(_b&&!_b.done&&(_c=_a["return"]))_c.call(_a);}finally{if(e_1)throw e_1.error;}return [7/*endfinally*/];case 9:++index;return [3/*break*/,1];case 10:return [2/*return*/];}});}();};container.forEach(function(element){return _this.insert(element);});Object.freeze(this);}Object.freeze(HashSet);exports["default"]=HashSet;},{"../LinkList/LinkList":29,"../Set/Set":33}],29:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};Object.defineProperty(exports,"__esModule",{value:true});var LinkNode=/** @class */function(){function LinkNode(element){this.value=undefined;this.pre=undefined;this.next=undefined;this.value=element;}return LinkNode;}();function LinkList(container){var _this=this;if(container===void 0){container=[];}var len=0;var head=undefined;var tail=undefined;this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){head=tail=undefined;len=0;};this.front=function(){return head===null||head===void 0?void 0:head.value;};this.back=function(){return tail===null||tail===void 0?void 0:tail.value;};this.forEach=function(callback){var curNode=head;var index=0;while(curNode){if(curNode.value===undefined)throw new Error("unknown error");callback(curNode.value,index++);curNode=curNode.next;}};this.getElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("pos must more then 0 and less then the list length");var curNode=head;while(pos--){if(!curNode)break;curNode=curNode.next;}if(!curNode||curNode.value===undefined)throw new Error("unknown error");return curNode.value;};this.eraseElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("erase pos must more then 0 and less then the list length");if(pos===0)this.popFront();else if(pos===len-1)this.popBack();else {var curNode=head;while(pos--){if(!(curNode===null||curNode===void 0?void 0:curNode.next))throw new Error("unknown error");curNode=curNode.next;}if(!curNode||!curNode.pre||!curNode.next){throw new Error("unknown error");}var pre=curNode.pre;var next=curNode.next;next.pre=pre;pre.next=next;if(len>0)--len;}};this.eraseElementByValue=function(value){while(head&&head.value===value){this.popFront();}while(tail&&tail.value===value){this.popBack();}if(!head)return;var curNode=head;while(curNode){if(curNode.value===value){var pre=curNode.pre;var next=curNode.next;if(next)next.pre=pre;if(pre)pre.next=next;if(len>0)--len;}curNode=curNode.next;}};this.pushBack=function(element){if(element===null||element===undefined){throw new Error("you can't push null or undefined here");}++len;var newTail=new LinkNode(element);if(!tail){head=tail=newTail;}else {tail.next=newTail;newTail.pre=tail;tail=newTail;}};this.popBack=function(){if(!tail)return;if(len>0)--len;if(!tail)return;if(head===tail){head=tail=undefined;}else {tail=tail.pre;if(tail)tail.next=undefined;}};this.setElementByPos=function(pos,element){if(element===null||element===undefined){throw new Error("you can't set null or undefined here");}if(pos<0||pos>=len)throw new Error("pos must more then 0 and less then the list length");var curNode=head;while(pos--){if(!curNode)throw new Error("unknown error");curNode=curNode.next;}if(curNode)curNode.value=element;};/**
	     * @param {number} pos insert element before pos, should in [0, list.size]
	     * @param {any} element the element you want to insert
	     * @param {number} [num = 1] the nums you want to insert
	     */this.insert=function(pos,element,num){if(num===void 0){num=1;}if(element===null||element===undefined){throw new Error("you can't insert null or undefined here");}if(pos<0||pos>len)throw new Error("insert pos must more then 0 and less then or equal to the list length");if(num<0)throw new Error("insert size must more than 0");if(pos===0){while(num--){this.pushFront(element);}}else if(pos===len){while(num--){this.pushBack(element);}}else {var curNode=head;for(var i=1;i<pos;++i){if(!(curNode===null||curNode===void 0?void 0:curNode.next))throw new Error("unknown error");curNode=curNode===null||curNode===void 0?void 0:curNode.next;}if(!curNode){throw new Error("unknown error");}var next=curNode.next;len+=num;while(num--){curNode.next=new LinkNode(element);curNode.next.pre=curNode;curNode=curNode.next;}curNode.next=next;if(next)next.pre=curNode;}};this.find=function(element){var curNode=head;while(curNode){if(curNode.value===element)return true;curNode=curNode.next;}return false;};this.reverse=function(){var pHead=head;var pTail=tail;var cnt=0;while(pHead&&pTail&&cnt*2<len){var tmp=pHead.value;pHead.value=pTail.value;pTail.value=tmp;pHead=pHead.next;pTail=pTail.pre;++cnt;}};this.unique=function(){var curNode=head;while(curNode){var tmpNode=curNode;while(tmpNode&&tmpNode.next&&tmpNode.value===tmpNode.next.value){tmpNode=tmpNode.next;if(len>0)--len;}curNode.next=tmpNode.next;if(curNode.next)curNode.next.pre=curNode;curNode=curNode.next;}};this.sort=function(cmp){var arr=[];this.forEach(function(element){arr.push(element);});arr.sort(cmp);var curNode=head;arr.forEach(function(element){if(curNode){curNode.value=element;curNode=curNode.next;}});};this.pushFront=function(element){if(element===null||element===undefined){throw new Error("you can't push null or undefined here");}++len;var newHead=new LinkNode(element);if(!head){head=tail=newHead;}else {newHead.next=head;head.pre=newHead;head=newHead;}};this.popFront=function(){if(!head)return;if(len>0)--len;if(!head)return;if(head===tail){head=tail=undefined;}else {head=head.next;if(head)head.pre=undefined;}};/**
	     * merge two sorted lists
	     * @param list other list
	     */this.merge=function(list){var _this=this;var curNode=head;list.forEach(function(element){while(curNode&&curNode.value!==undefined&&curNode.value<=element){curNode=curNode.next;}if(curNode===undefined){_this.pushBack(element);curNode=tail;}else if(curNode===head){_this.pushFront(element);curNode=head;}else {++len;var pre=curNode.pre;if(pre){pre.next=new LinkNode(element);pre.next.pre=pre;pre.next.next=curNode;if(curNode)curNode.pre=pre.next;}}});};this[Symbol.iterator]=function(){return function(){var curNode;return __generator(this,function(_a){switch(_a.label){case 0:curNode=head;_a.label=1;case 1:if(!(curNode!==undefined))return [3/*break*/,3];if(!curNode.value)throw new Error("unknown error");return [4/*yield*/,curNode.value];case 2:_a.sent();curNode=curNode.next;return [3/*break*/,1];case 3:return [2/*return*/];}});}();};container.forEach(function(element){return _this.pushBack(element);});Object.freeze(this);}Object.freeze(LinkList);exports["default"]=LinkList;},{}],30:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};var __values=this&&this.__values||function(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return {next:function next(){if(o&&i>=o.length)o=void 0;return {value:o&&o[i++],done:!o};}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",{value:true});var TreeNode_1=require("../Base/TreeNode");function Map(container,cmp){var _this=this;if(container===void 0){container=[];}cmp=cmp||function(x,y){if(x<y)return -1;if(x>y)return 1;return 0;};var len=0;var root=new TreeNode_1["default"]();root.color=TreeNode_1["default"].TreeNodeColorType.black;this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;root.key=root.value=undefined;root.leftChild=root.rightChild=root.brother=undefined;};var findSubTreeMinNode=function findSubTreeMinNode(curNode){if(!curNode||curNode.key===undefined)throw new Error("unknown error");return curNode.leftChild?findSubTreeMinNode(curNode.leftChild):curNode;};var findSubTreeMaxNode=function findSubTreeMaxNode(curNode){if(!curNode||curNode.key===undefined)throw new Error("unknown error");return curNode.rightChild?findSubTreeMaxNode(curNode.rightChild):curNode;};this.front=function(){if(this.empty())return undefined;var minNode=findSubTreeMinNode(root);if(minNode.key===undefined||minNode.value===undefined)throw new Error("unknown error");return {key:minNode.key,value:minNode.value};};this.back=function(){if(this.empty())return undefined;var maxNode=findSubTreeMaxNode(root);if(maxNode.key===undefined||maxNode.value===undefined)throw new Error("unknown error");return {key:maxNode.key,value:maxNode.value};};this.forEach=function(callback){var e_1,_a;var index=0;try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;callback(pair,index++);}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_1)throw e_1.error;}}};this.getElementByPos=function(pos){var e_2,_a;if(pos<0||pos>=this.size())throw new Error("pos must more than 0 and less than set's size");var index=0;try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var pair=_c.value;if(index===pos)return pair;++index;}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_2)throw e_2.error;}}throw new Error("unknown Error");};var _lowerBound=function _lowerBound(curNode,key){if(!curNode||curNode.key===undefined||curNode.value===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult===0)return {key:curNode.key,value:curNode.value};if(cmpResult<0)return _lowerBound(curNode.rightChild,key);return _lowerBound(curNode.leftChild,key)||{key:curNode.key,value:curNode.value};};this.lowerBound=function(key){return _lowerBound(root,key);};var _upperBound=function _upperBound(curNode,key){if(!curNode||curNode.key===undefined||curNode.value===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult<=0)return _upperBound(curNode.rightChild,key);return _upperBound(curNode.leftChild,key)||{key:curNode.key,value:curNode.value};};this.upperBound=function(key){return _upperBound(root,key);};var _reverseLowerBound=function _reverseLowerBound(curNode,key){if(!curNode||curNode.key===undefined||curNode.value===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult===0)return {key:curNode.key,value:curNode.value};if(cmpResult>0)return _reverseLowerBound(curNode.leftChild,key);return _reverseLowerBound(curNode.rightChild,key)||{key:curNode.key,value:curNode.value};};this.reverseLowerBound=function(key){return _reverseLowerBound(root,key);};var _reverseUpperBound=function _reverseUpperBound(curNode,key){if(!curNode||curNode.key===undefined||curNode.value===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult>=0)return _reverseUpperBound(curNode.leftChild,key);return _reverseUpperBound(curNode.rightChild,key)||{key:curNode.key,value:curNode.value};};this.reverseUpperBound=function(key){return _reverseUpperBound(root,key);};var eraseNodeSelfBalance=function eraseNodeSelfBalance(curNode){var parentNode=curNode.parent;if(!parentNode){if(curNode===root)return;throw new Error("unknown error");}if(curNode.color===TreeNode_1["default"].TreeNodeColorType.red){curNode.color=TreeNode_1["default"].TreeNodeColorType.black;return;}var brotherNode=curNode.brother;if(!brotherNode)throw new Error("unknown error");if(curNode===parentNode.leftChild){if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.black;parentNode.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=parentNode.rotateLeft();if(root===parentNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(brotherNode.rightChild&&brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=parentNode.color;parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;if(brotherNode.rightChild)brotherNode.rightChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=parentNode.rotateLeft();if(root===parentNode)root=newRoot;curNode.color=TreeNode_1["default"].TreeNodeColorType.black;}else if((!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&brotherNode.leftChild&&brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;if(brotherNode.leftChild)brotherNode.leftChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=brotherNode.rotateRight();if(root===brotherNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&(!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;eraseNodeSelfBalance(parentNode);}}}else if(curNode===parentNode.rightChild){if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.black;parentNode.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=parentNode.rotateRight();if(root===parentNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(brotherNode.leftChild&&brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=parentNode.color;parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;if(brotherNode.leftChild)brotherNode.leftChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=parentNode.rotateRight();if(root===parentNode)root=newRoot;curNode.color=TreeNode_1["default"].TreeNodeColorType.black;}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&brotherNode.rightChild&&brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;if(brotherNode.rightChild)brotherNode.rightChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=brotherNode.rotateLeft();if(root===brotherNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&(!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;eraseNodeSelfBalance(parentNode);}}}};var eraseNode=function eraseNode(curNode){var swapNode=curNode;while(swapNode.leftChild||swapNode.rightChild){if(swapNode.rightChild){swapNode=findSubTreeMinNode(swapNode.rightChild);var tmpKey=curNode.key;curNode.key=swapNode.key;swapNode.key=tmpKey;var tmpValue=curNode.value;curNode.value=swapNode.value;swapNode.value=tmpValue;curNode=swapNode;}if(swapNode.leftChild){swapNode=findSubTreeMaxNode(swapNode.leftChild);var tmpKey=curNode.key;curNode.key=swapNode.key;swapNode.key=tmpKey;var tmpValue=curNode.value;curNode.value=swapNode.value;swapNode.value=tmpValue;curNode=swapNode;}}eraseNodeSelfBalance(swapNode);if(swapNode)swapNode.remove();--len;root.color=TreeNode_1["default"].TreeNodeColorType.black;};var inOrderTraversal=function inOrderTraversal(curNode,callback){if(!curNode||curNode.key===undefined)return false;var ifReturn=inOrderTraversal(curNode.leftChild,callback);if(ifReturn)return true;if(callback(curNode))return true;return inOrderTraversal(curNode.rightChild,callback);};this.eraseElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("pos must more than 0 and less than set's size");var index=0;inOrderTraversal(root,function(curNode){if(pos===index){eraseNode(curNode);return true;}++index;return false;});};this.eraseElementByKey=function(key){if(this.empty())return;var curNode=findElementPos(root,key);if(curNode===undefined||curNode.key===undefined||cmp(curNode.key,key)!==0)return;eraseNode(curNode);};var findInsertPos=function findInsertPos(curNode,element){if(!curNode||curNode.key===undefined)throw new Error("unknown error");var cmpResult=cmp(element,curNode.key);if(cmpResult<0){if(!curNode.leftChild){curNode.leftChild=new TreeNode_1["default"]();curNode.leftChild.parent=curNode;curNode.leftChild.brother=curNode.rightChild;if(curNode.rightChild)curNode.rightChild.brother=curNode.leftChild;return curNode.leftChild;}return findInsertPos(curNode.leftChild,element);}else if(cmpResult>0){if(!curNode.rightChild){curNode.rightChild=new TreeNode_1["default"]();curNode.rightChild.parent=curNode;curNode.rightChild.brother=curNode.leftChild;if(curNode.leftChild)curNode.leftChild.brother=curNode.rightChild;return curNode.rightChild;}return findInsertPos(curNode.rightChild,element);}return curNode;};var insertNodeSelfBalance=function insertNodeSelfBalance(curNode){var parentNode=curNode.parent;if(!parentNode){if(curNode===root)return;throw new Error("unknown error");}if(parentNode.color===TreeNode_1["default"].TreeNodeColorType.black)return;if(parentNode.color===TreeNode_1["default"].TreeNodeColorType.red){var uncleNode=parentNode.brother;var grandParent=parentNode.parent;if(!grandParent)throw new Error("unknown error");if(uncleNode&&uncleNode.color===TreeNode_1["default"].TreeNodeColorType.red){uncleNode.color=parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;insertNodeSelfBalance(grandParent);}else if(!uncleNode||uncleNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(parentNode===grandParent.leftChild){if(curNode===parentNode.leftChild){parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=grandParent.rotateRight();if(grandParent===root)root=newRoot;}else if(curNode===parentNode.rightChild){var newRoot=parentNode.rotateLeft();if(grandParent===root)root=newRoot;insertNodeSelfBalance(parentNode);}}else if(parentNode===grandParent.rightChild){if(curNode===parentNode.leftChild){var newRoot=parentNode.rotateRight();if(grandParent===root)root=newRoot;insertNodeSelfBalance(parentNode);}else if(curNode===parentNode.rightChild){parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=grandParent.rotateLeft();if(grandParent===root)root=newRoot;}}}}};this.setElement=function(key,value){if(key===null||key===undefined){throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");}if(value===null||value===undefined){this.eraseElementByKey(key);return;}if(this.empty()){++len;root.key=key;root.value=value;root.color=TreeNode_1["default"].TreeNodeColorType.black;return;}var curNode=findInsertPos(root,key);if(curNode.key!==undefined&&cmp(curNode.key,key)===0){curNode.value=value;return;}++len;curNode.key=key;curNode.value=value;insertNodeSelfBalance(curNode);root.color=TreeNode_1["default"].TreeNodeColorType.black;};var findElementPos=function findElementPos(curNode,element){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(element,curNode.key);if(cmpResult<0)return findElementPos(curNode.leftChild,element);else if(cmpResult>0)return findElementPos(curNode.rightChild,element);return curNode;};this.find=function(element){return !!findElementPos(root,element);};this.getElementByKey=function(element){var curNode=findElementPos(root,element);if((curNode===null||curNode===void 0?void 0:curNode.key)===undefined||(curNode===null||curNode===void 0?void 0:curNode.value)===undefined)throw new Error("unknown error");return curNode.value;};// waiting for optimization, this is O(mlog(n+m)) algorithm now, but we expect it to be O(mlog(n/m+1)).
// (https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Set_operations_and_bulk_operations)
this.union=function(other){var _this=this;other.forEach(function(_a){var key=_a.key,value=_a.value;return _this.setElement(key,value);});};this.getHeight=function(){if(this.empty())return 0;var traversal=function traversal(curNode){if(!curNode)return 1;return Math.max(traversal(curNode.leftChild),traversal(curNode.rightChild))+1;};return traversal(root);};var iterationFunc=function iterationFunc(curNode){return __generator(this,function(_a){switch(_a.label){case 0:if(!curNode||curNode.key===undefined||curNode.value===undefined)return [2/*return*/];return [5/*yield**/,__values(iterationFunc(curNode.leftChild))];case 1:_a.sent();return [4/*yield*/,{key:curNode.key,value:curNode.value}];case 2:_a.sent();return [5/*yield**/,__values(iterationFunc(curNode.rightChild))];case 3:_a.sent();return [2/*return*/];}});};this[Symbol.iterator]=function(){return iterationFunc(root);};container.forEach(function(_a){var key=_a.key,value=_a.value;return _this.setElement(key,value);});Object.freeze(this);}Object.freeze(Map);exports["default"]=Map;},{"../Base/TreeNode":25}],31:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});/**
	 * @param container
	 * @param cmp default cmp will generate a max heap
	 * @constructor
	 */function PriorityQueue(container,cmp){if(container===void 0){container=[];}cmp=cmp||function(x,y){if(x>y)return -1;if(x<y)return 1;return 0;};var priorityQueue=[];container.forEach(function(element){return priorityQueue.push(element);});var len=priorityQueue.length;var swap=function swap(x,y){if(x<0||x>=len)throw new Error("unknown error");if(y<0||y>=len)throw new Error("unknown error");var tmp=priorityQueue[x];priorityQueue[x]=priorityQueue[y];priorityQueue[y]=tmp;};var adjust=function adjust(parent){if(parent<0||parent>=len)throw new Error("unknown error");var leftChild=parent*2+1;var rightChild=parent*2+2;if(leftChild<len&&cmp(priorityQueue[parent],priorityQueue[leftChild])>0)swap(parent,leftChild);if(rightChild<len&&cmp(priorityQueue[parent],priorityQueue[rightChild])>0)swap(parent,rightChild);};(function(){for(var parent_1=Math.floor((len-1)/2);parent_1>=0;--parent_1){var curParent=parent_1;var curChild=curParent*2+1;while(curChild<len){var leftChild=curChild;var rightChild=leftChild+1;var minChild=leftChild;if(rightChild<len&&cmp(priorityQueue[leftChild],priorityQueue[rightChild])>0)minChild=rightChild;if(cmp(priorityQueue[curParent],priorityQueue[minChild])<=0)break;swap(curParent,minChild);curParent=minChild;curChild=curParent*2+1;}}})();this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;priorityQueue.length=0;};this.push=function(element){priorityQueue.push(element);++len;if(len===1)return;var curNode=len-1;while(curNode>0){var parent_2=Math.floor((curNode-1)/2);if(cmp(priorityQueue[parent_2],element)<=0)break;adjust(parent_2);curNode=parent_2;}};this.pop=function(){if(this.empty())return;if(this.size()===1){--len;return;}var last=priorityQueue[len-1];--len;var parent=0;while(parent<this.size()){var leftChild=parent*2+1;var rightChild=parent*2+2;if(leftChild>=this.size())break;var minChild=leftChild;if(rightChild<this.size()&&cmp(priorityQueue[leftChild],priorityQueue[rightChild])>0)minChild=rightChild;if(cmp(priorityQueue[minChild],last)>=0)break;priorityQueue[parent]=priorityQueue[minChild];parent=minChild;}priorityQueue[parent]=last;};this.top=function(){return priorityQueue[0];};Object.freeze(this);}Object.freeze(PriorityQueue);exports["default"]=PriorityQueue;},{}],32:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});var LinkList_1=require("../LinkList/LinkList");function Queue(container){if(container===void 0){container=[];}var queue=new LinkList_1["default"](container);this.size=function(){return queue.size();};this.empty=function(){return queue.empty();};this.clear=function(){queue.clear();};this.push=function(element){queue.pushBack(element);};this.pop=function(){queue.popFront();};this.front=function(){return queue.front();};Object.freeze(this);}Object.freeze(Queue);exports["default"]=Queue;},{"../LinkList/LinkList":29}],33:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};var __values=this&&this.__values||function(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return {next:function next(){if(o&&i>=o.length)o=void 0;return {value:o&&o[i++],done:!o};}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",{value:true});var TreeNode_1=require("../Base/TreeNode");function Set(container,cmp){var _this=this;if(container===void 0){container=[];}cmp=cmp||function(x,y){if(x<y)return -1;if(x>y)return 1;return 0;};var len=0;var root=new TreeNode_1["default"]();root.color=TreeNode_1["default"].TreeNodeColorType.black;this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;root.key=undefined;root.leftChild=root.rightChild=root.brother=root.parent=undefined;root.color=TreeNode_1["default"].TreeNodeColorType.black;};var findSubTreeMinNode=function findSubTreeMinNode(curNode){if(!curNode||curNode.key===undefined)throw new Error("unknown error");return curNode.leftChild?findSubTreeMinNode(curNode.leftChild):curNode;};var findSubTreeMaxNode=function findSubTreeMaxNode(curNode){if(!curNode||curNode.key===undefined)throw new Error("unknown error");return curNode.rightChild?findSubTreeMaxNode(curNode.rightChild):curNode;};this.front=function(){if(this.empty())return undefined;var minNode=findSubTreeMinNode(root);return minNode.key;};this.back=function(){if(this.empty())return undefined;var maxNode=findSubTreeMaxNode(root);return maxNode.key;};this.forEach=function(callback){var e_1,_a;var index=0;try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var element=_c.value;callback(element,index++);}}catch(e_1_1){e_1={error:e_1_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_1)throw e_1.error;}}};this.getElementByPos=function(pos){var e_2,_a;if(pos<0||pos>=this.size())throw new Error("pos must more than 0 and less than set's size");var index=0;try{for(var _b=__values(this),_c=_b.next();!_c.done;_c=_b.next()){var element=_c.value;if(index===pos)return element;++index;}}catch(e_2_1){e_2={error:e_2_1};}finally{try{if(_c&&!_c.done&&(_a=_b["return"]))_a.call(_b);}finally{if(e_2)throw e_2.error;}}throw new Error("unknown error");};var eraseNodeSelfBalance=function eraseNodeSelfBalance(curNode){var parentNode=curNode.parent;if(!parentNode){if(curNode===root)return;throw new Error("unknown error");}if(curNode.color===TreeNode_1["default"].TreeNodeColorType.red){curNode.color=TreeNode_1["default"].TreeNodeColorType.black;return;}var brotherNode=curNode.brother;if(!brotherNode)throw new Error("unknown error");if(curNode===parentNode.leftChild){if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.black;parentNode.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=parentNode.rotateLeft();if(root===parentNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(brotherNode.rightChild&&brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=parentNode.color;parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;if(brotherNode.rightChild)brotherNode.rightChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=parentNode.rotateLeft();if(root===parentNode)root=newRoot;curNode.color=TreeNode_1["default"].TreeNodeColorType.black;}else if((!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&brotherNode.leftChild&&brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;if(brotherNode.leftChild)brotherNode.leftChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=brotherNode.rotateRight();if(root===brotherNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&(!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;eraseNodeSelfBalance(parentNode);}}}else if(curNode===parentNode.rightChild){if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.black;parentNode.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=parentNode.rotateRight();if(root===parentNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if(brotherNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(brotherNode.leftChild&&brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=parentNode.color;parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;if(brotherNode.leftChild)brotherNode.leftChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=parentNode.rotateRight();if(root===parentNode)root=newRoot;curNode.color=TreeNode_1["default"].TreeNodeColorType.black;}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&brotherNode.rightChild&&brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.red){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;if(brotherNode.rightChild)brotherNode.rightChild.color=TreeNode_1["default"].TreeNodeColorType.black;var newRoot=brotherNode.rotateLeft();if(root===brotherNode)root=newRoot;eraseNodeSelfBalance(curNode);}else if((!brotherNode.leftChild||brotherNode.leftChild.color===TreeNode_1["default"].TreeNodeColorType.black)&&(!brotherNode.rightChild||brotherNode.rightChild.color===TreeNode_1["default"].TreeNodeColorType.black)){brotherNode.color=TreeNode_1["default"].TreeNodeColorType.red;eraseNodeSelfBalance(parentNode);}}}};var eraseNode=function eraseNode(curNode){var swapNode=curNode;while(swapNode.leftChild||swapNode.rightChild){if(swapNode.rightChild){swapNode=findSubTreeMinNode(swapNode.rightChild);var tmpKey=curNode.key;curNode.key=swapNode.key;swapNode.key=tmpKey;curNode=swapNode;}if(swapNode.leftChild){swapNode=findSubTreeMaxNode(swapNode.leftChild);var tmpKey=curNode.key;curNode.key=swapNode.key;swapNode.key=tmpKey;curNode=swapNode;}}eraseNodeSelfBalance(swapNode);if(swapNode)swapNode.remove();--len;root.color=TreeNode_1["default"].TreeNodeColorType.black;};var inOrderTraversal=function inOrderTraversal(curNode,callback){if(!curNode||curNode.key===undefined)return false;var ifReturn=inOrderTraversal(curNode.leftChild,callback);if(ifReturn)return true;if(callback(curNode))return true;return inOrderTraversal(curNode.rightChild,callback);};this.eraseElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("pos must more than 0 and less than set's size");var index=0;inOrderTraversal(root,function(curNode){if(pos===index){eraseNode(curNode);return true;}++index;return false;});};this.eraseElementByValue=function(value){if(this.empty())return;var curNode=findElementPos(root,value);if(curNode===undefined||curNode.key===undefined||cmp(curNode.key,value)!==0)return;eraseNode(curNode);};var findInsertPos=function findInsertPos(curNode,element){if(!curNode||curNode.key===undefined)throw new Error("unknown error");var cmpResult=cmp(element,curNode.key);if(cmpResult<0){if(!curNode.leftChild){curNode.leftChild=new TreeNode_1["default"]();curNode.leftChild.parent=curNode;curNode.leftChild.brother=curNode.rightChild;if(curNode.rightChild)curNode.rightChild.brother=curNode.leftChild;return curNode.leftChild;}return findInsertPos(curNode.leftChild,element);}else if(cmpResult>0){if(!curNode.rightChild){curNode.rightChild=new TreeNode_1["default"]();curNode.rightChild.parent=curNode;curNode.rightChild.brother=curNode.leftChild;if(curNode.leftChild)curNode.leftChild.brother=curNode.rightChild;return curNode.rightChild;}return findInsertPos(curNode.rightChild,element);}return curNode;};var insertNodeSelfBalance=function insertNodeSelfBalance(curNode){var parentNode=curNode.parent;if(!parentNode){if(curNode===root)return;throw new Error("unknown error");}if(parentNode.color===TreeNode_1["default"].TreeNodeColorType.black)return;if(parentNode.color===TreeNode_1["default"].TreeNodeColorType.red){var uncleNode=parentNode.brother;var grandParent=parentNode.parent;if(!grandParent)throw new Error("unknown error");if(uncleNode&&uncleNode.color===TreeNode_1["default"].TreeNodeColorType.red){uncleNode.color=parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;insertNodeSelfBalance(grandParent);}else if(!uncleNode||uncleNode.color===TreeNode_1["default"].TreeNodeColorType.black){if(parentNode===grandParent.leftChild){if(curNode===parentNode.leftChild){parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=grandParent.rotateRight();if(grandParent===root)root=newRoot;}else if(curNode===parentNode.rightChild){var newRoot=parentNode.rotateLeft();if(grandParent===root)root=newRoot;insertNodeSelfBalance(parentNode);}}else if(parentNode===grandParent.rightChild){if(curNode===parentNode.leftChild){var newRoot=parentNode.rotateRight();if(grandParent===root)root=newRoot;insertNodeSelfBalance(parentNode);}else if(curNode===parentNode.rightChild){parentNode.color=TreeNode_1["default"].TreeNodeColorType.black;grandParent.color=TreeNode_1["default"].TreeNodeColorType.red;var newRoot=grandParent.rotateLeft();if(grandParent===root)root=newRoot;}}}}};this.insert=function(element){if(element===null||element===undefined){throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");}if(this.empty()){++len;root.key=element;root.color=TreeNode_1["default"].TreeNodeColorType.black;return;}var curNode=findInsertPos(root,element);if(curNode.key!==undefined&&cmp(curNode.key,element)===0)return;++len;curNode.key=element;insertNodeSelfBalance(curNode);root.color=TreeNode_1["default"].TreeNodeColorType.black;};var findElementPos=function findElementPos(curNode,element){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(element,curNode.key);if(cmpResult<0)return findElementPos(curNode.leftChild,element);else if(cmpResult>0)return findElementPos(curNode.rightChild,element);return curNode;};this.find=function(element){var curNode=findElementPos(root,element);return curNode!==undefined&&curNode.key!==undefined&&cmp(curNode.key,element)===0;};var _lowerBound=function _lowerBound(curNode,key){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult===0)return curNode.key;if(cmpResult<0)return _lowerBound(curNode.rightChild,key);var res=_lowerBound(curNode.leftChild,key);if(res!==undefined)return res;return curNode.key;};this.lowerBound=function(key){return _lowerBound(root,key);};var _upperBound=function _upperBound(curNode,key){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult<=0)return _upperBound(curNode.rightChild,key);var res=_upperBound(curNode.leftChild,key);if(res!==undefined)return res;return curNode.key;};this.upperBound=function(key){return _upperBound(root,key);};var _reverseLowerBound=function _reverseLowerBound(curNode,key){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult===0)return curNode.key;if(cmpResult>0)return _reverseLowerBound(curNode.leftChild,key);var res=_reverseLowerBound(curNode.rightChild,key);if(res!==undefined)return res;return curNode.key;};this.reverseLowerBound=function(key){return _reverseLowerBound(root,key);};var _reverseUpperBound=function _reverseUpperBound(curNode,key){if(!curNode||curNode.key===undefined)return undefined;var cmpResult=cmp(curNode.key,key);if(cmpResult>=0)return _reverseUpperBound(curNode.leftChild,key);var res=_reverseUpperBound(curNode.rightChild,key);if(res!==undefined)return res;return curNode.key;};this.reverseUpperBound=function(key){return _reverseUpperBound(root,key);};// waiting for optimization, this is O(mlog(n+m)) algorithm now, but we expect it to be O(mlog(n/m+1)).
// (https://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Set_operations_and_bulk_operations)
this.union=function(other){var _this=this;other.forEach(function(element){return _this.insert(element);});};this.getHeight=function(){if(this.empty())return 0;var traversal=function traversal(curNode){if(!curNode)return 1;return Math.max(traversal(curNode.leftChild),traversal(curNode.rightChild))+1;};return traversal(root);};var iterationFunc=function iterationFunc(curNode){return __generator(this,function(_a){switch(_a.label){case 0:if(!curNode||curNode.key===undefined)return [2/*return*/];return [5/*yield**/,__values(iterationFunc(curNode.leftChild))];case 1:_a.sent();return [4/*yield*/,curNode.key];case 2:_a.sent();return [5/*yield**/,__values(iterationFunc(curNode.rightChild))];case 3:_a.sent();return [2/*return*/];}});};this[Symbol.iterator]=function(){return iterationFunc(root);};container.forEach(function(element){return _this.insert(element);});Object.freeze(this);}Object.freeze(Set);exports["default"]=Set;},{"../Base/TreeNode":25}],34:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});function Stack(container){var _this=this;if(container===void 0){container=[];}var len=0;var stack=[];this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;stack.length=0;};this.push=function(element){stack.push(element);++len;};this.pop=function(){stack.pop();if(len>0)--len;};this.top=function(){return stack[len-1];};container.forEach(function(element){return _this.push(element);});Object.freeze(this);}Object.freeze(Stack);exports["default"]=Stack;},{}],35:[function(require,module,exports){var __generator=this&&this.__generator||function(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),"throw":verb(1),"return":verb(2)},typeof Symbol==="function"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError("Generator is already executing.");while(_){try{if(f=1,y&&(t=op[0]&2?y["return"]:op[0]?y["throw"]||((t=y["return"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return {value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}}if(op[0]&5)throw op[1];return {value:op[0]?op[1]:void 0,done:true};}};var __read=this&&this.__read||function(o,n){var m=typeof Symbol==="function"&&o[Symbol.iterator];if(!m)return o;var i=m.call(o),r,ar=[],e;try{while((n===void 0||n-->0)&&!(r=i.next()).done){ar.push(r.value);}}catch(error){e={error:error};}finally{try{if(r&&!r.done&&(m=i["return"]))m.call(i);}finally{if(e)throw e.error;}}return ar;};var __spreadArray=this&&this.__spreadArray||function(to,from,pack){if(pack||arguments.length===2)for(var i=0,l=from.length,ar;i<l;i++){if(ar||!(i in from)){if(!ar)ar=Array.prototype.slice.call(from,0,i);ar[i]=from[i];}}return to.concat(ar||Array.prototype.slice.call(from));};var __values=this&&this.__values||function(o){var s=typeof Symbol==="function"&&Symbol.iterator,m=s&&o[s],i=0;if(m)return m.call(o);if(o&&typeof o.length==="number")return {next:function next(){if(o&&i>=o.length)o=void 0;return {value:o&&o[i++],done:!o};}};throw new TypeError(s?"Object is not iterable.":"Symbol.iterator is not defined.");};Object.defineProperty(exports,"__esModule",{value:true});function Vector(container){var _this=this;if(container===void 0){container=[];}var len=0;var vector=[];this.size=function(){return len;};this.empty=function(){return len===0;};this.clear=function(){len=0;vector.length=0;};this.front=function(){if(this.empty())return undefined;return vector[0];};this.back=function(){if(this.empty())return undefined;return vector[len-1];};this.forEach=function(callback){vector.forEach(callback);};this.getElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("pos must more than 0 and less than vector's size");return vector[pos];};this.eraseElementByPos=function(pos){if(pos<0||pos>=len)throw new Error("pos must more than 0 and less than vector's size");for(var i=pos;i<len-1;++i){vector[i]=vector[i+1];}this.popBack();};this.eraseElementByValue=function(value){var newArr=[];this.forEach(function(element){if(element!==value)newArr.push(element);});newArr.forEach(function(element,index){vector[index]=element;});var newLen=newArr.length;while(len>newLen){this.popBack();}};this.pushBack=function(element){vector.push(element);++len;};this.popBack=function(){vector.pop();if(len>0)--len;};this.setElementByPos=function(pos,element){if(pos<0||pos>=len)throw new Error("pos must more than 0 and less than vector's size");vector[pos]=element;};this.insert=function(pos,element,num){if(num===void 0){num=1;}if(pos<0||pos>len)throw new Error("pos must more than 0 and less than or equal to vector's size");vector.splice.apply(vector,__spreadArray([pos,0],__read(new Array(num).fill(element)),false));len+=num;};this.find=function(element){return vector.includes(element);};this.reverse=function(){vector.reverse();};this.unique=function(){var pre;var newArr=[];this.forEach(function(element,index){if(index===0||element!==pre){newArr.push(element);pre=element;}});newArr.forEach(function(element,index){vector[index]=element;});var newLen=newArr.length;while(len>newLen){this.popBack();}};this.sort=function(cmp){vector.sort(cmp);};this[Symbol.iterator]=function(){return function(){return __generator(this,function(_a){switch(_a.label){case 0:return [5/*yield**/,__values(vector)];case 1:return [2/*return*/,_a.sent()];}});}();};container.forEach(function(element){return _this.pushBack(element);});Object.freeze(this);}Object.freeze(Vector);exports["default"]=Vector;},{}],36:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:true});exports.HashMap=exports.HashSet=exports.Map=exports.Set=exports.PriorityQueue=exports.Deque=exports.LinkList=exports.Queue=exports.Stack=exports.Vector=void 0;var Vector_1=require("./Vector/Vector");exports.Vector=Vector_1["default"];var Stack_1=require("./Stack/Stack");exports.Stack=Stack_1["default"];var Queue_1=require("./Queue/Queue");exports.Queue=Queue_1["default"];var LinkList_1=require("./LinkList/LinkList");exports.LinkList=LinkList_1["default"];var Deque_1=require("./Deque/Deque");exports.Deque=Deque_1["default"];var PriorityQueue_1=require("./PriorityQueue/PriorityQueue");exports.PriorityQueue=PriorityQueue_1["default"];var Set_1=require("./Set/Set");exports.Set=Set_1["default"];var Map_1=require("./Map/Map");exports.Map=Map_1["default"];var HashSet_1=require("./HashSet/HashSet");exports.HashSet=HashSet_1["default"];var HashMap_1=require("./HashMap/HashMap");exports.HashMap=HashMap_1["default"];},{"./Deque/Deque":26,"./HashMap/HashMap":27,"./HashSet/HashSet":28,"./LinkList/LinkList":29,"./Map/Map":30,"./PriorityQueue/PriorityQueue":31,"./Queue/Queue":32,"./Set/Set":33,"./Stack/Stack":34,"./Vector/Vector":35}],37:[function(require,module,exports){var Yallist=require('yallist');var MAX=Symbol('max');var LENGTH=Symbol('length');var LENGTH_CALCULATOR=Symbol('lengthCalculator');var ALLOW_STALE=Symbol('allowStale');var MAX_AGE=Symbol('maxAge');var DISPOSE=Symbol('dispose');var NO_DISPOSE_ON_SET=Symbol('noDisposeOnSet');var LRU_LIST=Symbol('lruList');var CACHE=Symbol('cache');var UPDATE_AGE_ON_GET=Symbol('updateAgeOnGet');var naiveLength=function naiveLength(){return 1;};// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
var LRUCache=/*#__PURE__*/function(){function LRUCache(options){_classCallCheck(this,LRUCache);if(typeof options==='number')options={max:options};if(!options)options={};if(options.max&&(typeof options.max!=='number'||options.max<0))throw new TypeError('max must be a non-negative number');// Kind of weird to have a default max of Infinity, but oh well.
this[MAX]=options.max||Infinity;var lc=options.length||naiveLength;this[LENGTH_CALCULATOR]=typeof lc!=='function'?naiveLength:lc;this[ALLOW_STALE]=options.stale||false;if(options.maxAge&&typeof options.maxAge!=='number')throw new TypeError('maxAge must be a number');this[MAX_AGE]=options.maxAge||0;this[DISPOSE]=options.dispose;this[NO_DISPOSE_ON_SET]=options.noDisposeOnSet||false;this[UPDATE_AGE_ON_GET]=options.updateAgeOnGet||false;this.reset();}// resize the cache when the max changes.
_createClass(LRUCache,[{key:"max",get:function get(){return this[MAX];},set:function set(mL){if(typeof mL!=='number'||mL<0)throw new TypeError('max must be a non-negative number');this[MAX]=mL||Infinity;trim(this);}},{key:"allowStale",get:function get(){return this[ALLOW_STALE];},set:function set(allowStale){this[ALLOW_STALE]=!!allowStale;}},{key:"maxAge",get:function get(){return this[MAX_AGE];}// resize the cache when the lengthCalculator changes.
,set:function set(mA){if(typeof mA!=='number')throw new TypeError('maxAge must be a non-negative number');this[MAX_AGE]=mA;trim(this);}},{key:"lengthCalculator",get:function get(){return this[LENGTH_CALCULATOR];},set:function set(lC){var _this5=this;if(typeof lC!=='function')lC=naiveLength;if(lC!==this[LENGTH_CALCULATOR]){this[LENGTH_CALCULATOR]=lC;this[LENGTH]=0;this[LRU_LIST].forEach(function(hit){hit.length=_this5[LENGTH_CALCULATOR](hit.value,hit.key);_this5[LENGTH]+=hit.length;});}trim(this);}},{key:"length",get:function get(){return this[LENGTH];}},{key:"itemCount",get:function get(){return this[LRU_LIST].length;}},{key:"rforEach",value:function rforEach(fn,thisp){thisp=thisp||this;for(var walker=this[LRU_LIST].tail;walker!==null;){var prev=walker.prev;forEachStep(this,fn,walker,thisp);walker=prev;}}},{key:"forEach",value:function forEach(fn,thisp){thisp=thisp||this;for(var walker=this[LRU_LIST].head;walker!==null;){var next=walker.next;forEachStep(this,fn,walker,thisp);walker=next;}}},{key:"keys",value:function keys(){return this[LRU_LIST].toArray().map(function(k){return k.key;});}},{key:"values",value:function values(){return this[LRU_LIST].toArray().map(function(k){return k.value;});}},{key:"reset",value:function reset(){var _this6=this;if(this[DISPOSE]&&this[LRU_LIST]&&this[LRU_LIST].length){this[LRU_LIST].forEach(function(hit){return _this6[DISPOSE](hit.key,hit.value);});}this[CACHE]=new Map();// hash of items by key
this[LRU_LIST]=new Yallist();// list of items in order of use recency
this[LENGTH]=0;// length of items in the list
}},{key:"dump",value:function dump(){var _this7=this;return this[LRU_LIST].map(function(hit){return isStale(_this7,hit)?false:{k:hit.key,v:hit.value,e:hit.now+(hit.maxAge||0)};}).toArray().filter(function(h){return h;});}},{key:"dumpLru",value:function dumpLru(){return this[LRU_LIST];}},{key:"set",value:function set(key,value,maxAge){maxAge=maxAge||this[MAX_AGE];if(maxAge&&typeof maxAge!=='number')throw new TypeError('maxAge must be a number');var now=maxAge?Date.now():0;var len=this[LENGTH_CALCULATOR](value,key);if(this[CACHE].has(key)){if(len>this[MAX]){_del(this,this[CACHE].get(key));return false;}var node=this[CACHE].get(key);var item=node.value;// dispose of the old one before overwriting
// split out into 2 ifs for better coverage tracking
if(this[DISPOSE]){if(!this[NO_DISPOSE_ON_SET])this[DISPOSE](key,item.value);}item.now=now;item.maxAge=maxAge;item.value=value;this[LENGTH]+=len-item.length;item.length=len;this.get(key);trim(this);return true;}var hit=new Entry(key,value,len,now,maxAge);// oversized objects fall out of cache automatically.
if(hit.length>this[MAX]){if(this[DISPOSE])this[DISPOSE](key,value);return false;}this[LENGTH]+=hit.length;this[LRU_LIST].unshift(hit);this[CACHE].set(key,this[LRU_LIST].head);trim(this);return true;}},{key:"has",value:function has(key){if(!this[CACHE].has(key))return false;var hit=this[CACHE].get(key).value;return !isStale(this,hit);}},{key:"get",value:function get(key){return _get(this,key,true);}},{key:"peek",value:function peek(key){return _get(this,key,false);}},{key:"pop",value:function pop(){var node=this[LRU_LIST].tail;if(!node)return null;_del(this,node);return node.value;}},{key:"del",value:function del(key){_del(this,this[CACHE].get(key));}},{key:"load",value:function load(arr){// reset the cache
this.reset();var now=Date.now();// A previous serialized cache has the most recent items first
for(var l=arr.length-1;l>=0;l--){var hit=arr[l];var expiresAt=hit.e||0;if(expiresAt===0)// the item was created without expiration in a non aged cache
this.set(hit.k,hit.v);else {var maxAge=expiresAt-now;// dont add already expired items
if(maxAge>0){this.set(hit.k,hit.v,maxAge);}}}}},{key:"prune",value:function prune(){var _this8=this;this[CACHE].forEach(function(value,key){return _get(_this8,key,false);});}}]);return LRUCache;}();var _get=function _get(self,key,doUse){var node=self[CACHE].get(key);if(node){var hit=node.value;if(isStale(self,hit)){_del(self,node);if(!self[ALLOW_STALE])return undefined;}else {if(doUse){if(self[UPDATE_AGE_ON_GET])node.value.now=Date.now();self[LRU_LIST].unshiftNode(node);}}return hit.value;}};var isStale=function isStale(self,hit){if(!hit||!hit.maxAge&&!self[MAX_AGE])return false;var diff=Date.now()-hit.now;return hit.maxAge?diff>hit.maxAge:self[MAX_AGE]&&diff>self[MAX_AGE];};var trim=function trim(self){if(self[LENGTH]>self[MAX]){for(var walker=self[LRU_LIST].tail;self[LENGTH]>self[MAX]&&walker!==null;){// We know that we're about to delete this one, and also
// what the next least recently used key will be, so just
// go ahead and set it now.
var prev=walker.prev;_del(self,walker);walker=prev;}}};var _del=function _del(self,node){if(node){var hit=node.value;if(self[DISPOSE])self[DISPOSE](hit.key,hit.value);self[LENGTH]-=hit.length;self[CACHE]["delete"](hit.key);self[LRU_LIST].removeNode(node);}};var Entry=/*#__PURE__*/_createClass(function Entry(key,value,length,now,maxAge){_classCallCheck(this,Entry);this.key=key;this.value=value;this.length=length;this.now=now;this.maxAge=maxAge||0;});var forEachStep=function forEachStep(self,fn,node,thisp){var hit=node.value;if(isStale(self,hit)){_del(self,node);if(!self[ALLOW_STALE])hit=undefined;}if(hit)fn.call(thisp,hit.value,hit.key,self);};module.exports=LRUCache;},{"yallist":83}],38:[function(require,module,exports){(function(Buffer){(function(){/* Protocol - protocol constants */var protocol=module.exports;/* Command code => mnemonic */protocol.types={0:'reserved',1:'connect',2:'connack',3:'publish',4:'puback',5:'pubrec',6:'pubrel',7:'pubcomp',8:'subscribe',9:'suback',10:'unsubscribe',11:'unsuback',12:'pingreq',13:'pingresp',14:'disconnect',15:'auth'};/* Mnemonic => Command code */protocol.codes={};for(var k in protocol.types){var v=protocol.types[k];protocol.codes[v]=k;}/* Header */protocol.CMD_SHIFT=4;protocol.CMD_MASK=0xF0;protocol.DUP_MASK=0x08;protocol.QOS_MASK=0x03;protocol.QOS_SHIFT=1;protocol.RETAIN_MASK=0x01;/* Length */protocol.VARBYTEINT_MASK=0x7F;protocol.VARBYTEINT_FIN_MASK=0x80;protocol.VARBYTEINT_MAX=268435455;/* Connack */protocol.SESSIONPRESENT_MASK=0x01;protocol.SESSIONPRESENT_HEADER=Buffer.from([protocol.SESSIONPRESENT_MASK]);protocol.CONNACK_HEADER=Buffer.from([protocol.codes.connack<<protocol.CMD_SHIFT]);/* Connect */protocol.USERNAME_MASK=0x80;protocol.PASSWORD_MASK=0x40;protocol.WILL_RETAIN_MASK=0x20;protocol.WILL_QOS_MASK=0x18;protocol.WILL_QOS_SHIFT=3;protocol.WILL_FLAG_MASK=0x04;protocol.CLEAN_SESSION_MASK=0x02;protocol.CONNECT_HEADER=Buffer.from([protocol.codes.connect<<protocol.CMD_SHIFT]);/* Properties */protocol.properties={sessionExpiryInterval:17,willDelayInterval:24,receiveMaximum:33,maximumPacketSize:39,topicAliasMaximum:34,requestResponseInformation:25,requestProblemInformation:23,userProperties:38,authenticationMethod:21,authenticationData:22,payloadFormatIndicator:1,messageExpiryInterval:2,contentType:3,responseTopic:8,correlationData:9,maximumQoS:36,retainAvailable:37,assignedClientIdentifier:18,reasonString:31,wildcardSubscriptionAvailable:40,subscriptionIdentifiersAvailable:41,sharedSubscriptionAvailable:42,serverKeepAlive:19,responseInformation:26,serverReference:28,topicAlias:35,subscriptionIdentifier:11};protocol.propertiesCodes={};for(var prop in protocol.properties){var id=protocol.properties[prop];protocol.propertiesCodes[id]=prop;}protocol.propertiesTypes={sessionExpiryInterval:'int32',willDelayInterval:'int32',receiveMaximum:'int16',maximumPacketSize:'int32',topicAliasMaximum:'int16',requestResponseInformation:'byte',requestProblemInformation:'byte',userProperties:'pair',authenticationMethod:'string',authenticationData:'binary',payloadFormatIndicator:'byte',messageExpiryInterval:'int32',contentType:'string',responseTopic:'string',correlationData:'binary',maximumQoS:'int8',retainAvailable:'byte',assignedClientIdentifier:'string',reasonString:'string',wildcardSubscriptionAvailable:'byte',subscriptionIdentifiersAvailable:'byte',sharedSubscriptionAvailable:'byte',serverKeepAlive:'int16',responseInformation:'string',serverReference:'string',topicAlias:'int16',subscriptionIdentifier:'var'};function genHeader(type){return [0,1,2].map(function(qos){return [0,1].map(function(dup){return [0,1].map(function(retain){var buf=Buffer.alloc(1);buf.writeUInt8(protocol.codes[type]<<protocol.CMD_SHIFT|(dup?protocol.DUP_MASK:0)|qos<<protocol.QOS_SHIFT|retain,0,true);return buf;});});});}/* Publish */protocol.PUBLISH_HEADER=genHeader('publish');/* Subscribe */protocol.SUBSCRIBE_HEADER=genHeader('subscribe');protocol.SUBSCRIBE_OPTIONS_QOS_MASK=0x03;protocol.SUBSCRIBE_OPTIONS_NL_MASK=0x01;protocol.SUBSCRIBE_OPTIONS_NL_SHIFT=2;protocol.SUBSCRIBE_OPTIONS_RAP_MASK=0x01;protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT=3;protocol.SUBSCRIBE_OPTIONS_RH_MASK=0x03;protocol.SUBSCRIBE_OPTIONS_RH_SHIFT=4;protocol.SUBSCRIBE_OPTIONS_RH=[0x00,0x10,0x20];protocol.SUBSCRIBE_OPTIONS_NL=0x04;protocol.SUBSCRIBE_OPTIONS_RAP=0x08;protocol.SUBSCRIBE_OPTIONS_QOS=[0x00,0x01,0x02];/* Unsubscribe */protocol.UNSUBSCRIBE_HEADER=genHeader('unsubscribe');/* Confirmations */protocol.ACKS={unsuback:genHeader('unsuback'),puback:genHeader('puback'),pubcomp:genHeader('pubcomp'),pubrel:genHeader('pubrel'),pubrec:genHeader('pubrec')};protocol.SUBACK_HEADER=Buffer.from([protocol.codes.suback<<protocol.CMD_SHIFT]);/* Protocol versions */protocol.VERSION3=Buffer.from([3]);protocol.VERSION4=Buffer.from([4]);protocol.VERSION5=Buffer.from([5]);protocol.VERSION131=Buffer.from([131]);protocol.VERSION132=Buffer.from([132]);/* QoS */protocol.QOS=[0,1,2].map(function(qos){return Buffer.from([qos]);});/* Empty packets */protocol.EMPTY={pingreq:Buffer.from([protocol.codes.pingreq<<4,0]),pingresp:Buffer.from([protocol.codes.pingresp<<4,0]),disconnect:Buffer.from([protocol.codes.disconnect<<4,0])};}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":17}],39:[function(require,module,exports){(function(Buffer){(function(){var writeToStream=require('./writeToStream');var EventEmitter=require('events');function generate(packet,opts){var stream=new Accumulator();writeToStream(packet,stream,opts);return stream.concat();}var Accumulator=/*#__PURE__*/function(_EventEmitter){_inherits(Accumulator,_EventEmitter);var _super=_createSuper(Accumulator);function Accumulator(){var _this9;_classCallCheck(this,Accumulator);_this9=_super.call(this);_this9._array=new Array(20);_this9._i=0;return _this9;}_createClass(Accumulator,[{key:"write",value:function write(chunk){this._array[this._i++]=chunk;return true;}},{key:"concat",value:function concat(){var length=0;var lengths=new Array(this._array.length);var list=this._array;var pos=0;var i;for(i=0;i<list.length&&list[i]!==undefined;i++){if(typeof list[i]!=='string')lengths[i]=list[i].length;else lengths[i]=Buffer.byteLength(list[i]);length+=lengths[i];}var result=Buffer.allocUnsafe(length);for(i=0;i<list.length&&list[i]!==undefined;i++){if(typeof list[i]!=='string'){list[i].copy(result,pos);pos+=lengths[i];}else {result.write(list[i],pos);pos+=lengths[i];}}return result;}}]);return Accumulator;}(EventEmitter);module.exports=generate;}).call(this);}).call(this,require("buffer").Buffer);},{"./writeToStream":44,"buffer":17,"events":22}],40:[function(require,module,exports){exports.parser=require('./parser').parser;exports.generate=require('./generate');exports.writeToStream=require('./writeToStream');},{"./generate":39,"./parser":43,"./writeToStream":44}],41:[function(require,module,exports){(function(Buffer){(function(){var max=65536;var cache={};// in node 6 Buffer.subarray returns a Uint8Array instead of a Buffer
// later versions return a Buffer
// alternative is Buffer.slice but that creates a new buffer
// creating new buffers takes time
// SubOk is only false on node < 8
var SubOk=Buffer.isBuffer(Buffer.from([1,2]).subarray(0,1));function generateBuffer(i){var buffer=Buffer.allocUnsafe(2);buffer.writeUInt8(i>>8,0);buffer.writeUInt8(i&0x00FF,0+1);return buffer;}function generateCache(){for(var i=0;i<max;i++){cache[i]=generateBuffer(i);}}function genBufVariableByteInt(num){var maxLength=4;// max 4 bytes
var digit=0;var pos=0;var buffer=Buffer.allocUnsafe(maxLength);do{digit=num%128|0;num=num/128|0;if(num>0)digit=digit|0x80;buffer.writeUInt8(digit,pos++);}while(num>0&&pos<maxLength);if(num>0){pos=0;}return SubOk?buffer.subarray(0,pos):buffer.slice(0,pos);}function generate4ByteBuffer(num){var buffer=Buffer.allocUnsafe(4);buffer.writeUInt32BE(num,0);return buffer;}module.exports={cache:cache,generateCache:generateCache,generateNumber:generateBuffer,genBufVariableByteInt:genBufVariableByteInt,generate4ByteBuffer:generate4ByteBuffer};}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":17}],42:[function(require,module,exports){var Packet=/*#__PURE__*/_createClass(function Packet(){_classCallCheck(this,Packet);this.cmd=null;this.retain=false;this.qos=0;this.dup=false;this.length=-1;this.topic=null;this.payload=null;});module.exports=Packet;},{}],43:[function(require,module,exports){var bl=require('bl');var EventEmitter=require('events');var Packet=require('./packet');var constants=require('./constants');var debug=require('debug')('mqtt-packet:parser');var Parser=/*#__PURE__*/function(_EventEmitter2){_inherits(Parser,_EventEmitter2);var _super2=_createSuper(Parser);function Parser(){var _this10;_classCallCheck(this,Parser);_this10=_super2.call(this);_this10.parser=_this10.constructor.parser;return _this10;}_createClass(Parser,[{key:"_resetState",value:function _resetState(){debug('_resetState: resetting packet, error, _list, and _stateCounter');this.packet=new Packet();this.error=null;this._list=bl();this._stateCounter=0;}},{key:"parse",value:function parse(buf){if(this.error)this._resetState();this._list.append(buf);debug('parse: current state: %s',this._states[this._stateCounter]);while((this.packet.length!==-1||this._list.length>0)&&this[this._states[this._stateCounter]]()&&!this.error){this._stateCounter++;debug('parse: state complete. _stateCounter is now: %d',this._stateCounter);debug('parse: packet.length: %d, buffer list length: %d',this.packet.length,this._list.length);if(this._stateCounter>=this._states.length)this._stateCounter=0;}debug('parse: exited while loop. packet: %d, buffer list length: %d',this.packet.length,this._list.length);return this._list.length;}},{key:"_parseHeader",value:function _parseHeader(){// There is at least one byte in the buffer
var zero=this._list.readUInt8(0);this.packet.cmd=constants.types[zero>>constants.CMD_SHIFT];this.packet.retain=(zero&constants.RETAIN_MASK)!==0;this.packet.qos=zero>>constants.QOS_SHIFT&constants.QOS_MASK;this.packet.dup=(zero&constants.DUP_MASK)!==0;debug('_parseHeader: packet: %o',this.packet);this._list.consume(1);return true;}},{key:"_parseLength",value:function _parseLength(){// There is at least one byte in the list
var result=this._parseVarByteNum(true);if(result){this.packet.length=result.value;this._list.consume(result.bytes);}debug('_parseLength %d',result.value);return !!result;}},{key:"_parsePayload",value:function _parsePayload(){debug('_parsePayload: payload %O',this._list);var result=false;// Do we have a payload? Do we have enough data to complete the payload?
// PINGs have no payload
if(this.packet.length===0||this._list.length>=this.packet.length){this._pos=0;switch(this.packet.cmd){case'connect':this._parseConnect();break;case'connack':this._parseConnack();break;case'publish':this._parsePublish();break;case'puback':case'pubrec':case'pubrel':case'pubcomp':this._parseConfirmation();break;case'subscribe':this._parseSubscribe();break;case'suback':this._parseSuback();break;case'unsubscribe':this._parseUnsubscribe();break;case'unsuback':this._parseUnsuback();break;case'pingreq':case'pingresp':// These are empty, nothing to do
break;case'disconnect':this._parseDisconnect();break;case'auth':this._parseAuth();break;default:this._emitError(new Error('Not supported'));}result=true;}debug('_parsePayload complete result: %s',result);return result;}},{key:"_parseConnect",value:function _parseConnect(){debug('_parseConnect');var topic;// Will topic
var payload;// Will payload
var password;// Password
var username;// Username
var flags={};var packet=this.packet;// Parse protocolId
var protocolId=this._parseString();if(protocolId===null)return this._emitError(new Error('Cannot parse protocolId'));if(protocolId!=='MQTT'&&protocolId!=='MQIsdp'){return this._emitError(new Error('Invalid protocolId'));}packet.protocolId=protocolId;// Parse constants version number
if(this._pos>=this._list.length)return this._emitError(new Error('Packet too short'));packet.protocolVersion=this._list.readUInt8(this._pos);if(packet.protocolVersion>=128){packet.bridgeMode=true;packet.protocolVersion=packet.protocolVersion-128;}if(packet.protocolVersion!==3&&packet.protocolVersion!==4&&packet.protocolVersion!==5){return this._emitError(new Error('Invalid protocol version'));}this._pos++;if(this._pos>=this._list.length){return this._emitError(new Error('Packet too short'));}// Parse connect flags
flags.username=this._list.readUInt8(this._pos)&constants.USERNAME_MASK;flags.password=this._list.readUInt8(this._pos)&constants.PASSWORD_MASK;flags.will=this._list.readUInt8(this._pos)&constants.WILL_FLAG_MASK;if(flags.will){packet.will={};packet.will.retain=(this._list.readUInt8(this._pos)&constants.WILL_RETAIN_MASK)!==0;packet.will.qos=(this._list.readUInt8(this._pos)&constants.WILL_QOS_MASK)>>constants.WILL_QOS_SHIFT;}packet.clean=(this._list.readUInt8(this._pos)&constants.CLEAN_SESSION_MASK)!==0;this._pos++;// Parse keepalive
packet.keepalive=this._parseNum();if(packet.keepalive===-1)return this._emitError(new Error('Packet too short'));// parse properties
if(packet.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}// Parse clientId
var clientId=this._parseString();if(clientId===null)return this._emitError(new Error('Packet too short'));packet.clientId=clientId;debug('_parseConnect: packet.clientId: %s',packet.clientId);if(flags.will){if(packet.protocolVersion===5){var willProperties=this._parseProperties();if(Object.getOwnPropertyNames(willProperties).length){packet.will.properties=willProperties;}}// Parse will topic
topic=this._parseString();if(topic===null)return this._emitError(new Error('Cannot parse will topic'));packet.will.topic=topic;debug('_parseConnect: packet.will.topic: %s',packet.will.topic);// Parse will payload
payload=this._parseBuffer();if(payload===null)return this._emitError(new Error('Cannot parse will payload'));packet.will.payload=payload;debug('_parseConnect: packet.will.paylaod: %s',packet.will.payload);}// Parse username
if(flags.username){username=this._parseString();if(username===null)return this._emitError(new Error('Cannot parse username'));packet.username=username;debug('_parseConnect: packet.username: %s',packet.username);}// Parse password
if(flags.password){password=this._parseBuffer();if(password===null)return this._emitError(new Error('Cannot parse password'));packet.password=password;}// need for right parse auth packet and self set up
this.settings=packet;debug('_parseConnect: complete');return packet;}},{key:"_parseConnack",value:function _parseConnack(){debug('_parseConnack');var packet=this.packet;if(this._list.length<1)return null;packet.sessionPresent=!!(this._list.readUInt8(this._pos++)&constants.SESSIONPRESENT_MASK);if(this.settings.protocolVersion===5){if(this._list.length>=2){packet.reasonCode=this._list.readUInt8(this._pos++);}else {packet.reasonCode=0;}}else {if(this._list.length<2)return null;packet.returnCode=this._list.readUInt8(this._pos++);}if(packet.returnCode===-1||packet.reasonCode===-1)return this._emitError(new Error('Cannot parse return code'));// mqtt 5 properties
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}debug('_parseConnack: complete');}},{key:"_parsePublish",value:function _parsePublish(){debug('_parsePublish');var packet=this.packet;packet.topic=this._parseString();if(packet.topic===null)return this._emitError(new Error('Cannot parse topic'));// Parse messageId
if(packet.qos>0)if(!this._parseMessageId()){return;}// Properties mqtt 5
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}packet.payload=this._list.slice(this._pos,packet.length);debug('_parsePublish: payload from buffer list: %o',packet.payload);}},{key:"_parseSubscribe",value:function _parseSubscribe(){debug('_parseSubscribe');var packet=this.packet;var topic;var options;var qos;var rh;var rap;var nl;var subscription;if(packet.qos!==1){return this._emitError(new Error('Wrong subscribe header'));}packet.subscriptions=[];if(!this._parseMessageId()){return;}// Properties mqtt 5
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}while(this._pos<packet.length){// Parse topic
topic=this._parseString();if(topic===null)return this._emitError(new Error('Cannot parse topic'));if(this._pos>=packet.length)return this._emitError(new Error('Malformed Subscribe Payload'));options=this._parseByte();qos=options&constants.SUBSCRIBE_OPTIONS_QOS_MASK;nl=(options>>constants.SUBSCRIBE_OPTIONS_NL_SHIFT&constants.SUBSCRIBE_OPTIONS_NL_MASK)!==0;rap=(options>>constants.SUBSCRIBE_OPTIONS_RAP_SHIFT&constants.SUBSCRIBE_OPTIONS_RAP_MASK)!==0;rh=options>>constants.SUBSCRIBE_OPTIONS_RH_SHIFT&constants.SUBSCRIBE_OPTIONS_RH_MASK;subscription={topic:topic,qos:qos};// mqtt 5 options
if(this.settings.protocolVersion===5){subscription.nl=nl;subscription.rap=rap;subscription.rh=rh;}else if(this.settings.bridgeMode){subscription.rh=0;subscription.rap=true;subscription.nl=true;}// Push pair to subscriptions
debug('_parseSubscribe: push subscription `%s` to subscription',subscription);packet.subscriptions.push(subscription);}}},{key:"_parseSuback",value:function _parseSuback(){debug('_parseSuback');var packet=this.packet;this.packet.granted=[];if(!this._parseMessageId()){return;}// Properties mqtt 5
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}// Parse granted QoSes
while(this._pos<this.packet.length){this.packet.granted.push(this._list.readUInt8(this._pos++));}}},{key:"_parseUnsubscribe",value:function _parseUnsubscribe(){debug('_parseUnsubscribe');var packet=this.packet;packet.unsubscriptions=[];// Parse messageId
if(!this._parseMessageId()){return;}// Properties mqtt 5
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}while(this._pos<packet.length){// Parse topic
var topic=this._parseString();if(topic===null)return this._emitError(new Error('Cannot parse topic'));// Push topic to unsubscriptions
debug('_parseUnsubscribe: push topic `%s` to unsubscriptions',topic);packet.unsubscriptions.push(topic);}}},{key:"_parseUnsuback",value:function _parseUnsuback(){debug('_parseUnsuback');var packet=this.packet;if(!this._parseMessageId())return this._emitError(new Error('Cannot parse messageId'));// Properties mqtt 5
if(this.settings.protocolVersion===5){var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}// Parse granted QoSes
packet.granted=[];while(this._pos<this.packet.length){this.packet.granted.push(this._list.readUInt8(this._pos++));}}}// parse packets like puback, pubrec, pubrel, pubcomp
},{key:"_parseConfirmation",value:function _parseConfirmation(){debug('_parseConfirmation: packet.cmd: `%s`',this.packet.cmd);var packet=this.packet;this._parseMessageId();if(this.settings.protocolVersion===5){if(packet.length>2){// response code
packet.reasonCode=this._parseByte();debug('_parseConfirmation: packet.reasonCode `%d`',packet.reasonCode);}else {packet.reasonCode=0;}if(packet.length>3){// properies mqtt 5
var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}}return true;}// parse disconnect packet
},{key:"_parseDisconnect",value:function _parseDisconnect(){var packet=this.packet;debug('_parseDisconnect');if(this.settings.protocolVersion===5){// response code
if(this._list.length>0){packet.reasonCode=this._parseByte();}else {packet.reasonCode=0;}// properies mqtt 5
var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}}debug('_parseDisconnect result: true');return true;}// parse auth packet
},{key:"_parseAuth",value:function _parseAuth(){debug('_parseAuth');var packet=this.packet;if(this.settings.protocolVersion!==5){return this._emitError(new Error('Not supported auth packet for this version MQTT'));}// response code
packet.reasonCode=this._parseByte();// properies mqtt 5
var properties=this._parseProperties();if(Object.getOwnPropertyNames(properties).length){packet.properties=properties;}debug('_parseAuth: result: true');return true;}},{key:"_parseMessageId",value:function _parseMessageId(){var packet=this.packet;packet.messageId=this._parseNum();if(packet.messageId===null){this._emitError(new Error('Cannot parse messageId'));return false;}debug('_parseMessageId: packet.messageId %d',packet.messageId);return true;}},{key:"_parseString",value:function _parseString(maybeBuffer){var length=this._parseNum();var end=length+this._pos;if(length===-1||end>this._list.length||end>this.packet.length)return null;var result=this._list.toString('utf8',this._pos,end);this._pos+=length;debug('_parseString: result: %s',result);return result;}},{key:"_parseStringPair",value:function _parseStringPair(){debug('_parseStringPair');return {name:this._parseString(),value:this._parseString()};}},{key:"_parseBuffer",value:function _parseBuffer(){var length=this._parseNum();var end=length+this._pos;if(length===-1||end>this._list.length||end>this.packet.length)return null;var result=this._list.slice(this._pos,end);this._pos+=length;debug('_parseBuffer: result: %o',result);return result;}},{key:"_parseNum",value:function _parseNum(){if(this._list.length-this._pos<2)return -1;var result=this._list.readUInt16BE(this._pos);this._pos+=2;debug('_parseNum: result: %s',result);return result;}},{key:"_parse4ByteNum",value:function _parse4ByteNum(){if(this._list.length-this._pos<4)return -1;var result=this._list.readUInt32BE(this._pos);this._pos+=4;debug('_parse4ByteNum: result: %s',result);return result;}},{key:"_parseVarByteNum",value:function _parseVarByteNum(fullInfoFlag){debug('_parseVarByteNum');var maxBytes=4;var bytes=0;var mul=1;var value=0;var result=false;var current;var padding=this._pos?this._pos:0;while(bytes<maxBytes&&padding+bytes<this._list.length){current=this._list.readUInt8(padding+bytes++);value+=mul*(current&constants.VARBYTEINT_MASK);mul*=0x80;if((current&constants.VARBYTEINT_FIN_MASK)===0){result=true;break;}if(this._list.length<=bytes){break;}}if(!result&&bytes===maxBytes&&this._list.length>=bytes){this._emitError(new Error('Invalid variable byte integer'));}if(padding){this._pos+=bytes;}result=result?fullInfoFlag?{bytes:bytes,value:value}:value:false;debug('_parseVarByteNum: result: %o',result);return result;}},{key:"_parseByte",value:function _parseByte(){var result;if(this._pos<this._list.length){result=this._list.readUInt8(this._pos);this._pos++;}debug('_parseByte: result: %o',result);return result;}},{key:"_parseByType",value:function _parseByType(type){debug('_parseByType: type: %s',type);switch(type){case'byte':{return this._parseByte()!==0;}case'int8':{return this._parseByte();}case'int16':{return this._parseNum();}case'int32':{return this._parse4ByteNum();}case'var':{return this._parseVarByteNum();}case'string':{return this._parseString();}case'pair':{return this._parseStringPair();}case'binary':{return this._parseBuffer();}}}},{key:"_parseProperties",value:function _parseProperties(){debug('_parseProperties');var length=this._parseVarByteNum();var start=this._pos;var end=start+length;var result={};while(this._pos<end){var type=this._parseByte();if(!type){this._emitError(new Error('Cannot parse property code type'));return false;}var name=constants.propertiesCodes[type];if(!name){this._emitError(new Error('Unknown property'));return false;}// user properties process
if(name==='userProperties'){if(!result[name]){result[name]=Object.create(null);}var currentUserProperty=this._parseByType(constants.propertiesTypes[name]);if(result[name][currentUserProperty.name]){if(Array.isArray(result[name][currentUserProperty.name])){result[name][currentUserProperty.name].push(currentUserProperty.value);}else {var currentValue=result[name][currentUserProperty.name];result[name][currentUserProperty.name]=[currentValue];result[name][currentUserProperty.name].push(currentUserProperty.value);}}else {result[name][currentUserProperty.name]=currentUserProperty.value;}continue;}if(result[name]){if(Array.isArray(result[name])){result[name].push(this._parseByType(constants.propertiesTypes[name]));}else {result[name]=[result[name]];result[name].push(this._parseByType(constants.propertiesTypes[name]));}}else {result[name]=this._parseByType(constants.propertiesTypes[name]);}}return result;}},{key:"_newPacket",value:function _newPacket(){debug('_newPacket');if(this.packet){this._list.consume(this.packet.length);debug('_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d',this.packet.cmd,this.packet.payload,this.packet.length);this.emit('packet',this.packet);}debug('_newPacket: new packet');this.packet=new Packet();this._pos=0;return true;}},{key:"_emitError",value:function _emitError(err){debug('_emitError');this.error=err;this.emit('error',err);}}],[{key:"parser",value:function parser(opt){if(!(this instanceof Parser))return new Parser().parser(opt);this.settings=opt||{};this._states=['_parseHeader','_parseLength','_parsePayload','_newPacket'];this._resetState();return this;}}]);return Parser;}(EventEmitter);module.exports=Parser;},{"./constants":38,"./packet":42,"bl":15,"debug":18,"events":22}],44:[function(require,module,exports){(function(Buffer){(function(){var protocol=require('./constants');var empty=Buffer.allocUnsafe(0);var zeroBuf=Buffer.from([0]);var numbers=require('./numbers');var nextTick=require('process-nextick-args').nextTick;var debug=require('debug')('mqtt-packet:writeToStream');var numCache=numbers.cache;var generateNumber=numbers.generateNumber;var generateCache=numbers.generateCache;var genBufVariableByteInt=numbers.genBufVariableByteInt;var generate4ByteBuffer=numbers.generate4ByteBuffer;var writeNumber=writeNumberCached;var toGenerate=true;function generate(packet,stream,opts){debug('generate called');if(stream.cork){stream.cork();nextTick(uncork,stream);}if(toGenerate){toGenerate=false;generateCache();}debug('generate: packet.cmd: %s',packet.cmd);switch(packet.cmd){case'connect':return connect(packet,stream);case'connack':return connack(packet,stream,opts);case'publish':return publish(packet,stream,opts);case'puback':case'pubrec':case'pubrel':case'pubcomp':return confirmation(packet,stream,opts);case'subscribe':return subscribe(packet,stream,opts);case'suback':return suback(packet,stream,opts);case'unsubscribe':return unsubscribe(packet,stream,opts);case'unsuback':return unsuback(packet,stream,opts);case'pingreq':case'pingresp':return emptyPacket(packet,stream);case'disconnect':return disconnect(packet,stream,opts);case'auth':return auth(packet,stream,opts);default:stream.emit('error',new Error('Unknown command'));return false;}}/**
	 * Controls numbers cache.
	 * Set to "false" to allocate buffers on-the-flight instead of pre-generated cache
	 */Object.defineProperty(generate,'cacheNumbers',{get:function get(){return writeNumber===writeNumberCached;},set:function set(value){if(value){if(!numCache||Object.keys(numCache).length===0)toGenerate=true;writeNumber=writeNumberCached;}else {toGenerate=false;writeNumber=writeNumberGenerated;}}});function uncork(stream){stream.uncork();}function connect(packet,stream,opts){var settings=packet||{};var protocolId=settings.protocolId||'MQTT';var protocolVersion=settings.protocolVersion||4;var will=settings.will;var clean=settings.clean;var keepalive=settings.keepalive||0;var clientId=settings.clientId||'';var username=settings.username;var password=settings.password;/* mqtt5 new oprions */var properties=settings.properties;if(clean===undefined)clean=true;var length=0;// Must be a string and non-falsy
if(!protocolId||typeof protocolId!=='string'&&!Buffer.isBuffer(protocolId)){stream.emit('error',new Error('Invalid protocolId'));return false;}else length+=protocolId.length+2;// Must be 3 or 4 or 5
if(protocolVersion!==3&&protocolVersion!==4&&protocolVersion!==5){stream.emit('error',new Error('Invalid protocol version'));return false;}else length+=1;// ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1
if((typeof clientId==='string'||Buffer.isBuffer(clientId))&&(clientId||protocolVersion>=4)&&(clientId||clean)){length+=Buffer.byteLength(clientId)+2;}else {if(protocolVersion<4){stream.emit('error',new Error('clientId must be supplied before 3.1.1'));return false;}if(clean*1===0){stream.emit('error',new Error('clientId must be given if cleanSession set to 0'));return false;}}// Must be a two byte number
if(typeof keepalive!=='number'||keepalive<0||keepalive>65535||keepalive%1!==0){stream.emit('error',new Error('Invalid keepalive'));return false;}else length+=2;// Connect flags
length+=1;// Properties
if(protocolVersion===5){var propertiesData=getProperties(stream,properties);if(!propertiesData){return false;}length+=propertiesData.length;}// If will exists...
if(will){// It must be an object
if(_typeof(will)!=='object'){stream.emit('error',new Error('Invalid will'));return false;}// It must have topic typeof string
if(!will.topic||typeof will.topic!=='string'){stream.emit('error',new Error('Invalid will topic'));return false;}else {length+=Buffer.byteLength(will.topic)+2;}// Payload
length+=2;// payload length
if(will.payload){if(will.payload.length>=0){if(typeof will.payload==='string'){length+=Buffer.byteLength(will.payload);}else {length+=will.payload.length;}}else {stream.emit('error',new Error('Invalid will payload'));return false;}}// will properties
var willProperties={};if(protocolVersion===5){willProperties=getProperties(stream,will.properties);if(!willProperties){return false;}length+=willProperties.length;}}// Username
var providedUsername=false;if(username!=null){if(isStringOrBuffer(username)){providedUsername=true;length+=Buffer.byteLength(username)+2;}else {stream.emit('error',new Error('Invalid username'));return false;}}// Password
if(password!=null){if(!providedUsername){stream.emit('error',new Error('Username is required to use password'));return false;}if(isStringOrBuffer(password)){length+=byteLength(password)+2;}else {stream.emit('error',new Error('Invalid password'));return false;}}// Generate header
stream.write(protocol.CONNECT_HEADER);// Generate length
writeVarByteInt(stream,length);// Generate protocol ID
writeStringOrBuffer(stream,protocolId);if(settings.bridgeMode){protocolVersion+=128;}stream.write(protocolVersion===131?protocol.VERSION131:protocolVersion===132?protocol.VERSION132:protocolVersion===4?protocol.VERSION4:protocolVersion===5?protocol.VERSION5:protocol.VERSION3);// Connect flags
var flags=0;flags|=username!=null?protocol.USERNAME_MASK:0;flags|=password!=null?protocol.PASSWORD_MASK:0;flags|=will&&will.retain?protocol.WILL_RETAIN_MASK:0;flags|=will&&will.qos?will.qos<<protocol.WILL_QOS_SHIFT:0;flags|=will?protocol.WILL_FLAG_MASK:0;flags|=clean?protocol.CLEAN_SESSION_MASK:0;stream.write(Buffer.from([flags]));// Keepalive
writeNumber(stream,keepalive);// Properties
if(protocolVersion===5){propertiesData.write();}// Client ID
writeStringOrBuffer(stream,clientId);// Will
if(will){if(protocolVersion===5){willProperties.write();}writeString(stream,will.topic);writeStringOrBuffer(stream,will.payload);}// Username and password
if(username!=null){writeStringOrBuffer(stream,username);}if(password!=null){writeStringOrBuffer(stream,password);}// This is a small packet that happens only once on a stream
// We assume the stream is always free to receive more data after this
return true;}function connack(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var rc=version===5?settings.reasonCode:settings.returnCode;var properties=settings.properties;var length=2;// length of rc and sessionHeader
// Check return code
if(typeof rc!=='number'){stream.emit('error',new Error('Invalid return code'));return false;}// mqtt5 properties
var propertiesData=null;if(version===5){propertiesData=getProperties(stream,properties);if(!propertiesData){return false;}length+=propertiesData.length;}stream.write(protocol.CONNACK_HEADER);// length
writeVarByteInt(stream,length);stream.write(settings.sessionPresent?protocol.SESSIONPRESENT_HEADER:zeroBuf);stream.write(Buffer.from([rc]));if(propertiesData!=null){propertiesData.write();}return true;}function publish(packet,stream,opts){debug('publish: packet: %o',packet);var version=opts?opts.protocolVersion:4;var settings=packet||{};var qos=settings.qos||0;var retain=settings.retain?protocol.RETAIN_MASK:0;var topic=settings.topic;var payload=settings.payload||empty;var id=settings.messageId;var properties=settings.properties;var length=0;// Topic must be a non-empty string or Buffer
if(typeof topic==='string')length+=Buffer.byteLength(topic)+2;else if(Buffer.isBuffer(topic))length+=topic.length+2;else {stream.emit('error',new Error('Invalid topic'));return false;}// Get the payload length
if(!Buffer.isBuffer(payload))length+=Buffer.byteLength(payload);else length+=payload.length;// Message ID must a number if qos > 0
if(qos&&typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}else if(qos)length+=2;// mqtt5 properties
var propertiesData=null;if(version===5){propertiesData=getProperties(stream,properties);if(!propertiesData){return false;}length+=propertiesData.length;}// Header
stream.write(protocol.PUBLISH_HEADER[qos][settings.dup?1:0][retain?1:0]);// Remaining length
writeVarByteInt(stream,length);// Topic
writeNumber(stream,byteLength(topic));stream.write(topic);// Message ID
if(qos>0)writeNumber(stream,id);// Properties
if(propertiesData!=null){propertiesData.write();}// Payload
debug('publish: payload: %o',payload);return stream.write(payload);}/* Puback, pubrec, pubrel and pubcomp */function confirmation(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var type=settings.cmd||'puback';var id=settings.messageId;var dup=settings.dup&&type==='pubrel'?protocol.DUP_MASK:0;var qos=0;var reasonCode=settings.reasonCode;var properties=settings.properties;var length=version===5?3:2;if(type==='pubrel')qos=1;// Check message ID
if(typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}// properies mqtt 5
var propertiesData=null;if(version===5){// Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)
if(_typeof(properties)==='object'){propertiesData=getPropertiesByMaximumPacketSize(stream,properties,opts,length);if(!propertiesData){return false;}length+=propertiesData.length;}}// Header
stream.write(protocol.ACKS[type][qos][dup][0]);// Length
writeVarByteInt(stream,length);// Message ID
writeNumber(stream,id);// reason code in header
if(version===5){stream.write(Buffer.from([reasonCode]));}// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}return true;}function subscribe(packet,stream,opts){debug('subscribe: packet: ');var version=opts?opts.protocolVersion:4;var settings=packet||{};var dup=settings.dup?protocol.DUP_MASK:0;var id=settings.messageId;var subs=settings.subscriptions;var properties=settings.properties;var length=0;// Check message ID
if(typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}else length+=2;// properies mqtt 5
var propertiesData=null;if(version===5){propertiesData=getProperties(stream,properties);if(!propertiesData){return false;}length+=propertiesData.length;}// Check subscriptions
if(_typeof(subs)==='object'&&subs.length){for(var i=0;i<subs.length;i+=1){var itopic=subs[i].topic;var iqos=subs[i].qos;if(typeof itopic!=='string'){stream.emit('error',new Error('Invalid subscriptions - invalid topic'));return false;}if(typeof iqos!=='number'){stream.emit('error',new Error('Invalid subscriptions - invalid qos'));return false;}if(version===5){var nl=subs[i].nl||false;if(typeof nl!=='boolean'){stream.emit('error',new Error('Invalid subscriptions - invalid No Local'));return false;}var rap=subs[i].rap||false;if(typeof rap!=='boolean'){stream.emit('error',new Error('Invalid subscriptions - invalid Retain as Published'));return false;}var rh=subs[i].rh||0;if(typeof rh!=='number'||rh>2){stream.emit('error',new Error('Invalid subscriptions - invalid Retain Handling'));return false;}}length+=Buffer.byteLength(itopic)+2+1;}}else {stream.emit('error',new Error('Invalid subscriptions'));return false;}// Generate header
debug('subscribe: writing to stream: %o',protocol.SUBSCRIBE_HEADER);stream.write(protocol.SUBSCRIBE_HEADER[1][dup?1:0][0]);// Generate length
writeVarByteInt(stream,length);// Generate message ID
writeNumber(stream,id);// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}var result=true;// Generate subs
var _iterator2=_createForOfIteratorHelper(subs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var sub=_step2.value;var jtopic=sub.topic;var jqos=sub.qos;var jnl=+sub.nl;var jrap=+sub.rap;var jrh=sub.rh;var joptions=void 0;// Write topic string
writeString(stream,jtopic);// options process
joptions=protocol.SUBSCRIBE_OPTIONS_QOS[jqos];if(version===5){joptions|=jnl?protocol.SUBSCRIBE_OPTIONS_NL:0;joptions|=jrap?protocol.SUBSCRIBE_OPTIONS_RAP:0;joptions|=jrh?protocol.SUBSCRIBE_OPTIONS_RH[jrh]:0;}// Write options
result=stream.write(Buffer.from([joptions]));}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return result;}function suback(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var id=settings.messageId;var granted=settings.granted;var properties=settings.properties;var length=0;// Check message ID
if(typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}else length+=2;// Check granted qos vector
if(_typeof(granted)==='object'&&granted.length){for(var i=0;i<granted.length;i+=1){if(typeof granted[i]!=='number'){stream.emit('error',new Error('Invalid qos vector'));return false;}length+=1;}}else {stream.emit('error',new Error('Invalid qos vector'));return false;}// properies mqtt 5
var propertiesData=null;if(version===5){propertiesData=getPropertiesByMaximumPacketSize(stream,properties,opts,length);if(!propertiesData){return false;}length+=propertiesData.length;}// header
stream.write(protocol.SUBACK_HEADER);// Length
writeVarByteInt(stream,length);// Message ID
writeNumber(stream,id);// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}return stream.write(Buffer.from(granted));}function unsubscribe(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var id=settings.messageId;var dup=settings.dup?protocol.DUP_MASK:0;var unsubs=settings.unsubscriptions;var properties=settings.properties;var length=0;// Check message ID
if(typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}else {length+=2;}// Check unsubs
if(_typeof(unsubs)==='object'&&unsubs.length){for(var i=0;i<unsubs.length;i+=1){if(typeof unsubs[i]!=='string'){stream.emit('error',new Error('Invalid unsubscriptions'));return false;}length+=Buffer.byteLength(unsubs[i])+2;}}else {stream.emit('error',new Error('Invalid unsubscriptions'));return false;}// properies mqtt 5
var propertiesData=null;if(version===5){propertiesData=getProperties(stream,properties);if(!propertiesData){return false;}length+=propertiesData.length;}// Header
stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup?1:0][0]);// Length
writeVarByteInt(stream,length);// Message ID
writeNumber(stream,id);// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}// Unsubs
var result=true;for(var j=0;j<unsubs.length;j++){result=writeString(stream,unsubs[j]);}return result;}function unsuback(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var id=settings.messageId;var dup=settings.dup?protocol.DUP_MASK:0;var granted=settings.granted;var properties=settings.properties;var type=settings.cmd;var qos=0;var length=2;// Check message ID
if(typeof id!=='number'){stream.emit('error',new Error('Invalid messageId'));return false;}// Check granted
if(version===5){if(_typeof(granted)==='object'&&granted.length){for(var i=0;i<granted.length;i+=1){if(typeof granted[i]!=='number'){stream.emit('error',new Error('Invalid qos vector'));return false;}length+=1;}}else {stream.emit('error',new Error('Invalid qos vector'));return false;}}// properies mqtt 5
var propertiesData=null;if(version===5){propertiesData=getPropertiesByMaximumPacketSize(stream,properties,opts,length);if(!propertiesData){return false;}length+=propertiesData.length;}// Header
stream.write(protocol.ACKS[type][qos][dup][0]);// Length
writeVarByteInt(stream,length);// Message ID
writeNumber(stream,id);// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}// payload
if(version===5){stream.write(Buffer.from(granted));}return true;}function emptyPacket(packet,stream,opts){return stream.write(protocol.EMPTY[packet.cmd]);}function disconnect(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var reasonCode=settings.reasonCode;var properties=settings.properties;var length=version===5?1:0;// properies mqtt 5
var propertiesData=null;if(version===5){propertiesData=getPropertiesByMaximumPacketSize(stream,properties,opts,length);if(!propertiesData){return false;}length+=propertiesData.length;}// Header
stream.write(Buffer.from([protocol.codes.disconnect<<4]));// Length
writeVarByteInt(stream,length);// reason code in header
if(version===5){stream.write(Buffer.from([reasonCode]));}// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}return true;}function auth(packet,stream,opts){var version=opts?opts.protocolVersion:4;var settings=packet||{};var reasonCode=settings.reasonCode;var properties=settings.properties;var length=version===5?1:0;if(version!==5)stream.emit('error',new Error('Invalid mqtt version for auth packet'));// properies mqtt 5
var propertiesData=getPropertiesByMaximumPacketSize(stream,properties,opts,length);if(!propertiesData){return false;}length+=propertiesData.length;// Header
stream.write(Buffer.from([protocol.codes.auth<<4]));// Length
writeVarByteInt(stream,length);// reason code in header
stream.write(Buffer.from([reasonCode]));// properies mqtt 5
if(propertiesData!==null){propertiesData.write();}return true;}/**
	 * writeVarByteInt - write an MQTT style variable byte integer to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <Number> length - length (>0)
	 * @returns <Number> number of bytes written
	 *
	 * @api private
	 */var varByteIntCache={};function writeVarByteInt(stream,num){if(num>protocol.VARBYTEINT_MAX){stream.emit('error',new Error("Invalid variable byte integer: ".concat(num)));return false;}var buffer=varByteIntCache[num];if(!buffer){buffer=genBufVariableByteInt(num);if(num<16384)varByteIntCache[num]=buffer;}debug('writeVarByteInt: writing to stream: %o',buffer);return stream.write(buffer);}/**
	 * writeString - write a utf8 string to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> string - string to write
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */function writeString(stream,string){var strlen=Buffer.byteLength(string);writeNumber(stream,strlen);debug('writeString: %s',string);return stream.write(string,'utf8');}/**
	 * writeStringPair - write a utf8 string pairs to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <String> name - string name to write
	 * @param <String> value - string value to write
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */function writeStringPair(stream,name,value){writeString(stream,name);writeString(stream,value);}/**
	 * writeNumber - write a two byte number to the buffer
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> number - number to write
	 * @return <Number> number of bytes written
	 *
	 * @api private
	 */function writeNumberCached(stream,number){debug('writeNumberCached: number: %d',number);debug('writeNumberCached: %o',numCache[number]);return stream.write(numCache[number]);}function writeNumberGenerated(stream,number){var generatedNumber=generateNumber(number);debug('writeNumberGenerated: %o',generatedNumber);return stream.write(generatedNumber);}function write4ByteNumber(stream,number){var generated4ByteBuffer=generate4ByteBuffer(number);debug('write4ByteNumber: %o',generated4ByteBuffer);return stream.write(generated4ByteBuffer);}/**
	 * writeStringOrBuffer - write a String or Buffer with the its length prefix
	 *
	 * @param <Buffer> buffer - destination
	 * @param <Number> pos - offset
	 * @param <String> toWrite - String or Buffer
	 * @return <Number> number of bytes written
	 */function writeStringOrBuffer(stream,toWrite){if(typeof toWrite==='string'){writeString(stream,toWrite);}else if(toWrite){writeNumber(stream,toWrite.length);stream.write(toWrite);}else writeNumber(stream,0);}function getProperties(stream,properties){/* connect properties */if(_typeof(properties)!=='object'||properties.length!=null){return {length:1,write:function write(){writeProperties(stream,{},0);}};}var propertiesLength=0;function getLengthProperty(name,value){var type=protocol.propertiesTypes[name];var length=0;switch(type){case'byte':{if(typeof value!=='boolean'){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+1;break;}case'int8':{if(typeof value!=='number'||value<0||value>0xff){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+1;break;}case'binary':{if(value&&value===null){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+Buffer.byteLength(value)+2;break;}case'int16':{if(typeof value!=='number'||value<0||value>0xffff){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+2;break;}case'int32':{if(typeof value!=='number'||value<0||value>0xffffffff){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+4;break;}case'var':{// var byte integer is max 24 bits packed in 32 bits
if(typeof value!=='number'||value<0||value>0x0fffffff){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+Buffer.byteLength(genBufVariableByteInt(value));break;}case'string':{if(typeof value!=='string'){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=1+2+Buffer.byteLength(value.toString());break;}case'pair':{if(_typeof(value)!=='object'){stream.emit('error',new Error("Invalid ".concat(name,": ").concat(value)));return false;}length+=Object.getOwnPropertyNames(value).reduce(function(result,name){var currentValue=value[name];if(Array.isArray(currentValue)){result+=currentValue.reduce(function(currentLength,value){currentLength+=1+2+Buffer.byteLength(name.toString())+2+Buffer.byteLength(value.toString());return currentLength;},0);}else {result+=1+2+Buffer.byteLength(name.toString())+2+Buffer.byteLength(value[name].toString());}return result;},0);break;}default:{stream.emit('error',new Error("Invalid property ".concat(name,": ").concat(value)));return false;}}return length;}if(properties){for(var propName in properties){var propLength=0;var propValueLength=0;var propValue=properties[propName];if(Array.isArray(propValue)){for(var valueIndex=0;valueIndex<propValue.length;valueIndex++){propValueLength=getLengthProperty(propName,propValue[valueIndex]);if(!propValueLength){return false;}propLength+=propValueLength;}}else {propValueLength=getLengthProperty(propName,propValue);if(!propValueLength){return false;}propLength=propValueLength;}if(!propLength)return false;propertiesLength+=propLength;}}var propertiesLengthLength=Buffer.byteLength(genBufVariableByteInt(propertiesLength));return {length:propertiesLengthLength+propertiesLength,write:function write(){writeProperties(stream,properties,propertiesLength);}};}function getPropertiesByMaximumPacketSize(stream,properties,opts,length){var mayEmptyProps=['reasonString','userProperties'];var maximumPacketSize=opts&&opts.properties&&opts.properties.maximumPacketSize?opts.properties.maximumPacketSize:0;var propertiesData=getProperties(stream,properties);if(maximumPacketSize){while(length+propertiesData.length>maximumPacketSize){var currentMayEmptyProp=mayEmptyProps.shift();if(currentMayEmptyProp&&properties[currentMayEmptyProp]){delete properties[currentMayEmptyProp];propertiesData=getProperties(stream,properties);}else {return false;}}}return propertiesData;}function writeProperty(stream,propName,value){var type=protocol.propertiesTypes[propName];switch(type){case'byte':{stream.write(Buffer.from([protocol.properties[propName]]));stream.write(Buffer.from([+value]));break;}case'int8':{stream.write(Buffer.from([protocol.properties[propName]]));stream.write(Buffer.from([value]));break;}case'binary':{stream.write(Buffer.from([protocol.properties[propName]]));writeStringOrBuffer(stream,value);break;}case'int16':{stream.write(Buffer.from([protocol.properties[propName]]));writeNumber(stream,value);break;}case'int32':{stream.write(Buffer.from([protocol.properties[propName]]));write4ByteNumber(stream,value);break;}case'var':{stream.write(Buffer.from([protocol.properties[propName]]));writeVarByteInt(stream,value);break;}case'string':{stream.write(Buffer.from([protocol.properties[propName]]));writeString(stream,value);break;}case'pair':{Object.getOwnPropertyNames(value).forEach(function(name){var currentValue=value[name];if(Array.isArray(currentValue)){currentValue.forEach(function(value){stream.write(Buffer.from([protocol.properties[propName]]));writeStringPair(stream,name.toString(),value.toString());});}else {stream.write(Buffer.from([protocol.properties[propName]]));writeStringPair(stream,name.toString(),currentValue.toString());}});break;}default:{stream.emit('error',new Error("Invalid property ".concat(propName," value: ").concat(value)));return false;}}}function writeProperties(stream,properties,propertiesLength){/* write properties to stream */writeVarByteInt(stream,propertiesLength);for(var propName in properties){if(Object.prototype.hasOwnProperty.call(properties,propName)&&properties[propName]!==null){var value=properties[propName];if(Array.isArray(value)){for(var valueIndex=0;valueIndex<value.length;valueIndex++){writeProperty(stream,propName,value[valueIndex]);}}else {writeProperty(stream,propName,value);}}}}function byteLength(bufOrString){if(!bufOrString)return 0;else if(bufOrString instanceof Buffer)return bufOrString.length;else return Buffer.byteLength(bufOrString);}function isStringOrBuffer(field){return typeof field==='string'||field instanceof Buffer;}module.exports=generate;}).call(this);}).call(this,require("buffer").Buffer);},{"./constants":38,"./numbers":41,"buffer":17,"debug":18,"process-nextick-args":49}],45:[function(require,module,exports){/**
	 * Helpers.
	 */var s=1000;var m=s*60;var h=m*60;var d=h*24;var w=d*7;var y=d*365.25;/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */module.exports=function(val,options){options=options||{};var type=_typeof(val);if(type==='string'&&val.length>0){return parse(val);}else if(type==='number'&&isFinite(val)){return options["long"]?fmtLong(val):fmtShort(val);}throw new Error('val is not a non-empty string or a valid number. val='+JSON.stringify(val));};/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */function parse(str){str=String(str);if(str.length>100){return;}var match=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);if(!match){return;}var n=parseFloat(match[1]);var type=(match[2]||'ms').toLowerCase();switch(type){case'years':case'year':case'yrs':case'yr':case'y':return n*y;case'weeks':case'week':case'w':return n*w;case'days':case'day':case'd':return n*d;case'hours':case'hour':case'hrs':case'hr':case'h':return n*h;case'minutes':case'minute':case'mins':case'min':case'm':return n*m;case'seconds':case'second':case'secs':case'sec':case's':return n*s;case'milliseconds':case'millisecond':case'msecs':case'msec':case'ms':return n;default:return undefined;}}/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */function fmtShort(ms){var msAbs=Math.abs(ms);if(msAbs>=d){return Math.round(ms/d)+'d';}if(msAbs>=h){return Math.round(ms/h)+'h';}if(msAbs>=m){return Math.round(ms/m)+'m';}if(msAbs>=s){return Math.round(ms/s)+'s';}return ms+'ms';}/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */function fmtLong(ms){var msAbs=Math.abs(ms);if(msAbs>=d){return plural(ms,msAbs,d,'day');}if(msAbs>=h){return plural(ms,msAbs,h,'hour');}if(msAbs>=m){return plural(ms,msAbs,m,'minute');}if(msAbs>=s){return plural(ms,msAbs,s,'second');}return ms+' ms';}/**
	 * Pluralization helper.
	 */function plural(ms,msAbs,n,name){var isPlural=msAbs>=n*1.5;return Math.round(ms/n)+' '+name+(isPlural?'s':'');}},{}],46:[function(require,module,exports){// Copyright Takatoshi Kondo 2021
//
// Distributed under the MIT License
var NumberAllocator=require('./lib/number-allocator.js');module.exports.NumberAllocator=NumberAllocator;},{"./lib/number-allocator.js":47}],47:[function(require,module,exports){// Copyright Takatoshi Kondo 2021
var SortedSet=require('js-sdsl').Set;var debugTrace=require('debug')('number-allocator:trace');var debugError=require('debug')('number-allocator:error');/**
	 * Interval constructor
	 * @constructor
	 * @param {Number} low  - The lowest value of the interval
	 * @param {Number} high - The highest value of the interval
	 */function Interval(low,high){this.low=low;this.high=high;}Interval.prototype.equals=function(other){return this.low===other.low&&this.high===other.high;};Interval.prototype.compare=function(other){if(this.low<other.low&&this.high<other.low)return -1;if(other.low<this.low&&other.high<this.low)return 1;return 0;};/**
	 * NumberAllocator constructor.
	 * The all numbers are set to vacant status.
	 * Time Complexity O(1)
	 * @constructor
	 * @param {Number} min  - The maximum number of allocatable. The number must be integer.
	 * @param {Number} maxh - The minimum number of allocatable. The number must be integer.
	 */function NumberAllocator(min,max){if(!(this instanceof NumberAllocator)){return new NumberAllocator(min,max);}this.min=min;this.max=max;this.ss=new SortedSet([],function(lhs,rhs){return lhs.compare(rhs);});debugTrace('Create');this.clear();}/**
	 * Get the first vacant number. The status of the number is not updated.
	 * Time Complexity O(1)
	 * @return {Number} - The first vacant number. If all numbers are occupied, return null.
	 *                    When alloc() is called then the same value will be allocated.
	 */NumberAllocator.prototype.firstVacant=function(){if(this.ss.size()===0)return null;return this.ss.front().low;};/**
	 * Allocate the first vacant number. The number become occupied status.
	 * Time Complexity O(1)
	 * @return {Number} - The first vacant number. If all numbers are occupied, return null.
	 */NumberAllocator.prototype.alloc=function(){if(this.ss.size()===0){debugTrace('alloc():empty');return null;}var it=this.ss.front();var num=it.low;if(num+1<=it.high){// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
// x|----|
++it.low;}else {this.ss.eraseElementByPos(0);}debugTrace('alloc():'+num);return num;};/**
	 * Use the number. The number become occupied status.
	 * If the number has already been occupied, then return false.
	 * Time Complexity O(logN) : N is the number of intervals (not numbers)
	 * @param {Number} num - The number to request use.
	 * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.
	 */NumberAllocator.prototype.use=function(num){var key=new Interval(num,num);var it=this.ss.lowerBound(key);if(it){if(it.equals(key)){// |x|
this.ss.eraseElementByValue(it);debugTrace('use():'+num);return true;}// x |-----|
if(it.low>num)return false;// |x----|
if(it.low===num){// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
// x|----|
++it.low;debugTrace('use():'+num);return true;}// |----x|
if(it.high===num){// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
// |----|x
--it.high;debugTrace('use():'+num);return true;}var low=it.low;// |--x--|
// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
// x|--|
it.low=num+1;// |--|x|--|
this.ss.insert(new Interval(low,num-1));debugTrace('use():'+num);return true;}debugTrace('use():failed');return false;};/**
	 * Deallocate the number. The number become vacant status.
	 * Time Complexity O(logN) : N is the number of intervals (not numbers)
	 * @param {Number} num - The number to deallocate. The number must be occupied status.
	 *                       In other words, the number must be allocated by alloc() or occupied be use().
	 */NumberAllocator.prototype.free=function(num){if(num<this.min||num>this.max){debugError('free():'+num+' is out of range');return;}var key=new Interval(num,num);var it=this.ss.lowerBound(key);if(it){if(it.low<=num&&num<=it.high){debugError('free():'+num+' has already been vacant');return;}if(it===this.ss.front()){// v....
if(num+1===it.low){// Concat to right
// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
--it.low;}else {// Insert new interval
this.ss.insert(key);}}else {// ..v..
var itl=this.ss.reverseLowerBound(key);if(itl.high+1===num){if(num+1===it.low){// Concat to left and right
this.ss.eraseElementByValue(itl);// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
it.low=itl.low;}else {// Concat to left
// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
itl.high=num;}}else {if(num+1===it.low){// Concat to right
// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
it.low=num;}else {// Insert new interval
this.ss.insert(key);}}}}else {// ....v
if(it===this.ss.front()){// Insert new interval
this.ss.insert(key);return;}var _itl=this.ss.reverseLowerBound(key);if(_itl.high+1===num){// Concat to left
// Overwrite the interval in the ss but it is safe,
// because no order violation is happened.
_itl.high=num;}else {// Insert new interval
this.ss.insert(key);}}debugTrace('free():'+num);};/**
	 * Clear all occupied numbers.
	 * The all numbers are set to vacant status.
	 * Time Complexity O(1)
	 */NumberAllocator.prototype.clear=function(){debugTrace('clear()');this.ss.clear();this.ss.insert(new Interval(this.min,this.max));};/**
	 * Get the number of intervals. Interval is internal structure of this library.
	 * This function is for debugging.
	 * Time Complexity O(1)
	 * @return {Number} - The number of intervals.
	 */NumberAllocator.prototype.intervalCount=function(){return this.ss.size();};/**
	 * Dump the internal structor of the library.
	 * This function is for debugging.
	 * Time Complexity O(N) : N is the number of intervals (not numbers)
	 */NumberAllocator.prototype.dump=function(){console.log('length:'+this.ss.size());var _iterator3=_createForOfIteratorHelper(this.ss),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var element=_step3.value;console.log(element);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}};module.exports=NumberAllocator;},{"debug":18,"js-sdsl":36}],48:[function(require,module,exports){var wrappy=require('wrappy');module.exports=wrappy(once);module.exports.strict=wrappy(onceStrict);once.proto=once(function(){Object.defineProperty(Function.prototype,'once',{value:function value(){return once(this);},configurable:true});Object.defineProperty(Function.prototype,'onceStrict',{value:function value(){return onceStrict(this);},configurable:true});});function once(fn){var f=function f(){if(f.called)return f.value;f.called=true;return f.value=fn.apply(this,arguments);};f.called=false;return f;}function onceStrict(fn){var f=function f(){if(f.called)throw new Error(f.onceError);f.called=true;return f.value=fn.apply(this,arguments);};var name=fn.name||'Function wrapped with `once`';f.onceError=name+" shouldn't be called more than once";f.called=false;return f;}},{"wrappy":79}],49:[function(require,module,exports){(function(process){(function(){if(typeof process==='undefined'||!process.version||process.version.indexOf('v0.')===0||process.version.indexOf('v1.')===0&&process.version.indexOf('v1.8.')!==0){module.exports={nextTick:nextTick};}else {module.exports=process;}function nextTick(fn,arg1,arg2,arg3){if(typeof fn!=='function'){throw new TypeError('"callback" argument must be a function');}var len=arguments.length;var args,i;switch(len){case 0:case 1:return process.nextTick(fn);case 2:return process.nextTick(function afterTickOne(){fn.call(null,arg1);});case 3:return process.nextTick(function afterTickTwo(){fn.call(null,arg1,arg2);});case 4:return process.nextTick(function afterTickThree(){fn.call(null,arg1,arg2,arg3);});default:args=new Array(len-1);i=0;while(i<args.length){args[i++]=arguments[i];}return process.nextTick(function afterTick(){fn.apply(null,args);});}}}).call(this);}).call(this,require('_process'));},{"_process":50}],50:[function(require,module,exports){// shim for using process in browser
var process=module.exports={};// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else {cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else {cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations
return setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined
if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations
return clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined
if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else {queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects
function Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues
process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.prependListener=noop;process.prependOnceListener=noop;process.listeners=function(name){return [];};process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return '/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};},{}],51:[function(require,module,exports){(function(global){(function(){(function(root){/** Detect free variables */var freeExports=_typeof(exports)=='object'&&exports&&!exports.nodeType&&exports;var freeModule=_typeof(module)=='object'&&module&&!module.nodeType&&module;var freeGlobal=_typeof(global)=='object'&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal||freeGlobal.self===freeGlobal){root=freeGlobal;}/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */var punycode,/** Highest positive signed 32-bit float value */maxInt=2147483647,// aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */base=36,tMin=1,tMax=26,skew=38,damp=700,initialBias=72,initialN=128,// 0x80
delimiter='-',// '\x2D'
/** Regular expressions */regexPunycode=/^xn--/,regexNonASCII=/[^\x20-\x7E]/,// unprintable ASCII chars + non-ASCII chars
regexSeparators=/[\x2E\u3002\uFF0E\uFF61]/g,// RFC 3490 separators
/** Error messages */errors={'overflow':'Overflow: input needs wider integers to process','not-basic':'Illegal input >= 0x80 (not a basic code point)','invalid-input':'Invalid input'},/** Convenience shortcuts */baseMinusTMin=base-tMin,floor=Math.floor,stringFromCharCode=String.fromCharCode,/** Temporary variable */key;/*--------------------------------------------------------------------------*/ /**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */function error(type){throw new RangeError(errors[type]);}/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */function map(array,fn){var length=array.length;var result=[];while(length--){result[length]=fn(array[length]);}return result;}/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */function mapDomain(string,fn){var parts=string.split('@');var result='';if(parts.length>1){// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result=parts[0]+'@';string=parts[1];}// Avoid `split(regex)` for IE8 compatibility. See #17.
string=string.replace(regexSeparators,'\x2E');var labels=string.split('.');var encoded=map(labels,fn).join('.');return result+encoded;}/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */function ucs2decode(string){var output=[],counter=0,length=string.length,value,extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=0xD800&&value<=0xDBFF&&counter<length){// high surrogate, and there is a next character
extra=string.charCodeAt(counter++);if((extra&0xFC00)==0xDC00){// low surrogate
output.push(((value&0x3FF)<<10)+(extra&0x3FF)+0x10000);}else {// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value);counter--;}}else {output.push(value);}}return output;}/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */function ucs2encode(array){return map(array,function(value){var output='';if(value>0xFFFF){value-=0x10000;output+=stringFromCharCode(value>>>10&0x3FF|0xD800);value=0xDC00|value&0x3FF;}output+=stringFromCharCode(value);return output;}).join('');}/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */function basicToDigit(codePoint){if(codePoint-48<10){return codePoint-22;}if(codePoint-65<26){return codePoint-65;}if(codePoint-97<26){return codePoint-97;}return base;}/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */function digitToBasic(digit,flag){//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit+22+75*(digit<26)-((flag!=0)<<5);}/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */function adapt(delta,numPoints,firstTime){var k=0;delta=firstTime?floor(delta/damp):delta>>1;delta+=floor(delta/numPoints);for(;delta>baseMinusTMin*tMax>>1;k+=base){delta=floor(delta/baseMinusTMin);}return floor(k+(baseMinusTMin+1)*delta/(delta+skew));}/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */function decode(input){// Don't use UCS-2
var output=[],inputLength=input.length,out,i=0,n=initialN,bias=initialBias,basic,j,index,oldi,w,k,digit,t,/** Cached calculation results */baseMinusT;// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
basic=input.lastIndexOf(delimiter);if(basic<0){basic=0;}for(j=0;j<basic;++j){// if it's not a basic code point
if(input.charCodeAt(j)>=0x80){error('not-basic');}output.push(input.charCodeAt(j));}// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for(index=basic>0?basic+1:0;index<inputLength;){// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for(oldi=i,w=1,k=base;;k+=base){if(index>=inputLength){error('invalid-input');}digit=basicToDigit(input.charCodeAt(index++));if(digit>=base||digit>floor((maxInt-i)/w)){error('overflow');}i+=digit*w;t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(digit<t){break;}baseMinusT=base-t;if(w>floor(maxInt/baseMinusT)){error('overflow');}w*=baseMinusT;}out=output.length+1;bias=adapt(i-oldi,out,oldi==0);// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
if(floor(i/out)>maxInt-n){error('overflow');}n+=floor(i/out);i%=out;// Insert `n` at position `i` of the output
output.splice(i++,0,n);}return ucs2encode(output);}/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */function encode(input){var n,delta,handledCPCount,basicLength,bias,j,m,q,k,t,currentValue,output=[],/** `inputLength` will hold the number of code points in `input`. */inputLength,/** Cached calculation results */handledCPCountPlusOne,baseMinusT,qMinusT;// Convert the input in UCS-2 to Unicode
input=ucs2decode(input);// Cache the length
inputLength=input.length;// Initialize the state
n=initialN;delta=0;bias=initialBias;// Handle the basic code points
for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<0x80){output.push(stringFromCharCode(currentValue));}}handledCPCount=basicLength=output.length;// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if(basicLength){output.push(delimiter);}// Main encoding loop:
while(handledCPCount<inputLength){// All non-basic code points < n have been handled already. Find the next
// larger one:
for(m=maxInt,j=0;j<inputLength;++j){currentValue=input[j];if(currentValue>=n&&currentValue<m){m=currentValue;}}// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
handledCPCountPlusOne=handledCPCount+1;if(m-n>floor((maxInt-delta)/handledCPCountPlusOne)){error('overflow');}delta+=(m-n)*handledCPCountPlusOne;n=m;for(j=0;j<inputLength;++j){currentValue=input[j];if(currentValue<n&&++delta>maxInt){error('overflow');}if(currentValue==n){// Represent delta as a generalized variable-length integer
for(q=delta,k=base;;k+=base){t=k<=bias?tMin:k>=bias+tMax?tMax:k-bias;if(q<t){break;}qMinusT=q-t;baseMinusT=base-t;output.push(stringFromCharCode(digitToBasic(t+qMinusT%baseMinusT,0)));q=floor(qMinusT/baseMinusT);}output.push(stringFromCharCode(digitToBasic(q,0)));bias=adapt(delta,handledCPCountPlusOne,handledCPCount==basicLength);delta=0;++handledCPCount;}}++delta;++n;}return output.join('');}/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */function toUnicode(input){return mapDomain(input,function(string){return regexPunycode.test(string)?decode(string.slice(4).toLowerCase()):string;});}/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */function toASCII(input){return mapDomain(input,function(string){return regexNonASCII.test(string)?'xn--'+encode(string):string;});}/*--------------------------------------------------------------------------*/ /** Define the public API */punycode={/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */'version':'1.4.1',/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */'ucs2':{'decode':ucs2decode,'encode':ucs2encode},'decode':decode,'encode':encode,'toASCII':toASCII,'toUnicode':toUnicode};/** Expose `punycode` */ // Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if(freeExports&&freeModule){if(module.exports==freeExports){// in Node.js, io.js, or RingoJS v0.8.0+
freeModule.exports=punycode;}else {// in Narwhal or RingoJS v0.7.0-
for(key in punycode){punycode.hasOwnProperty(key)&&(freeExports[key]=punycode[key]);}}}else {// in Rhino or a web browser
root.punycode=punycode;}})(this);}).call(this);}).call(this,typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],52:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}module.exports=function(qs,sep,eq,options){sep=sep||'&';eq=eq||'=';var obj={};if(typeof qs!=='string'||qs.length===0){return obj;}var regexp=/\+/g;qs=qs.split(sep);var maxKeys=1000;if(options&&typeof options.maxKeys==='number'){maxKeys=options.maxKeys;}var len=qs.length;// maxKeys <= 0 means that we should not limit keys count
if(maxKeys>0&&len>maxKeys){len=maxKeys;}for(var i=0;i<len;++i){var x=qs[i].replace(regexp,'%20'),idx=x.indexOf(eq),kstr,vstr,k,v;if(idx>=0){kstr=x.substr(0,idx);vstr=x.substr(idx+1);}else {kstr=x;vstr='';}k=decodeURIComponent(kstr);v=decodeURIComponent(vstr);if(!hasOwnProperty(obj,k)){obj[k]=v;}else if(isArray(obj[k])){obj[k].push(v);}else {obj[k]=[obj[k],v];}}return obj;};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};},{}],53:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
var stringifyPrimitive=function stringifyPrimitive(v){switch(_typeof(v)){case'string':return v;case'boolean':return v?'true':'false';case'number':return isFinite(v)?v:'';default:return '';}};module.exports=function(obj,sep,eq,name){sep=sep||'&';eq=eq||'=';if(obj===null){obj=undefined;}if(_typeof(obj)==='object'){return map(objectKeys(obj),function(k){var ks=encodeURIComponent(stringifyPrimitive(k))+eq;if(isArray(obj[k])){return map(obj[k],function(v){return ks+encodeURIComponent(stringifyPrimitive(v));}).join(sep);}else {return ks+encodeURIComponent(stringifyPrimitive(obj[k]));}}).join(sep);}if(!name)return '';return encodeURIComponent(stringifyPrimitive(name))+eq+encodeURIComponent(stringifyPrimitive(obj));};var isArray=Array.isArray||function(xs){return Object.prototype.toString.call(xs)==='[object Array]';};function map(xs,f){if(xs.map)return xs.map(f);var res=[];for(var i=0;i<xs.length;i++){res.push(f(xs[i],i));}return res;}var objectKeys=Object.keys||function(obj){var res=[];for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))res.push(key);}return res;};},{}],54:[function(require,module,exports){exports.decode=exports.parse=require('./decode');exports.encode=exports.stringify=require('./encode');},{"./decode":52,"./encode":53}],55:[function(require,module,exports){function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}var codes={};function createErrorType(code,message,Base){if(!Base){Base=Error;}function getMessage(arg1,arg2,arg3){if(typeof message==='string'){return message;}else {return message(arg1,arg2,arg3);}}var NodeError=/*#__PURE__*/function(_Base){_inheritsLoose(NodeError,_Base);function NodeError(arg1,arg2,arg3){return _Base.call(this,getMessage(arg1,arg2,arg3))||this;}return NodeError;}(Base);NodeError.prototype.name=Base.name;NodeError.prototype.code=code;codes[code]=NodeError;}// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected,thing){if(Array.isArray(expected)){var len=expected.length;expected=expected.map(function(i){return String(i);});if(len>2){return "one of ".concat(thing," ").concat(expected.slice(0,len-1).join(', '),", or ")+expected[len-1];}else if(len===2){return "one of ".concat(thing," ").concat(expected[0]," or ").concat(expected[1]);}else {return "of ".concat(thing," ").concat(expected[0]);}}else {return "of ".concat(thing," ").concat(String(expected));}}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str,search,pos){return str.substr(!pos||pos<0?0:+pos,search.length)===search;}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str,search,this_len){if(this_len===undefined||this_len>str.length){this_len=str.length;}return str.substring(this_len-search.length,this_len)===search;}// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str,search,start){if(typeof start!=='number'){start=0;}if(start+search.length>str.length){return false;}else {return str.indexOf(search,start)!==-1;}}createErrorType('ERR_INVALID_OPT_VALUE',function(name,value){return 'The value "'+value+'" is invalid for option "'+name+'"';},TypeError);createErrorType('ERR_INVALID_ARG_TYPE',function(name,expected,actual){// determiner: 'must be' or 'must not be'
var determiner;if(typeof expected==='string'&&startsWith(expected,'not ')){determiner='must not be';expected=expected.replace(/^not /,'');}else {determiner='must be';}var msg;if(endsWith(name,' argument')){// For cases like 'first argument'
msg="The ".concat(name," ").concat(determiner," ").concat(oneOf(expected,'type'));}else {var type=includes(name,'.')?'property':'argument';msg="The \"".concat(name,"\" ").concat(type," ").concat(determiner," ").concat(oneOf(expected,'type'));}msg+=". Received type ".concat(_typeof(actual));return msg;},TypeError);createErrorType('ERR_STREAM_PUSH_AFTER_EOF','stream.push() after EOF');createErrorType('ERR_METHOD_NOT_IMPLEMENTED',function(name){return 'The '+name+' method is not implemented';});createErrorType('ERR_STREAM_PREMATURE_CLOSE','Premature close');createErrorType('ERR_STREAM_DESTROYED',function(name){return 'Cannot call '+name+' after a stream was destroyed';});createErrorType('ERR_MULTIPLE_CALLBACK','Callback called multiple times');createErrorType('ERR_STREAM_CANNOT_PIPE','Cannot pipe, not readable');createErrorType('ERR_STREAM_WRITE_AFTER_END','write after end');createErrorType('ERR_STREAM_NULL_VALUES','May not write null values to stream',TypeError);createErrorType('ERR_UNKNOWN_ENCODING',function(arg){return 'Unknown encoding: '+arg;},TypeError);createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT','stream.unshift() after end event');module.exports.codes=codes;},{}],56:[function(require,module,exports){(function(process){(function(){// Copyright Joyent, Inc. and other Node contributors.
/*<replacement>*/var objectKeys=Object.keys||function(obj){var keys=[];for(var key in obj){keys.push(key);}return keys;};/*</replacement>*/module.exports=Duplex;var Readable=require('./_stream_readable');var Writable=require('./_stream_writable');require('inherits')(Duplex,Readable);{// Allow the keys array to be GC'ed.
var keys=objectKeys(Writable.prototype);for(var v=0;v<keys.length;v++){var method=keys[v];if(!Duplex.prototype[method])Duplex.prototype[method]=Writable.prototype[method];}}function Duplex(options){if(!(this instanceof Duplex))return new Duplex(options);Readable.call(this,options);Writable.call(this,options);this.allowHalfOpen=true;if(options){if(options.readable===false)this.readable=false;if(options.writable===false)this.writable=false;if(options.allowHalfOpen===false){this.allowHalfOpen=false;this.once('end',onend);}}}Object.defineProperty(Duplex.prototype,'writableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.highWaterMark;}});Object.defineProperty(Duplex.prototype,'writableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer();}});Object.defineProperty(Duplex.prototype,'writableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.length;}});// the no-half-open enforcer
function onend(){// If the writable side ended, then we're ok.
if(this._writableState.ended)return;// no more data can be written.
// But allow more writes to happen in this tick.
process.nextTick(onEndNT,this);}function onEndNT(self){self.end();}Object.defineProperty(Duplex.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._readableState===undefined||this._writableState===undefined){return false;}return this._readableState.destroyed&&this._writableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(this._readableState===undefined||this._writableState===undefined){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._readableState.destroyed=value;this._writableState.destroyed=value;}});}).call(this);}).call(this,require('_process'));},{"./_stream_readable":58,"./_stream_writable":60,"_process":50,"inherits":24}],57:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
module.exports=PassThrough;var Transform=require('./_stream_transform');require('inherits')(PassThrough,Transform);function PassThrough(options){if(!(this instanceof PassThrough))return new PassThrough(options);Transform.call(this,options);}PassThrough.prototype._transform=function(chunk,encoding,cb){cb(null,chunk);};},{"./_stream_transform":59,"inherits":24}],58:[function(require,module,exports){(function(process,global){(function(){// Copyright Joyent, Inc. and other Node contributors.
module.exports=Readable;/*<replacement>*/var Duplex;/*</replacement>*/Readable.ReadableState=ReadableState;/*<replacement>*/require('events').EventEmitter;var EElistenerCount=function EElistenerCount(emitter,type){return emitter.listeners(type).length;};/*</replacement>*/ /*<replacement>*/var Stream=require('./internal/streams/stream');/*</replacement>*/var Buffer=require('buffer').Buffer;var OurUint8Array=global.Uint8Array||function(){};function _uint8ArrayToBuffer(chunk){return Buffer.from(chunk);}function _isUint8Array(obj){return Buffer.isBuffer(obj)||obj instanceof OurUint8Array;}/*<replacement>*/var debugUtil=require('util');var debug;if(debugUtil&&debugUtil.debuglog){debug=debugUtil.debuglog('stream');}else {debug=function debug(){};}/*</replacement>*/var BufferList=require('./internal/streams/buffer_list');var destroyImpl=require('./internal/streams/destroy');var _require=require('./internal/streams/state'),getHighWaterMark=_require.getHighWaterMark;var _require$codes=require('../errors').codes,ERR_INVALID_ARG_TYPE=_require$codes.ERR_INVALID_ARG_TYPE,ERR_STREAM_PUSH_AFTER_EOF=_require$codes.ERR_STREAM_PUSH_AFTER_EOF,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_STREAM_UNSHIFT_AFTER_END_EVENT=_require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;// Lazy loaded to improve the startup performance.
var StringDecoder;var createReadableStreamAsyncIterator;var from;require('inherits')(Readable,Stream);var errorOrDestroy=destroyImpl.errorOrDestroy;var kProxyEvents=['error','close','destroy','pause','resume'];function prependListener(emitter,event,fn){// Sadly this is not cacheable as some libraries bundle their own
// event emitter implementation with them.
if(typeof emitter.prependListener==='function')return emitter.prependListener(event,fn);// This is a hack to make sure that our error handler is attached before any
// userland ones.  NEVER DO THIS. This is here only because this code needs
// to continue to work with older versions of Node.js that do not include
// the prependListener() method. The goal is to eventually remove this hack.
if(!emitter._events||!emitter._events[event])emitter.on(event,fn);else if(Array.isArray(emitter._events[event]))emitter._events[event].unshift(fn);else emitter._events[event]=[fn,emitter._events[event]];}function ReadableState(options,stream,isDuplex){Duplex=Duplex||require('./_stream_duplex');options=options||{};// Duplex streams are both readable and writable, but share
// the same options object.
// However, some cases require setting options to different
// values for the readable and the writable sides of the duplex stream.
// These options can be provided separately as readableXXX and writableXXX.
if(typeof isDuplex!=='boolean')isDuplex=stream instanceof Duplex;// object stream flag. Used to make read(n) ignore n and to
// make all the buffer merging and length checks go away
this.objectMode=!!options.objectMode;if(isDuplex)this.objectMode=this.objectMode||!!options.readableObjectMode;// the point at which it stops calling _read() to fill the buffer
// Note: 0 is a valid value, means "don't call _read preemptively ever"
this.highWaterMark=getHighWaterMark(this,options,'readableHighWaterMark',isDuplex);// A linked list is used to store data chunks instead of an array because the
// linked list can remove elements from the beginning faster than
// array.shift()
this.buffer=new BufferList();this.length=0;this.pipes=null;this.pipesCount=0;this.flowing=null;this.ended=false;this.endEmitted=false;this.reading=false;// a flag to be able to tell if the event 'readable'/'data' is emitted
// immediately, or on a later tick.  We set this to true at first, because
// any actions that shouldn't happen until "later" should generally also
// not happen before the first read call.
this.sync=true;// whenever we return null, then we set a flag to say
// that we're awaiting a 'readable' event emission.
this.needReadable=false;this.emittedReadable=false;this.readableListening=false;this.resumeScheduled=false;this.paused=true;// Should close be emitted on destroy. Defaults to true.
this.emitClose=options.emitClose!==false;// Should .destroy() be called after 'end' (and potentially 'finish')
this.autoDestroy=!!options.autoDestroy;// has it been destroyed
this.destroyed=false;// Crypto is kind of old and crusty.  Historically, its default string
// encoding is 'binary' so we have to make this configurable.
// Everything else in the universe uses 'utf8', though.
this.defaultEncoding=options.defaultEncoding||'utf8';// the number of writers that are awaiting a drain event in .pipe()s
this.awaitDrain=0;// if true, a maybeReadMore has been scheduled
this.readingMore=false;this.decoder=null;this.encoding=null;if(options.encoding){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;this.decoder=new StringDecoder(options.encoding);this.encoding=options.encoding;}}function Readable(options){Duplex=Duplex||require('./_stream_duplex');if(!(this instanceof Readable))return new Readable(options);// Checking for a Stream.Duplex instance is faster here instead of inside
// the ReadableState constructor, at least with V8 6.5
var isDuplex=this instanceof Duplex;this._readableState=new ReadableState(options,this,isDuplex);// legacy
this.readable=true;if(options){if(typeof options.read==='function')this._read=options.read;if(typeof options.destroy==='function')this._destroy=options.destroy;}Stream.call(this);}Object.defineProperty(Readable.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._readableState===undefined){return false;}return this._readableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(!this._readableState){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._readableState.destroyed=value;}});Readable.prototype.destroy=destroyImpl.destroy;Readable.prototype._undestroy=destroyImpl.undestroy;Readable.prototype._destroy=function(err,cb){cb(err);};// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push=function(chunk,encoding){var state=this._readableState;var skipChunkCheck;if(!state.objectMode){if(typeof chunk==='string'){encoding=encoding||state.defaultEncoding;if(encoding!==state.encoding){chunk=Buffer.from(chunk,encoding);encoding='';}skipChunkCheck=true;}}else {skipChunkCheck=true;}return readableAddChunk(this,chunk,encoding,false,skipChunkCheck);};// Unshift should *always* be something directly out of read()
Readable.prototype.unshift=function(chunk){return readableAddChunk(this,chunk,null,true,false);};function readableAddChunk(stream,chunk,encoding,addToFront,skipChunkCheck){debug('readableAddChunk',chunk);var state=stream._readableState;if(chunk===null){state.reading=false;onEofChunk(stream,state);}else {var er;if(!skipChunkCheck)er=chunkInvalid(state,chunk);if(er){errorOrDestroy(stream,er);}else if(state.objectMode||chunk&&chunk.length>0){if(typeof chunk!=='string'&&!state.objectMode&&Object.getPrototypeOf(chunk)!==Buffer.prototype){chunk=_uint8ArrayToBuffer(chunk);}if(addToFront){if(state.endEmitted)errorOrDestroy(stream,new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream,state,chunk,true);}else if(state.ended){errorOrDestroy(stream,new ERR_STREAM_PUSH_AFTER_EOF());}else if(state.destroyed){return false;}else {state.reading=false;if(state.decoder&&!encoding){chunk=state.decoder.write(chunk);if(state.objectMode||chunk.length!==0)addChunk(stream,state,chunk,false);else maybeReadMore(stream,state);}else {addChunk(stream,state,chunk,false);}}}else if(!addToFront){state.reading=false;maybeReadMore(stream,state);}}// We can push more data if we are below the highWaterMark.
// Also, if we have no data yet, we can stand some more bytes.
// This is to work around cases where hwm=0, such as the repl.
return !state.ended&&(state.length<state.highWaterMark||state.length===0);}function addChunk(stream,state,chunk,addToFront){if(state.flowing&&state.length===0&&!state.sync){state.awaitDrain=0;stream.emit('data',chunk);}else {// update the buffer info.
state.length+=state.objectMode?1:chunk.length;if(addToFront)state.buffer.unshift(chunk);else state.buffer.push(chunk);if(state.needReadable)emitReadable(stream);}maybeReadMore(stream,state);}function chunkInvalid(state,chunk){var er;if(!_isUint8Array(chunk)&&typeof chunk!=='string'&&chunk!==undefined&&!state.objectMode){er=new ERR_INVALID_ARG_TYPE('chunk',['string','Buffer','Uint8Array'],chunk);}return er;}Readable.prototype.isPaused=function(){return this._readableState.flowing===false;};// backwards compatibility.
Readable.prototype.setEncoding=function(enc){if(!StringDecoder)StringDecoder=require('string_decoder/').StringDecoder;var decoder=new StringDecoder(enc);this._readableState.decoder=decoder;// If setEncoding(null), decoder.encoding equals utf8
this._readableState.encoding=this._readableState.decoder.encoding;// Iterate over current buffer to convert already stored Buffers:
var p=this._readableState.buffer.head;var content='';while(p!==null){content+=decoder.write(p.data);p=p.next;}this._readableState.buffer.clear();if(content!=='')this._readableState.buffer.push(content);this._readableState.length=content.length;return this;};// Don't raise the hwm > 1GB
var MAX_HWM=0x40000000;function computeNewHighWaterMark(n){if(n>=MAX_HWM){// TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
n=MAX_HWM;}else {// Get the next highest power of 2 to prevent increasing hwm excessively in
// tiny amounts
n--;n|=n>>>1;n|=n>>>2;n|=n>>>4;n|=n>>>8;n|=n>>>16;n++;}return n;}// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n,state){if(n<=0||state.length===0&&state.ended)return 0;if(state.objectMode)return 1;if(n!==n){// Only flow one buffer at a time
if(state.flowing&&state.length)return state.buffer.head.data.length;else return state.length;}// If we're asking for more than the current hwm, then raise the hwm.
if(n>state.highWaterMark)state.highWaterMark=computeNewHighWaterMark(n);if(n<=state.length)return n;// Don't have enough
if(!state.ended){state.needReadable=true;return 0;}return state.length;}// you can override either this method, or the async _read(n) below.
Readable.prototype.read=function(n){debug('read',n);n=parseInt(n,10);var state=this._readableState;var nOrig=n;if(n!==0)state.emittedReadable=false;// if we're doing read(0) to trigger a readable event, but we
// already have a bunch of data in the buffer, then just trigger
// the 'readable' event and move on.
if(n===0&&state.needReadable&&((state.highWaterMark!==0?state.length>=state.highWaterMark:state.length>0)||state.ended)){debug('read: emitReadable',state.length,state.ended);if(state.length===0&&state.ended)endReadable(this);else emitReadable(this);return null;}n=howMuchToRead(n,state);// if we've ended, and we're now clear, then finish it up.
if(n===0&&state.ended){if(state.length===0)endReadable(this);return null;}// All the actual chunk generation logic needs to be
// *below* the call to _read.  The reason is that in certain
// synthetic stream cases, such as passthrough streams, _read
// may be a completely synchronous operation which may change
// the state of the read buffer, providing enough data when
// before there was *not* enough.
//
// So, the steps are:
// 1. Figure out what the state of things will be after we do
// a read from the buffer.
//
// 2. If that resulting state will trigger a _read, then call _read.
// Note that this may be asynchronous, or synchronous.  Yes, it is
// deeply ugly to write APIs this way, but that still doesn't mean
// that the Readable class should behave improperly, as streams are
// designed to be sync/async agnostic.
// Take note if the _read call is sync or async (ie, if the read call
// has returned yet), so that we know whether or not it's safe to emit
// 'readable' etc.
//
// 3. Actually pull the requested chunks out of the buffer and return.
// if we need a readable event, then we need to do some reading.
var doRead=state.needReadable;debug('need readable',doRead);// if we currently have less than the highWaterMark, then also read some
if(state.length===0||state.length-n<state.highWaterMark){doRead=true;debug('length less than watermark',doRead);}// however, if we've ended, then there's no point, and if we're already
// reading, then it's unnecessary.
if(state.ended||state.reading){doRead=false;debug('reading or ended',doRead);}else if(doRead){debug('do read');state.reading=true;state.sync=true;// if the length is currently zero, then we *need* a readable event.
if(state.length===0)state.needReadable=true;// call internal read method
this._read(state.highWaterMark);state.sync=false;// If _read pushed data synchronously, then `reading` will be false,
// and we need to re-evaluate how much data we can return to the user.
if(!state.reading)n=howMuchToRead(nOrig,state);}var ret;if(n>0)ret=fromList(n,state);else ret=null;if(ret===null){state.needReadable=state.length<=state.highWaterMark;n=0;}else {state.length-=n;state.awaitDrain=0;}if(state.length===0){// If we have nothing in the buffer, then we want to know
// as soon as we *do* get something into the buffer.
if(!state.ended)state.needReadable=true;// If we tried to read() past the EOF, then emit end on the next tick.
if(nOrig!==n&&state.ended)endReadable(this);}if(ret!==null)this.emit('data',ret);return ret;};function onEofChunk(stream,state){debug('onEofChunk');if(state.ended)return;if(state.decoder){var chunk=state.decoder.end();if(chunk&&chunk.length){state.buffer.push(chunk);state.length+=state.objectMode?1:chunk.length;}}state.ended=true;if(state.sync){// if we are sync, wait until next tick to emit the data.
// Otherwise we risk emitting data in the flow()
// the readable code triggers during a read() call
emitReadable(stream);}else {// emit 'readable' now to make sure it gets picked up.
state.needReadable=false;if(!state.emittedReadable){state.emittedReadable=true;emitReadable_(stream);}}}// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream){var state=stream._readableState;debug('emitReadable',state.needReadable,state.emittedReadable);state.needReadable=false;if(!state.emittedReadable){debug('emitReadable',state.flowing);state.emittedReadable=true;process.nextTick(emitReadable_,stream);}}function emitReadable_(stream){var state=stream._readableState;debug('emitReadable_',state.destroyed,state.length,state.ended);if(!state.destroyed&&(state.length||state.ended)){stream.emit('readable');state.emittedReadable=false;}// The stream needs another readable event if
// 1. It is not flowing, as the flow mechanism will take
//    care of it.
// 2. It is not ended.
// 3. It is below the highWaterMark, so we can schedule
//    another readable later.
state.needReadable=!state.flowing&&!state.ended&&state.length<=state.highWaterMark;flow(stream);}// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream,state){if(!state.readingMore){state.readingMore=true;process.nextTick(maybeReadMore_,stream,state);}}function maybeReadMore_(stream,state){// Attempt to read more data if we should.
//
// The conditions for reading more data are (one of):
// - Not enough data buffered (state.length < state.highWaterMark). The loop
//   is responsible for filling the buffer with enough data if such data
//   is available. If highWaterMark is 0 and we are not in the flowing mode
//   we should _not_ attempt to buffer any extra data. We'll get more data
//   when the stream consumer calls read() instead.
// - No data in the buffer, and the stream is in flowing mode. In this mode
//   the loop below is responsible for ensuring read() is called. Failing to
//   call read here would abort the flow and there's no other mechanism for
//   continuing the flow if the stream consumer has just subscribed to the
//   'data' event.
//
// In addition to the above conditions to keep reading data, the following
// conditions prevent the data from being read:
// - The stream has ended (state.ended).
// - There is already a pending 'read' operation (state.reading). This is a
//   case where the the stream has called the implementation defined _read()
//   method, but they are processing the call asynchronously and have _not_
//   called push() with new data. In this case we skip performing more
//   read()s. The execution ends in this method again after the _read() ends
//   up calling push() with more data.
while(!state.reading&&!state.ended&&(state.length<state.highWaterMark||state.flowing&&state.length===0)){var len=state.length;debug('maybeReadMore read 0');stream.read(0);if(len===state.length)// didn't get any data, stop spinning.
break;}state.readingMore=false;}// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read=function(n){errorOrDestroy(this,new ERR_METHOD_NOT_IMPLEMENTED('_read()'));};Readable.prototype.pipe=function(dest,pipeOpts){var src=this;var state=this._readableState;switch(state.pipesCount){case 0:state.pipes=dest;break;case 1:state.pipes=[state.pipes,dest];break;default:state.pipes.push(dest);break;}state.pipesCount+=1;debug('pipe count=%d opts=%j',state.pipesCount,pipeOpts);var doEnd=(!pipeOpts||pipeOpts.end!==false)&&dest!==process.stdout&&dest!==process.stderr;var endFn=doEnd?onend:unpipe;if(state.endEmitted)process.nextTick(endFn);else src.once('end',endFn);dest.on('unpipe',onunpipe);function onunpipe(readable,unpipeInfo){debug('onunpipe');if(readable===src){if(unpipeInfo&&unpipeInfo.hasUnpiped===false){unpipeInfo.hasUnpiped=true;cleanup();}}}function onend(){debug('onend');dest.end();}// when the dest drains, it reduces the awaitDrain counter
// on the source.  This would be more elegant with a .once()
// handler in flow(), but adding and removing repeatedly is
// too slow.
var ondrain=pipeOnDrain(src);dest.on('drain',ondrain);var cleanedUp=false;function cleanup(){debug('cleanup');// cleanup event handlers once the pipe is broken
dest.removeListener('close',onclose);dest.removeListener('finish',onfinish);dest.removeListener('drain',ondrain);dest.removeListener('error',onerror);dest.removeListener('unpipe',onunpipe);src.removeListener('end',onend);src.removeListener('end',unpipe);src.removeListener('data',ondata);cleanedUp=true;// if the reader is waiting for a drain event from this
// specific writer, then it would cause it to never start
// flowing again.
// So, if this is awaiting a drain, then we just call it now.
// If we don't know, then assume that we are waiting for one.
if(state.awaitDrain&&(!dest._writableState||dest._writableState.needDrain))ondrain();}src.on('data',ondata);function ondata(chunk){debug('ondata');var ret=dest.write(chunk);debug('dest.write',ret);if(ret===false){// If the user unpiped during `dest.write()`, it is possible
// to get stuck in a permanently paused state if that write
// also returned false.
// => Check whether `dest` is still a piping destination.
if((state.pipesCount===1&&state.pipes===dest||state.pipesCount>1&&indexOf(state.pipes,dest)!==-1)&&!cleanedUp){debug('false write response, pause',state.awaitDrain);state.awaitDrain++;}src.pause();}}// if the dest has an error, then stop piping into it.
// however, don't suppress the throwing behavior for this.
function onerror(er){debug('onerror',er);unpipe();dest.removeListener('error',onerror);if(EElistenerCount(dest,'error')===0)errorOrDestroy(dest,er);}// Make sure our error handler is attached before userland ones.
prependListener(dest,'error',onerror);// Both close and finish should trigger unpipe, but only once.
function onclose(){dest.removeListener('finish',onfinish);unpipe();}dest.once('close',onclose);function onfinish(){debug('onfinish');dest.removeListener('close',onclose);unpipe();}dest.once('finish',onfinish);function unpipe(){debug('unpipe');src.unpipe(dest);}// tell the dest that it's being piped to
dest.emit('pipe',src);// start the flow if it hasn't been started already.
if(!state.flowing){debug('pipe resume');src.resume();}return dest;};function pipeOnDrain(src){return function pipeOnDrainFunctionResult(){var state=src._readableState;debug('pipeOnDrain',state.awaitDrain);if(state.awaitDrain)state.awaitDrain--;if(state.awaitDrain===0&&EElistenerCount(src,'data')){state.flowing=true;flow(src);}};}Readable.prototype.unpipe=function(dest){var state=this._readableState;var unpipeInfo={hasUnpiped:false};// if we're not piping anywhere, then do nothing.
if(state.pipesCount===0)return this;// just one destination.  most common case.
if(state.pipesCount===1){// passed in one, but it's not the right one.
if(dest&&dest!==state.pipes)return this;if(!dest)dest=state.pipes;// got a match.
state.pipes=null;state.pipesCount=0;state.flowing=false;if(dest)dest.emit('unpipe',this,unpipeInfo);return this;}// slow case. multiple pipe destinations.
if(!dest){// remove all.
var dests=state.pipes;var len=state.pipesCount;state.pipes=null;state.pipesCount=0;state.flowing=false;for(var i=0;i<len;i++){dests[i].emit('unpipe',this,{hasUnpiped:false});}return this;}// try to find the right one.
var index=indexOf(state.pipes,dest);if(index===-1)return this;state.pipes.splice(index,1);state.pipesCount-=1;if(state.pipesCount===1)state.pipes=state.pipes[0];dest.emit('unpipe',this,unpipeInfo);return this;};// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on=function(ev,fn){var res=Stream.prototype.on.call(this,ev,fn);var state=this._readableState;if(ev==='data'){// update readableListening so that resume() may be a no-op
// a few lines down. This is needed to support once('readable').
state.readableListening=this.listenerCount('readable')>0;// Try start flowing on next tick if stream isn't explicitly paused
if(state.flowing!==false)this.resume();}else if(ev==='readable'){if(!state.endEmitted&&!state.readableListening){state.readableListening=state.needReadable=true;state.flowing=false;state.emittedReadable=false;debug('on readable',state.length,state.reading);if(state.length){emitReadable(this);}else if(!state.reading){process.nextTick(nReadingNextTick,this);}}}return res;};Readable.prototype.addListener=Readable.prototype.on;Readable.prototype.removeListener=function(ev,fn){var res=Stream.prototype.removeListener.call(this,ev,fn);if(ev==='readable'){// We need to check if there is someone still listening to
// readable and reset the state. However this needs to happen
// after readable has been emitted but before I/O (nextTick) to
// support once('readable', fn) cycles. This means that calling
// resume within the same tick will have no
// effect.
process.nextTick(updateReadableListening,this);}return res;};Readable.prototype.removeAllListeners=function(ev){var res=Stream.prototype.removeAllListeners.apply(this,arguments);if(ev==='readable'||ev===undefined){// We need to check if there is someone still listening to
// readable and reset the state. However this needs to happen
// after readable has been emitted but before I/O (nextTick) to
// support once('readable', fn) cycles. This means that calling
// resume within the same tick will have no
// effect.
process.nextTick(updateReadableListening,this);}return res;};function updateReadableListening(self){var state=self._readableState;state.readableListening=self.listenerCount('readable')>0;if(state.resumeScheduled&&!state.paused){// flowing needs to be set to true now, otherwise
// the upcoming resume will not flow.
state.flowing=true;// crude way to check if we should resume
}else if(self.listenerCount('data')>0){self.resume();}}function nReadingNextTick(self){debug('readable nexttick read 0');self.read(0);}// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume=function(){var state=this._readableState;if(!state.flowing){debug('resume');// we flow only if there is no one listening
// for readable, but we still have to call
// resume()
state.flowing=!state.readableListening;resume(this,state);}state.paused=false;return this;};function resume(stream,state){if(!state.resumeScheduled){state.resumeScheduled=true;process.nextTick(resume_,stream,state);}}function resume_(stream,state){debug('resume',state.reading);if(!state.reading){stream.read(0);}state.resumeScheduled=false;stream.emit('resume');flow(stream);if(state.flowing&&!state.reading)stream.read(0);}Readable.prototype.pause=function(){debug('call pause flowing=%j',this._readableState.flowing);if(this._readableState.flowing!==false){debug('pause');this._readableState.flowing=false;this.emit('pause');}this._readableState.paused=true;return this;};function flow(stream){var state=stream._readableState;debug('flow',state.flowing);while(state.flowing&&stream.read()!==null){}}// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap=function(stream){var _this=this;var state=this._readableState;var paused=false;stream.on('end',function(){debug('wrapped end');if(state.decoder&&!state.ended){var chunk=state.decoder.end();if(chunk&&chunk.length)_this.push(chunk);}_this.push(null);});stream.on('data',function(chunk){debug('wrapped data');if(state.decoder)chunk=state.decoder.write(chunk);// don't skip over falsy values in objectMode
if(state.objectMode&&(chunk===null||chunk===undefined))return;else if(!state.objectMode&&(!chunk||!chunk.length))return;var ret=_this.push(chunk);if(!ret){paused=true;stream.pause();}});// proxy all the other methods.
// important when wrapping filters and duplexes.
for(var i in stream){if(this[i]===undefined&&typeof stream[i]==='function'){this[i]=function methodWrap(method){return function methodWrapReturnFunction(){return stream[method].apply(stream,arguments);};}(i);}}// proxy certain important events.
for(var n=0;n<kProxyEvents.length;n++){stream.on(kProxyEvents[n],this.emit.bind(this,kProxyEvents[n]));}// when we try to consume some more bytes, simply unpause the
// underlying stream.
this._read=function(n){debug('wrapped _read',n);if(paused){paused=false;stream.resume();}};return this;};if(typeof Symbol==='function'){Readable.prototype[Symbol.asyncIterator]=function(){if(createReadableStreamAsyncIterator===undefined){createReadableStreamAsyncIterator=require('./internal/streams/async_iterator');}return createReadableStreamAsyncIterator(this);};}Object.defineProperty(Readable.prototype,'readableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.highWaterMark;}});Object.defineProperty(Readable.prototype,'readableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState&&this._readableState.buffer;}});Object.defineProperty(Readable.prototype,'readableFlowing',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.flowing;},set:function set(state){if(this._readableState){this._readableState.flowing=state;}}});// exposed for testing purposes only.
Readable._fromList=fromList;Object.defineProperty(Readable.prototype,'readableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._readableState.length;}});// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n,state){// nothing buffered
if(state.length===0)return null;var ret;if(state.objectMode)ret=state.buffer.shift();else if(!n||n>=state.length){// read it all, truncate the list
if(state.decoder)ret=state.buffer.join('');else if(state.buffer.length===1)ret=state.buffer.first();else ret=state.buffer.concat(state.length);state.buffer.clear();}else {// read part of list
ret=state.buffer.consume(n,state.decoder);}return ret;}function endReadable(stream){var state=stream._readableState;debug('endReadable',state.endEmitted);if(!state.endEmitted){state.ended=true;process.nextTick(endReadableNT,state,stream);}}function endReadableNT(state,stream){debug('endReadableNT',state.endEmitted,state.length);// Check that we didn't get one last unshift.
if(!state.endEmitted&&state.length===0){state.endEmitted=true;stream.readable=false;stream.emit('end');if(state.autoDestroy){// In case of duplex streams we need a way to detect
// if the writable side is ready for autoDestroy as well
var wState=stream._writableState;if(!wState||wState.autoDestroy&&wState.finished){stream.destroy();}}}}if(typeof Symbol==='function'){Readable.from=function(iterable,opts){if(from===undefined){from=require('./internal/streams/from');}return from(Readable,iterable,opts);};}function indexOf(xs,x){for(var i=0,l=xs.length;i<l;i++){if(xs[i]===x)return i;}return -1;}}).call(this);}).call(this,require('_process'),typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"../errors":55,"./_stream_duplex":56,"./internal/streams/async_iterator":61,"./internal/streams/buffer_list":62,"./internal/streams/destroy":63,"./internal/streams/from":65,"./internal/streams/state":67,"./internal/streams/stream":68,"_process":50,"buffer":17,"events":22,"inherits":24,"string_decoder/":75,"util":16}],59:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
module.exports=Transform;var _require$codes=require('../errors').codes,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=_require$codes.ERR_MULTIPLE_CALLBACK,ERR_TRANSFORM_ALREADY_TRANSFORMING=_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,ERR_TRANSFORM_WITH_LENGTH_0=_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;var Duplex=require('./_stream_duplex');require('inherits')(Transform,Duplex);function afterTransform(er,data){var ts=this._transformState;ts.transforming=false;var cb=ts.writecb;if(cb===null){return this.emit('error',new ERR_MULTIPLE_CALLBACK());}ts.writechunk=null;ts.writecb=null;if(data!=null)// single equals check for both `null` and `undefined`
this.push(data);cb(er);var rs=this._readableState;rs.reading=false;if(rs.needReadable||rs.length<rs.highWaterMark){this._read(rs.highWaterMark);}}function Transform(options){if(!(this instanceof Transform))return new Transform(options);Duplex.call(this,options);this._transformState={afterTransform:afterTransform.bind(this),needTransform:false,transforming:false,writecb:null,writechunk:null,writeencoding:null};// start out asking for a readable event once data is transformed.
this._readableState.needReadable=true;// we have implemented the _read method, and done the other things
// that Readable wants before the first _read call, so unset the
// sync guard flag.
this._readableState.sync=false;if(options){if(typeof options.transform==='function')this._transform=options.transform;if(typeof options.flush==='function')this._flush=options.flush;}// When the writable side finishes, then flush out anything remaining.
this.on('prefinish',prefinish);}function prefinish(){var _this=this;if(typeof this._flush==='function'&&!this._readableState.destroyed){this._flush(function(er,data){done(_this,er,data);});}else {done(this,null,null);}}Transform.prototype.push=function(chunk,encoding){this._transformState.needTransform=false;return Duplex.prototype.push.call(this,chunk,encoding);};// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));};Transform.prototype._write=function(chunk,encoding,cb){var ts=this._transformState;ts.writecb=cb;ts.writechunk=chunk;ts.writeencoding=encoding;if(!ts.transforming){var rs=this._readableState;if(ts.needTransform||rs.needReadable||rs.length<rs.highWaterMark)this._read(rs.highWaterMark);}};// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read=function(n){var ts=this._transformState;if(ts.writechunk!==null&&!ts.transforming){ts.transforming=true;this._transform(ts.writechunk,ts.writeencoding,ts.afterTransform);}else {// mark that we need a transform, so that any data that comes in
// will get processed, now that we've asked for it.
ts.needTransform=true;}};Transform.prototype._destroy=function(err,cb){Duplex.prototype._destroy.call(this,err,function(err2){cb(err2);});};function done(stream,er,data){if(er)return stream.emit('error',er);if(data!=null)// single equals check for both `null` and `undefined`
stream.push(data);// TODO(BridgeAR): Write a test for these two error cases
// if there's nothing in the write buffer, then that means
// that nothing more will ever be provided
if(stream._writableState.length)throw new ERR_TRANSFORM_WITH_LENGTH_0();if(stream._transformState.transforming)throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();return stream.push(null);}},{"../errors":55,"./_stream_duplex":56,"inherits":24}],60:[function(require,module,exports){(function(process,global){(function(){// Copyright Joyent, Inc. and other Node contributors.
module.exports=Writable;// there will be only 2 of these for each stream
function CorkedRequest(state){var _this=this;this.next=null;this.entry=null;this.finish=function(){onCorkedFinish(_this,state);};}/* </replacement> */ /*<replacement>*/var Duplex;/*</replacement>*/Writable.WritableState=WritableState;/*<replacement>*/var internalUtil={deprecate:require('util-deprecate')};/*</replacement>*/ /*<replacement>*/var Stream=require('./internal/streams/stream');/*</replacement>*/var Buffer=require('buffer').Buffer;var OurUint8Array=global.Uint8Array||function(){};function _uint8ArrayToBuffer(chunk){return Buffer.from(chunk);}function _isUint8Array(obj){return Buffer.isBuffer(obj)||obj instanceof OurUint8Array;}var destroyImpl=require('./internal/streams/destroy');var _require=require('./internal/streams/state'),getHighWaterMark=_require.getHighWaterMark;var _require$codes=require('../errors').codes,ERR_INVALID_ARG_TYPE=_require$codes.ERR_INVALID_ARG_TYPE,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=_require$codes.ERR_MULTIPLE_CALLBACK,ERR_STREAM_CANNOT_PIPE=_require$codes.ERR_STREAM_CANNOT_PIPE,ERR_STREAM_DESTROYED=_require$codes.ERR_STREAM_DESTROYED,ERR_STREAM_NULL_VALUES=_require$codes.ERR_STREAM_NULL_VALUES,ERR_STREAM_WRITE_AFTER_END=_require$codes.ERR_STREAM_WRITE_AFTER_END,ERR_UNKNOWN_ENCODING=_require$codes.ERR_UNKNOWN_ENCODING;var errorOrDestroy=destroyImpl.errorOrDestroy;require('inherits')(Writable,Stream);function nop(){}function WritableState(options,stream,isDuplex){Duplex=Duplex||require('./_stream_duplex');options=options||{};// Duplex streams are both readable and writable, but share
// the same options object.
// However, some cases require setting options to different
// values for the readable and the writable sides of the duplex stream,
// e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
if(typeof isDuplex!=='boolean')isDuplex=stream instanceof Duplex;// object stream flag to indicate whether or not this stream
// contains buffers or objects.
this.objectMode=!!options.objectMode;if(isDuplex)this.objectMode=this.objectMode||!!options.writableObjectMode;// the point at which write() starts returning false
// Note: 0 is a valid value, means that we always return false if
// the entire buffer is not flushed immediately on write()
this.highWaterMark=getHighWaterMark(this,options,'writableHighWaterMark',isDuplex);// if _final has been called
this.finalCalled=false;// drain event flag.
this.needDrain=false;// at the start of calling end()
this.ending=false;// when end() has been called, and returned
this.ended=false;// when 'finish' is emitted
this.finished=false;// has it been destroyed
this.destroyed=false;// should we decode strings into buffers before passing to _write?
// this is here so that some node-core streams can optimize string
// handling at a lower level.
var noDecode=options.decodeStrings===false;this.decodeStrings=!noDecode;// Crypto is kind of old and crusty.  Historically, its default string
// encoding is 'binary' so we have to make this configurable.
// Everything else in the universe uses 'utf8', though.
this.defaultEncoding=options.defaultEncoding||'utf8';// not an actual buffer we keep track of, but a measurement
// of how much we're waiting to get pushed to some underlying
// socket or file.
this.length=0;// a flag to see when we're in the middle of a write.
this.writing=false;// when true all writes will be buffered until .uncork() call
this.corked=0;// a flag to be able to tell if the onwrite cb is called immediately,
// or on a later tick.  We set this to true at first, because any
// actions that shouldn't happen until "later" should generally also
// not happen before the first write call.
this.sync=true;// a flag to know if we're processing previously buffered items, which
// may call the _write() callback in the same tick, so that we don't
// end up in an overlapped onwrite situation.
this.bufferProcessing=false;// the callback that's passed to _write(chunk,cb)
this.onwrite=function(er){onwrite(stream,er);};// the callback that the user supplies to write(chunk,encoding,cb)
this.writecb=null;// the amount that is being written when _write is called.
this.writelen=0;this.bufferedRequest=null;this.lastBufferedRequest=null;// number of pending user-supplied write callbacks
// this must be 0 before 'finish' can be emitted
this.pendingcb=0;// emit prefinish if the only thing we're waiting for is _write cbs
// This is relevant for synchronous Transform streams
this.prefinished=false;// True if the error was already emitted and should not be thrown again
this.errorEmitted=false;// Should close be emitted on destroy. Defaults to true.
this.emitClose=options.emitClose!==false;// Should .destroy() be called after 'finish' (and potentially 'end')
this.autoDestroy=!!options.autoDestroy;// count buffered requests
this.bufferedRequestCount=0;// allocate the first CorkedRequest, there is always
// one allocated and free to use, and we maintain at most two
this.corkedRequestsFree=new CorkedRequest(this);}WritableState.prototype.getBuffer=function getBuffer(){var current=this.bufferedRequest;var out=[];while(current){out.push(current);current=current.next;}return out;};(function(){try{Object.defineProperty(WritableState.prototype,'buffer',{get:internalUtil.deprecate(function writableStateBufferGetter(){return this.getBuffer();},'_writableState.buffer is deprecated. Use _writableState.getBuffer '+'instead.','DEP0003')});}catch(_){}})();// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;if(typeof Symbol==='function'&&Symbol.hasInstance&&typeof Function.prototype[Symbol.hasInstance]==='function'){realHasInstance=Function.prototype[Symbol.hasInstance];Object.defineProperty(Writable,Symbol.hasInstance,{value:function value(object){if(realHasInstance.call(this,object))return true;if(this!==Writable)return false;return object&&object._writableState instanceof WritableState;}});}else {realHasInstance=function realHasInstance(object){return object instanceof this;};}function Writable(options){Duplex=Duplex||require('./_stream_duplex');// Writable ctor is applied to Duplexes, too.
// `realHasInstance` is necessary because using plain `instanceof`
// would return false, as no `_writableState` property is attached.
// Trying to use the custom `instanceof` for Writable here will also break the
// Node.js LazyTransform implementation, which has a non-trivial getter for
// `_writableState` that would lead to infinite recursion.
// Checking for a Stream.Duplex instance is faster here instead of inside
// the WritableState constructor, at least with V8 6.5
var isDuplex=this instanceof Duplex;if(!isDuplex&&!realHasInstance.call(Writable,this))return new Writable(options);this._writableState=new WritableState(options,this,isDuplex);// legacy.
this.writable=true;if(options){if(typeof options.write==='function')this._write=options.write;if(typeof options.writev==='function')this._writev=options.writev;if(typeof options.destroy==='function')this._destroy=options.destroy;if(typeof options["final"]==='function')this._final=options["final"];}Stream.call(this);}// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe=function(){errorOrDestroy(this,new ERR_STREAM_CANNOT_PIPE());};function writeAfterEnd(stream,cb){var er=new ERR_STREAM_WRITE_AFTER_END();// TODO: defer error events consistently everywhere, not just the cb
errorOrDestroy(stream,er);process.nextTick(cb,er);}// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream,state,chunk,cb){var er;if(chunk===null){er=new ERR_STREAM_NULL_VALUES();}else if(typeof chunk!=='string'&&!state.objectMode){er=new ERR_INVALID_ARG_TYPE('chunk',['string','Buffer'],chunk);}if(er){errorOrDestroy(stream,er);process.nextTick(cb,er);return false;}return true;}Writable.prototype.write=function(chunk,encoding,cb){var state=this._writableState;var ret=false;var isBuf=!state.objectMode&&_isUint8Array(chunk);if(isBuf&&!Buffer.isBuffer(chunk)){chunk=_uint8ArrayToBuffer(chunk);}if(typeof encoding==='function'){cb=encoding;encoding=null;}if(isBuf)encoding='buffer';else if(!encoding)encoding=state.defaultEncoding;if(typeof cb!=='function')cb=nop;if(state.ending)writeAfterEnd(this,cb);else if(isBuf||validChunk(this,state,chunk,cb)){state.pendingcb++;ret=writeOrBuffer(this,state,isBuf,chunk,encoding,cb);}return ret;};Writable.prototype.cork=function(){this._writableState.corked++;};Writable.prototype.uncork=function(){var state=this._writableState;if(state.corked){state.corked--;if(!state.writing&&!state.corked&&!state.bufferProcessing&&state.bufferedRequest)clearBuffer(this,state);}};Writable.prototype.setDefaultEncoding=function setDefaultEncoding(encoding){// node::ParseEncoding() requires lower case.
if(typeof encoding==='string')encoding=encoding.toLowerCase();if(!(['hex','utf8','utf-8','ascii','binary','base64','ucs2','ucs-2','utf16le','utf-16le','raw'].indexOf((encoding+'').toLowerCase())>-1))throw new ERR_UNKNOWN_ENCODING(encoding);this._writableState.defaultEncoding=encoding;return this;};Object.defineProperty(Writable.prototype,'writableBuffer',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState&&this._writableState.getBuffer();}});function decodeChunk(state,chunk,encoding){if(!state.objectMode&&state.decodeStrings!==false&&typeof chunk==='string'){chunk=Buffer.from(chunk,encoding);}return chunk;}Object.defineProperty(Writable.prototype,'writableHighWaterMark',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.highWaterMark;}});// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream,state,isBuf,chunk,encoding,cb){if(!isBuf){var newChunk=decodeChunk(state,chunk,encoding);if(chunk!==newChunk){isBuf=true;encoding='buffer';chunk=newChunk;}}var len=state.objectMode?1:chunk.length;state.length+=len;var ret=state.length<state.highWaterMark;// we must ensure that previous needDrain will not be reset to false.
if(!ret)state.needDrain=true;if(state.writing||state.corked){var last=state.lastBufferedRequest;state.lastBufferedRequest={chunk:chunk,encoding:encoding,isBuf:isBuf,callback:cb,next:null};if(last){last.next=state.lastBufferedRequest;}else {state.bufferedRequest=state.lastBufferedRequest;}state.bufferedRequestCount+=1;}else {doWrite(stream,state,false,len,chunk,encoding,cb);}return ret;}function doWrite(stream,state,writev,len,chunk,encoding,cb){state.writelen=len;state.writecb=cb;state.writing=true;state.sync=true;if(state.destroyed)state.onwrite(new ERR_STREAM_DESTROYED('write'));else if(writev)stream._writev(chunk,state.onwrite);else stream._write(chunk,encoding,state.onwrite);state.sync=false;}function onwriteError(stream,state,sync,er,cb){--state.pendingcb;if(sync){// defer the callback if we are being called synchronously
// to avoid piling up things on the stack
process.nextTick(cb,er);// this can emit finish, and it will always happen
// after error
process.nextTick(finishMaybe,stream,state);stream._writableState.errorEmitted=true;errorOrDestroy(stream,er);}else {// the caller expect this to happen before if
// it is async
cb(er);stream._writableState.errorEmitted=true;errorOrDestroy(stream,er);// this can emit finish, but finish must
// always follow error
finishMaybe(stream,state);}}function onwriteStateUpdate(state){state.writing=false;state.writecb=null;state.length-=state.writelen;state.writelen=0;}function onwrite(stream,er){var state=stream._writableState;var sync=state.sync;var cb=state.writecb;if(typeof cb!=='function')throw new ERR_MULTIPLE_CALLBACK();onwriteStateUpdate(state);if(er)onwriteError(stream,state,sync,er,cb);else {// Check if we're actually ready to finish, but don't emit yet
var finished=needFinish(state)||stream.destroyed;if(!finished&&!state.corked&&!state.bufferProcessing&&state.bufferedRequest){clearBuffer(stream,state);}if(sync){process.nextTick(afterWrite,stream,state,finished,cb);}else {afterWrite(stream,state,finished,cb);}}}function afterWrite(stream,state,finished,cb){if(!finished)onwriteDrain(stream,state);state.pendingcb--;cb();finishMaybe(stream,state);}// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream,state){if(state.length===0&&state.needDrain){state.needDrain=false;stream.emit('drain');}}// if there's something in the buffer waiting, then process it
function clearBuffer(stream,state){state.bufferProcessing=true;var entry=state.bufferedRequest;if(stream._writev&&entry&&entry.next){// Fast case, write everything using _writev()
var l=state.bufferedRequestCount;var buffer=new Array(l);var holder=state.corkedRequestsFree;holder.entry=entry;var count=0;var allBuffers=true;while(entry){buffer[count]=entry;if(!entry.isBuf)allBuffers=false;entry=entry.next;count+=1;}buffer.allBuffers=allBuffers;doWrite(stream,state,true,state.length,buffer,'',holder.finish);// doWrite is almost always async, defer these to save a bit of time
// as the hot path ends with doWrite
state.pendingcb++;state.lastBufferedRequest=null;if(holder.next){state.corkedRequestsFree=holder.next;holder.next=null;}else {state.corkedRequestsFree=new CorkedRequest(state);}state.bufferedRequestCount=0;}else {// Slow case, write chunks one-by-one
while(entry){var chunk=entry.chunk;var encoding=entry.encoding;var cb=entry.callback;var len=state.objectMode?1:chunk.length;doWrite(stream,state,false,len,chunk,encoding,cb);entry=entry.next;state.bufferedRequestCount--;// if we didn't call the onwrite immediately, then
// it means that we need to wait until it does.
// also, that means that the chunk and cb are currently
// being processed, so move the buffer counter past them.
if(state.writing){break;}}if(entry===null)state.lastBufferedRequest=null;}state.bufferedRequest=entry;state.bufferProcessing=false;}Writable.prototype._write=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));};Writable.prototype._writev=null;Writable.prototype.end=function(chunk,encoding,cb){var state=this._writableState;if(typeof chunk==='function'){cb=chunk;chunk=null;encoding=null;}else if(typeof encoding==='function'){cb=encoding;encoding=null;}if(chunk!==null&&chunk!==undefined)this.write(chunk,encoding);// .end() fully uncorks
if(state.corked){state.corked=1;this.uncork();}// ignore unnecessary end() calls.
if(!state.ending)endWritable(this,state,cb);return this;};Object.defineProperty(Writable.prototype,'writableLength',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){return this._writableState.length;}});function needFinish(state){return state.ending&&state.length===0&&state.bufferedRequest===null&&!state.finished&&!state.writing;}function callFinal(stream,state){stream._final(function(err){state.pendingcb--;if(err){errorOrDestroy(stream,err);}state.prefinished=true;stream.emit('prefinish');finishMaybe(stream,state);});}function prefinish(stream,state){if(!state.prefinished&&!state.finalCalled){if(typeof stream._final==='function'&&!state.destroyed){state.pendingcb++;state.finalCalled=true;process.nextTick(callFinal,stream,state);}else {state.prefinished=true;stream.emit('prefinish');}}}function finishMaybe(stream,state){var need=needFinish(state);if(need){prefinish(stream,state);if(state.pendingcb===0){state.finished=true;stream.emit('finish');if(state.autoDestroy){// In case of duplex streams we need a way to detect
// if the readable side is ready for autoDestroy as well
var rState=stream._readableState;if(!rState||rState.autoDestroy&&rState.endEmitted){stream.destroy();}}}}return need;}function endWritable(stream,state,cb){state.ending=true;finishMaybe(stream,state);if(cb){if(state.finished)process.nextTick(cb);else stream.once('finish',cb);}state.ended=true;stream.writable=false;}function onCorkedFinish(corkReq,state,err){var entry=corkReq.entry;corkReq.entry=null;while(entry){var cb=entry.callback;state.pendingcb--;cb(err);entry=entry.next;}// reuse the free corkReq.
state.corkedRequestsFree.next=corkReq;}Object.defineProperty(Writable.prototype,'destroyed',{// making it explicit this property is not enumerable
// because otherwise some prototype manipulation in
// userland will fail
enumerable:false,get:function get(){if(this._writableState===undefined){return false;}return this._writableState.destroyed;},set:function set(value){// we ignore the value if the stream
// has not been initialized yet
if(!this._writableState){return;}// backward compatibility, the user is explicitly
// managing destroyed
this._writableState.destroyed=value;}});Writable.prototype.destroy=destroyImpl.destroy;Writable.prototype._undestroy=destroyImpl.undestroy;Writable.prototype._destroy=function(err,cb){cb(err);};}).call(this);}).call(this,require('_process'),typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{"../errors":55,"./_stream_duplex":56,"./internal/streams/destroy":63,"./internal/streams/state":67,"./internal/streams/stream":68,"_process":50,"buffer":17,"inherits":24,"util-deprecate":78}],61:[function(require,module,exports){(function(process){(function(){var _Object$setPrototypeO;function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}var finished=require('./end-of-stream');var kLastResolve=Symbol('lastResolve');var kLastReject=Symbol('lastReject');var kError=Symbol('error');var kEnded=Symbol('ended');var kLastPromise=Symbol('lastPromise');var kHandlePromise=Symbol('handlePromise');var kStream=Symbol('stream');function createIterResult(value,done){return {value:value,done:done};}function readAndResolve(iter){var resolve=iter[kLastResolve];if(resolve!==null){var data=iter[kStream].read();// we defer if data is null
// we can be expecting either 'end' or
// 'error'
if(data!==null){iter[kLastPromise]=null;iter[kLastResolve]=null;iter[kLastReject]=null;resolve(createIterResult(data,false));}}}function onReadable(iter){// we wait for the next tick, because it might
// emit an error with process.nextTick
process.nextTick(readAndResolve,iter);}function wrapForNext(lastPromise,iter){return function(resolve,reject){lastPromise.then(function(){if(iter[kEnded]){resolve(createIterResult(undefined,true));return;}iter[kHandlePromise](resolve,reject);},reject);};}var AsyncIteratorPrototype=Object.getPrototypeOf(function(){});var ReadableStreamAsyncIteratorPrototype=Object.setPrototypeOf((_Object$setPrototypeO={get stream(){return this[kStream];},next:function next(){var _this=this;// if we have detected an error in the meanwhile
// reject straight away
var error=this[kError];if(error!==null){return Promise.reject(error);}if(this[kEnded]){return Promise.resolve(createIterResult(undefined,true));}if(this[kStream].destroyed){// We need to defer via nextTick because if .destroy(err) is
// called, the error will be emitted via nextTick, and
// we cannot guarantee that there is no error lingering around
// waiting to be emitted.
return new Promise(function(resolve,reject){process.nextTick(function(){if(_this[kError]){reject(_this[kError]);}else {resolve(createIterResult(undefined,true));}});});}// if we have multiple next() calls
// we will wait for the previous Promise to finish
// this logic is optimized to support for await loops,
// where next() is only called once at a time
var lastPromise=this[kLastPromise];var promise;if(lastPromise){promise=new Promise(wrapForNext(lastPromise,this));}else {// fast path needed to support multiple this.push()
// without triggering the next() queue
var data=this[kStream].read();if(data!==null){return Promise.resolve(createIterResult(data,false));}promise=new Promise(this[kHandlePromise]);}this[kLastPromise]=promise;return promise;}},_defineProperty(_Object$setPrototypeO,Symbol.asyncIterator,function(){return this;}),_defineProperty(_Object$setPrototypeO,"return",function _return(){var _this2=this;// destroy(err, cb) is a private API
// we can guarantee we have that here, because we control the
// Readable class this is attached to
return new Promise(function(resolve,reject){_this2[kStream].destroy(null,function(err){if(err){reject(err);return;}resolve(createIterResult(undefined,true));});});}),_Object$setPrototypeO),AsyncIteratorPrototype);var createReadableStreamAsyncIterator=function createReadableStreamAsyncIterator(stream){var _Object$create;var iterator=Object.create(ReadableStreamAsyncIteratorPrototype,(_Object$create={},_defineProperty(_Object$create,kStream,{value:stream,writable:true}),_defineProperty(_Object$create,kLastResolve,{value:null,writable:true}),_defineProperty(_Object$create,kLastReject,{value:null,writable:true}),_defineProperty(_Object$create,kError,{value:null,writable:true}),_defineProperty(_Object$create,kEnded,{value:stream._readableState.endEmitted,writable:true}),_defineProperty(_Object$create,kHandlePromise,{value:function value(resolve,reject){var data=iterator[kStream].read();if(data){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;resolve(createIterResult(data,false));}else {iterator[kLastResolve]=resolve;iterator[kLastReject]=reject;}},writable:true}),_Object$create));iterator[kLastPromise]=null;finished(stream,function(err){if(err&&err.code!=='ERR_STREAM_PREMATURE_CLOSE'){var reject=iterator[kLastReject];// reject if we are waiting for data in the Promise
// returned by next() and store the error
if(reject!==null){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;reject(err);}iterator[kError]=err;return;}var resolve=iterator[kLastResolve];if(resolve!==null){iterator[kLastPromise]=null;iterator[kLastResolve]=null;iterator[kLastReject]=null;resolve(createIterResult(undefined,true));}iterator[kEnded]=true;});stream.on('readable',onReadable.bind(null,iterator));return iterator;};module.exports=createReadableStreamAsyncIterator;}).call(this);}).call(this,require('_process'));},{"./end-of-stream":64,"_process":50}],62:[function(require,module,exports){function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else {ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else {obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}var _require=require('buffer'),Buffer=_require.Buffer;var _require2=require('util'),inspect=_require2.inspect;var custom=inspect&&inspect.custom||'inspect';function copyBuffer(src,target,offset){Buffer.prototype.copy.call(src,target,offset);}module.exports=/*#__PURE__*/function(){function BufferList(){_classCallCheck(this,BufferList);this.head=null;this.tail=null;this.length=0;}_createClass(BufferList,[{key:"push",value:function push(v){var entry={data:v,next:null};if(this.length>0)this.tail.next=entry;else this.head=entry;this.tail=entry;++this.length;}},{key:"unshift",value:function unshift(v){var entry={data:v,next:this.head};if(this.length===0)this.tail=entry;this.head=entry;++this.length;}},{key:"shift",value:function shift(){if(this.length===0)return;var ret=this.head.data;if(this.length===1)this.head=this.tail=null;else this.head=this.head.next;--this.length;return ret;}},{key:"clear",value:function clear(){this.head=this.tail=null;this.length=0;}},{key:"join",value:function join(s){if(this.length===0)return '';var p=this.head;var ret=''+p.data;while(p=p.next){ret+=s+p.data;}return ret;}},{key:"concat",value:function concat(n){if(this.length===0)return Buffer.alloc(0);var ret=Buffer.allocUnsafe(n>>>0);var p=this.head;var i=0;while(p){copyBuffer(p.data,ret,i);i+=p.data.length;p=p.next;}return ret;}// Consumes a specified amount of bytes or characters from the buffered data.
},{key:"consume",value:function consume(n,hasStrings){var ret;if(n<this.head.data.length){// `slice` is the same for buffers and strings.
ret=this.head.data.slice(0,n);this.head.data=this.head.data.slice(n);}else if(n===this.head.data.length){// First chunk is a perfect match.
ret=this.shift();}else {// Result spans more than one buffer.
ret=hasStrings?this._getString(n):this._getBuffer(n);}return ret;}},{key:"first",value:function first(){return this.head.data;}// Consumes a specified amount of characters from the buffered data.
},{key:"_getString",value:function _getString(n){var p=this.head;var c=1;var ret=p.data;n-=ret.length;while(p=p.next){var str=p.data;var nb=n>str.length?str.length:n;if(nb===str.length)ret+=str;else ret+=str.slice(0,n);n-=nb;if(n===0){if(nb===str.length){++c;if(p.next)this.head=p.next;else this.head=this.tail=null;}else {this.head=p;p.data=str.slice(nb);}break;}++c;}this.length-=c;return ret;}// Consumes a specified amount of bytes from the buffered data.
},{key:"_getBuffer",value:function _getBuffer(n){var ret=Buffer.allocUnsafe(n);var p=this.head;var c=1;p.data.copy(ret);n-=p.data.length;while(p=p.next){var buf=p.data;var nb=n>buf.length?buf.length:n;buf.copy(ret,ret.length-n,0,nb);n-=nb;if(n===0){if(nb===buf.length){++c;if(p.next)this.head=p.next;else this.head=this.tail=null;}else {this.head=p;p.data=buf.slice(nb);}break;}++c;}this.length-=c;return ret;}// Make sure the linked list only shows the minimal necessary information.
},{key:custom,value:function value(_,options){return inspect(this,_objectSpread({},options,{// Only inspect one level.
depth:0,// It should not recurse.
customInspect:false}));}}]);return BufferList;}();},{"buffer":17,"util":16}],63:[function(require,module,exports){(function(process){(function(){function destroy(err,cb){var _this=this;var readableDestroyed=this._readableState&&this._readableState.destroyed;var writableDestroyed=this._writableState&&this._writableState.destroyed;if(readableDestroyed||writableDestroyed){if(cb){cb(err);}else if(err){if(!this._writableState){process.nextTick(emitErrorNT,this,err);}else if(!this._writableState.errorEmitted){this._writableState.errorEmitted=true;process.nextTick(emitErrorNT,this,err);}}return this;}// we set destroyed to true before firing error callbacks in order
// to make it re-entrance safe in case destroy() is called within callbacks
if(this._readableState){this._readableState.destroyed=true;}// if this is a duplex stream mark the writable part as destroyed as well
if(this._writableState){this._writableState.destroyed=true;}this._destroy(err||null,function(err){if(!cb&&err){if(!_this._writableState){process.nextTick(emitErrorAndCloseNT,_this,err);}else if(!_this._writableState.errorEmitted){_this._writableState.errorEmitted=true;process.nextTick(emitErrorAndCloseNT,_this,err);}else {process.nextTick(emitCloseNT,_this);}}else if(cb){process.nextTick(emitCloseNT,_this);cb(err);}else {process.nextTick(emitCloseNT,_this);}});return this;}function emitErrorAndCloseNT(self,err){emitErrorNT(self,err);emitCloseNT(self);}function emitCloseNT(self){if(self._writableState&&!self._writableState.emitClose)return;if(self._readableState&&!self._readableState.emitClose)return;self.emit('close');}function undestroy(){if(this._readableState){this._readableState.destroyed=false;this._readableState.reading=false;this._readableState.ended=false;this._readableState.endEmitted=false;}if(this._writableState){this._writableState.destroyed=false;this._writableState.ended=false;this._writableState.ending=false;this._writableState.finalCalled=false;this._writableState.prefinished=false;this._writableState.finished=false;this._writableState.errorEmitted=false;}}function emitErrorNT(self,err){self.emit('error',err);}function errorOrDestroy(stream,err){// We have tests that rely on errors being emitted
// in the same tick, so changing this is semver major.
// For now when you opt-in to autoDestroy we allow
// the error to be emitted nextTick. In a future
// semver major update we should change the default to this.
var rState=stream._readableState;var wState=stream._writableState;if(rState&&rState.autoDestroy||wState&&wState.autoDestroy)stream.destroy(err);else stream.emit('error',err);}module.exports={destroy:destroy,undestroy:undestroy,errorOrDestroy:errorOrDestroy};}).call(this);}).call(this,require('_process'));},{"_process":50}],64:[function(require,module,exports){// Ported from https://github.com/mafintosh/end-of-stream with
var ERR_STREAM_PREMATURE_CLOSE=require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;function once(callback){var called=false;return function(){if(called)return;called=true;for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}callback.apply(this,args);};}function noop(){}function isRequest(stream){return stream.setHeader&&typeof stream.abort==='function';}function eos(stream,opts,callback){if(typeof opts==='function')return eos(stream,null,opts);if(!opts)opts={};callback=once(callback||noop);var readable=opts.readable||opts.readable!==false&&stream.readable;var writable=opts.writable||opts.writable!==false&&stream.writable;var onlegacyfinish=function onlegacyfinish(){if(!stream.writable)onfinish();};var writableEnded=stream._writableState&&stream._writableState.finished;var onfinish=function onfinish(){writable=false;writableEnded=true;if(!readable)callback.call(stream);};var readableEnded=stream._readableState&&stream._readableState.endEmitted;var onend=function onend(){readable=false;readableEnded=true;if(!writable)callback.call(stream);};var onerror=function onerror(err){callback.call(stream,err);};var onclose=function onclose(){var err;if(readable&&!readableEnded){if(!stream._readableState||!stream._readableState.ended)err=new ERR_STREAM_PREMATURE_CLOSE();return callback.call(stream,err);}if(writable&&!writableEnded){if(!stream._writableState||!stream._writableState.ended)err=new ERR_STREAM_PREMATURE_CLOSE();return callback.call(stream,err);}};var onrequest=function onrequest(){stream.req.on('finish',onfinish);};if(isRequest(stream)){stream.on('complete',onfinish);stream.on('abort',onclose);if(stream.req)onrequest();else stream.on('request',onrequest);}else if(writable&&!stream._writableState){// legacy streams
stream.on('end',onlegacyfinish);stream.on('close',onlegacyfinish);}stream.on('end',onend);stream.on('finish',onfinish);if(opts.error!==false)stream.on('error',onerror);stream.on('close',onclose);return function(){stream.removeListener('complete',onfinish);stream.removeListener('abort',onclose);stream.removeListener('request',onrequest);if(stream.req)stream.req.removeListener('finish',onfinish);stream.removeListener('end',onlegacyfinish);stream.removeListener('close',onlegacyfinish);stream.removeListener('finish',onfinish);stream.removeListener('end',onend);stream.removeListener('error',onerror);stream.removeListener('close',onclose);};}module.exports=eos;},{"../../../errors":55}],65:[function(require,module,exports){module.exports=function(){throw new Error('Readable.from is not available in the browser');};},{}],66:[function(require,module,exports){// Ported from https://github.com/mafintosh/pump with
var eos;function once(callback){var called=false;return function(){if(called)return;called=true;callback.apply(void 0,arguments);};}var _require$codes=require('../../../errors').codes,ERR_MISSING_ARGS=_require$codes.ERR_MISSING_ARGS,ERR_STREAM_DESTROYED=_require$codes.ERR_STREAM_DESTROYED;function noop(err){// Rethrow the error if it exists to avoid swallowing it
if(err)throw err;}function isRequest(stream){return stream.setHeader&&typeof stream.abort==='function';}function destroyer(stream,reading,writing,callback){callback=once(callback);var closed=false;stream.on('close',function(){closed=true;});if(eos===undefined)eos=require('./end-of-stream');eos(stream,{readable:reading,writable:writing},function(err){if(err)return callback(err);closed=true;callback();});var destroyed=false;return function(err){if(closed)return;if(destroyed)return;destroyed=true;// request.destroy just do .end - .abort is what we want
if(isRequest(stream))return stream.abort();if(typeof stream.destroy==='function')return stream.destroy();callback(err||new ERR_STREAM_DESTROYED('pipe'));};}function call(fn){fn();}function pipe(from,to){return from.pipe(to);}function popCallback(streams){if(!streams.length)return noop;if(typeof streams[streams.length-1]!=='function')return noop;return streams.pop();}function pipeline(){for(var _len=arguments.length,streams=new Array(_len),_key=0;_key<_len;_key++){streams[_key]=arguments[_key];}var callback=popCallback(streams);if(Array.isArray(streams[0]))streams=streams[0];if(streams.length<2){throw new ERR_MISSING_ARGS('streams');}var error;var destroys=streams.map(function(stream,i){var reading=i<streams.length-1;var writing=i>0;return destroyer(stream,reading,writing,function(err){if(!error)error=err;if(err)destroys.forEach(call);if(reading)return;destroys.forEach(call);callback(error);});});return streams.reduce(pipe);}module.exports=pipeline;},{"../../../errors":55,"./end-of-stream":64}],67:[function(require,module,exports){var ERR_INVALID_OPT_VALUE=require('../../../errors').codes.ERR_INVALID_OPT_VALUE;function highWaterMarkFrom(options,isDuplex,duplexKey){return options.highWaterMark!=null?options.highWaterMark:isDuplex?options[duplexKey]:null;}function getHighWaterMark(state,options,duplexKey,isDuplex){var hwm=highWaterMarkFrom(options,isDuplex,duplexKey);if(hwm!=null){if(!(isFinite(hwm)&&Math.floor(hwm)===hwm)||hwm<0){var name=isDuplex?duplexKey:'highWaterMark';throw new ERR_INVALID_OPT_VALUE(name,hwm);}return Math.floor(hwm);}// Default value
return state.objectMode?16:16*1024;}module.exports={getHighWaterMark:getHighWaterMark};},{"../../../errors":55}],68:[function(require,module,exports){module.exports=require('events').EventEmitter;},{"events":22}],69:[function(require,module,exports){exports=module.exports=require('./lib/_stream_readable.js');exports.Stream=exports;exports.Readable=exports;exports.Writable=require('./lib/_stream_writable.js');exports.Duplex=require('./lib/_stream_duplex.js');exports.Transform=require('./lib/_stream_transform.js');exports.PassThrough=require('./lib/_stream_passthrough.js');exports.finished=require('./lib/internal/streams/end-of-stream.js');exports.pipeline=require('./lib/internal/streams/pipeline.js');},{"./lib/_stream_duplex.js":56,"./lib/_stream_passthrough.js":57,"./lib/_stream_readable.js":58,"./lib/_stream_transform.js":59,"./lib/_stream_writable.js":60,"./lib/internal/streams/end-of-stream.js":64,"./lib/internal/streams/pipeline.js":66}],70:[function(require,module,exports){function ReInterval(callback,interval,args){var self=this;this._callback=callback;this._args=args;this._interval=setInterval(callback,interval,this._args);this.reschedule=function(interval){// if no interval entered, use the interval passed in on creation
if(!interval)interval=self._interval;if(self._interval)clearInterval(self._interval);self._interval=setInterval(self._callback,interval,self._args);};this.clear=function(){if(self._interval){clearInterval(self._interval);self._interval=undefined;}};this.destroy=function(){if(self._interval){clearInterval(self._interval);}self._callback=undefined;self._interval=undefined;self._args=undefined;};}function reInterval(){if(typeof arguments[0]!=='function')throw new Error('callback needed');if(typeof arguments[1]!=='number')throw new Error('interval needed');var args;if(arguments.length>0){args=new Array(arguments.length-2);for(var i=0;i<args.length;i++){args[i]=arguments[i+2];}}return new ReInterval(arguments[0],arguments[1],args);}module.exports=reInterval;},{}],71:[function(require,module,exports){module.exports=require('./index.js')();},{"./index.js":72}],72:[function(require,module,exports){(function(Buffer){(function(){module.exports=rfdc;function copyBuffer(cur){if(cur instanceof Buffer){return Buffer.from(cur);}return new cur.constructor(cur.buffer.slice(),cur.byteOffset,cur.length);}function rfdc(opts){opts=opts||{};if(opts.circles)return rfdcCircles(opts);return opts.proto?cloneProto:clone;function cloneArray(a,fn){var keys=Object.keys(a);var a2=new Array(keys.length);for(var i=0;i<keys.length;i++){var k=keys[i];var cur=a[k];if(_typeof(cur)!=='object'||cur===null){a2[k]=cur;}else if(cur instanceof Date){a2[k]=new Date(cur);}else if(ArrayBuffer.isView(cur)){a2[k]=copyBuffer(cur);}else {a2[k]=fn(cur);}}return a2;}function clone(o){if(_typeof(o)!=='object'||o===null)return o;if(o instanceof Date)return new Date(o);if(Array.isArray(o))return cloneArray(o,clone);if(o instanceof Map)return new Map(cloneArray(Array.from(o),clone));if(o instanceof Set)return new Set(cloneArray(Array.from(o),clone));var o2={};for(var k in o){if(Object.hasOwnProperty.call(o,k)===false)continue;var cur=o[k];if(_typeof(cur)!=='object'||cur===null){o2[k]=cur;}else if(cur instanceof Date){o2[k]=new Date(cur);}else if(cur instanceof Map){o2[k]=new Map(cloneArray(Array.from(cur),clone));}else if(cur instanceof Set){o2[k]=new Set(cloneArray(Array.from(cur),clone));}else if(ArrayBuffer.isView(cur)){o2[k]=copyBuffer(cur);}else {o2[k]=clone(cur);}}return o2;}function cloneProto(o){if(_typeof(o)!=='object'||o===null)return o;if(o instanceof Date)return new Date(o);if(Array.isArray(o))return cloneArray(o,cloneProto);if(o instanceof Map)return new Map(cloneArray(Array.from(o),cloneProto));if(o instanceof Set)return new Set(cloneArray(Array.from(o),cloneProto));var o2={};for(var k in o){var cur=o[k];if(_typeof(cur)!=='object'||cur===null){o2[k]=cur;}else if(cur instanceof Date){o2[k]=new Date(cur);}else if(cur instanceof Map){o2[k]=new Map(cloneArray(Array.from(cur),cloneProto));}else if(cur instanceof Set){o2[k]=new Set(cloneArray(Array.from(cur),cloneProto));}else if(ArrayBuffer.isView(cur)){o2[k]=copyBuffer(cur);}else {o2[k]=cloneProto(cur);}}return o2;}}function rfdcCircles(opts){var refs=[];var refsNew=[];return opts.proto?cloneProto:clone;function cloneArray(a,fn){var keys=Object.keys(a);var a2=new Array(keys.length);for(var i=0;i<keys.length;i++){var k=keys[i];var cur=a[k];if(_typeof(cur)!=='object'||cur===null){a2[k]=cur;}else if(cur instanceof Date){a2[k]=new Date(cur);}else if(ArrayBuffer.isView(cur)){a2[k]=copyBuffer(cur);}else {var index=refs.indexOf(cur);if(index!==-1){a2[k]=refsNew[index];}else {a2[k]=fn(cur);}}}return a2;}function clone(o){if(_typeof(o)!=='object'||o===null)return o;if(o instanceof Date)return new Date(o);if(Array.isArray(o))return cloneArray(o,clone);if(o instanceof Map)return new Map(cloneArray(Array.from(o),clone));if(o instanceof Set)return new Set(cloneArray(Array.from(o),clone));var o2={};refs.push(o);refsNew.push(o2);for(var k in o){if(Object.hasOwnProperty.call(o,k)===false)continue;var cur=o[k];if(_typeof(cur)!=='object'||cur===null){o2[k]=cur;}else if(cur instanceof Date){o2[k]=new Date(cur);}else if(cur instanceof Map){o2[k]=new Map(cloneArray(Array.from(cur),clone));}else if(cur instanceof Set){o2[k]=new Set(cloneArray(Array.from(cur),clone));}else if(ArrayBuffer.isView(cur)){o2[k]=copyBuffer(cur);}else {var i=refs.indexOf(cur);if(i!==-1){o2[k]=refsNew[i];}else {o2[k]=clone(cur);}}}refs.pop();refsNew.pop();return o2;}function cloneProto(o){if(_typeof(o)!=='object'||o===null)return o;if(o instanceof Date)return new Date(o);if(Array.isArray(o))return cloneArray(o,cloneProto);if(o instanceof Map)return new Map(cloneArray(Array.from(o),cloneProto));if(o instanceof Set)return new Set(cloneArray(Array.from(o),cloneProto));var o2={};refs.push(o);refsNew.push(o2);for(var k in o){var cur=o[k];if(_typeof(cur)!=='object'||cur===null){o2[k]=cur;}else if(cur instanceof Date){o2[k]=new Date(cur);}else if(cur instanceof Map){o2[k]=new Map(cloneArray(Array.from(cur),cloneProto));}else if(cur instanceof Set){o2[k]=new Set(cloneArray(Array.from(cur),cloneProto));}else if(ArrayBuffer.isView(cur)){o2[k]=copyBuffer(cur);}else {var i=refs.indexOf(cur);if(i!==-1){o2[k]=refsNew[i];}else {o2[k]=cloneProto(cur);}}}refs.pop();refsNew.pop();return o2;}}}).call(this);}).call(this,require("buffer").Buffer);},{"buffer":17}],73:[function(require,module,exports){/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */var buffer=require('buffer');var Buffer=buffer.Buffer;// alternative to using Object.keys for old browsers
function copyProps(src,dst){for(var key in src){dst[key]=src[key];}}if(Buffer.from&&Buffer.alloc&&Buffer.allocUnsafe&&Buffer.allocUnsafeSlow){module.exports=buffer;}else {// Copy properties from require('buffer')
copyProps(buffer,exports);exports.Buffer=SafeBuffer;}function SafeBuffer(arg,encodingOrOffset,length){return Buffer(arg,encodingOrOffset,length);}SafeBuffer.prototype=Object.create(Buffer.prototype);// Copy static methods from Buffer
copyProps(Buffer,SafeBuffer);SafeBuffer.from=function(arg,encodingOrOffset,length){if(typeof arg==='number'){throw new TypeError('Argument must not be a number');}return Buffer(arg,encodingOrOffset,length);};SafeBuffer.alloc=function(size,fill,encoding){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}var buf=Buffer(size);if(fill!==undefined){if(typeof encoding==='string'){buf.fill(fill,encoding);}else {buf.fill(fill);}}else {buf.fill(0);}return buf;};SafeBuffer.allocUnsafe=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return Buffer(size);};SafeBuffer.allocUnsafeSlow=function(size){if(typeof size!=='number'){throw new TypeError('Argument must be a number');}return buffer.SlowBuffer(size);};},{"buffer":17}],74:[function(require,module,exports){module.exports=shift;function shift(stream){var rs=stream._readableState;if(!rs)return null;return rs.objectMode||typeof stream._duplexState==='number'?stream.read():stream.read(getStateLength(rs));}function getStateLength(state){if(state.buffer.length){// Since node 6.3.0 state.buffer is a BufferList not an array
if(state.buffer.head){return state.buffer.head.data.length;}return state.buffer[0].length;}return state.length;}},{}],75:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
/*<replacement>*/var Buffer=require('safe-buffer').Buffer;/*</replacement>*/var isEncoding=Buffer.isEncoding||function(encoding){encoding=''+encoding;switch(encoding&&encoding.toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':case'raw':return true;default:return false;}};function _normalizeEncoding(enc){if(!enc)return 'utf8';var retried;while(true){switch(enc){case'utf8':case'utf-8':return 'utf8';case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return 'utf16le';case'latin1':case'binary':return 'latin1';case'base64':case'ascii':case'hex':return enc;default:if(retried)return;// undefined
enc=(''+enc).toLowerCase();retried=true;}}}// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc){var nenc=_normalizeEncoding(enc);if(typeof nenc!=='string'&&(Buffer.isEncoding===isEncoding||!isEncoding(enc)))throw new Error('Unknown encoding: '+enc);return nenc||enc;}// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder=StringDecoder;function StringDecoder(encoding){this.encoding=normalizeEncoding(encoding);var nb;switch(this.encoding){case'utf16le':this.text=utf16Text;this.end=utf16End;nb=4;break;case'utf8':this.fillLast=utf8FillLast;nb=4;break;case'base64':this.text=base64Text;this.end=base64End;nb=3;break;default:this.write=simpleWrite;this.end=simpleEnd;return;}this.lastNeed=0;this.lastTotal=0;this.lastChar=Buffer.allocUnsafe(nb);}StringDecoder.prototype.write=function(buf){if(buf.length===0)return '';var r;var i;if(this.lastNeed){r=this.fillLast(buf);if(r===undefined)return '';i=this.lastNeed;this.lastNeed=0;}else {i=0;}if(i<buf.length)return r?r+this.text(buf,i):this.text(buf,i);return r||'';};StringDecoder.prototype.end=utf8End;// Returns only complete characters in a Buffer
StringDecoder.prototype.text=utf8Text;// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast=function(buf){if(this.lastNeed<=buf.length){buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,this.lastTotal-this.lastNeed,0,buf.length);this.lastNeed-=buf.length;};// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(_byte){if(_byte<=0x7F)return 0;else if(_byte>>5===0x06)return 2;else if(_byte>>4===0x0E)return 3;else if(_byte>>3===0x1E)return 4;return _byte>>6===0x02?-1:-2;}// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self,buf,i){var j=buf.length-1;if(j<i)return 0;var nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-1;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0)self.lastNeed=nb-2;return nb;}if(--j<i||nb===-2)return 0;nb=utf8CheckByte(buf[j]);if(nb>=0){if(nb>0){if(nb===2)nb=0;else self.lastNeed=nb-3;}return nb;}return 0;}// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self,buf,p){if((buf[0]&0xC0)!==0x80){self.lastNeed=0;return "\uFFFD";}if(self.lastNeed>1&&buf.length>1){if((buf[1]&0xC0)!==0x80){self.lastNeed=1;return "\uFFFD";}if(self.lastNeed>2&&buf.length>2){if((buf[2]&0xC0)!==0x80){self.lastNeed=2;return "\uFFFD";}}}}// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf){var p=this.lastTotal-this.lastNeed;var r=utf8CheckExtraBytes(this,buf);if(r!==undefined)return r;if(this.lastNeed<=buf.length){buf.copy(this.lastChar,p,0,this.lastNeed);return this.lastChar.toString(this.encoding,0,this.lastTotal);}buf.copy(this.lastChar,p,0,buf.length);this.lastNeed-=buf.length;}// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf,i){var total=utf8CheckIncomplete(this,buf,i);if(!this.lastNeed)return buf.toString('utf8',i);this.lastTotal=total;var end=buf.length-(total-this.lastNeed);buf.copy(this.lastChar,0,end);return buf.toString('utf8',i,end);}// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+"\uFFFD";return r;}// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf,i){if((buf.length-i)%2===0){var r=buf.toString('utf16le',i);if(r){var c=r.charCodeAt(r.length-1);if(c>=0xD800&&c<=0xDBFF){this.lastNeed=2;this.lastTotal=4;this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];return r.slice(0,-1);}}return r;}this.lastNeed=1;this.lastTotal=2;this.lastChar[0]=buf[buf.length-1];return buf.toString('utf16le',i,buf.length-1);}// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed){var end=this.lastTotal-this.lastNeed;return r+this.lastChar.toString('utf16le',0,end);}return r;}function base64Text(buf,i){var n=(buf.length-i)%3;if(n===0)return buf.toString('base64',i);this.lastNeed=3-n;this.lastTotal=3;if(n===1){this.lastChar[0]=buf[buf.length-1];}else {this.lastChar[0]=buf[buf.length-2];this.lastChar[1]=buf[buf.length-1];}return buf.toString('base64',i,buf.length-n);}function base64End(buf){var r=buf&&buf.length?this.write(buf):'';if(this.lastNeed)return r+this.lastChar.toString('base64',0,3-this.lastNeed);return r;}// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf){return buf.toString(this.encoding);}function simpleEnd(buf){return buf&&buf.length?this.write(buf):'';}},{"safe-buffer":73}],76:[function(require,module,exports){// Copyright Joyent, Inc. and other Node contributors.
var punycode=require('punycode');var util=require('./util');exports.parse=urlParse;exports.resolve=urlResolve;exports.resolveObject=urlResolveObject;exports.format=urlFormat;exports.Url=Url;function Url(){this.protocol=null;this.slashes=null;this.auth=null;this.host=null;this.port=null;this.hostname=null;this.hash=null;this.search=null;this.query=null;this.pathname=null;this.path=null;this.href=null;}// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,// Special case for a simple path URL
simplePathPattern=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims=['<','>','"','`',' ','\r','\n','\t'],// RFC 2396: characters not allowed for various reasons.
unwise=['{','}','|','\\','^','`'].concat(delims),// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape=['\''].concat(unwise),// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars=['%','/','?',';','#'].concat(autoEscape),hostEndingChars=['/','?','#'],hostnameMaxLen=255,hostnamePartPattern=/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol={'javascript':true,'javascript:':true},// protocols that never have a hostname.
hostlessProtocol={'javascript':true,'javascript:':true},// protocols that always contain a // bit.
slashedProtocol={'http':true,'https':true,'ftp':true,'gopher':true,'file':true,'http:':true,'https:':true,'ftp:':true,'gopher:':true,'file:':true},querystring=require('querystring');function urlParse(url,parseQueryString,slashesDenoteHost){if(url&&util.isObject(url)&&url instanceof Url)return url;var u=new Url();u.parse(url,parseQueryString,slashesDenoteHost);return u;}Url.prototype.parse=function(url,parseQueryString,slashesDenoteHost){if(!util.isString(url)){throw new TypeError("Parameter 'url' must be a string, not "+_typeof(url));}// Copy chrome, IE, opera backslash-handling behavior.
// Back slashes before the query string get converted to forward slashes
// See: https://code.google.com/p/chromium/issues/detail?id=25916
var queryIndex=url.indexOf('?'),splitter=queryIndex!==-1&&queryIndex<url.indexOf('#')?'?':'#',uSplit=url.split(splitter),slashRegex=/\\/g;uSplit[0]=uSplit[0].replace(slashRegex,'/');url=uSplit.join(splitter);var rest=url;// trim before proceeding.
// This is to support parse stuff like "  http://foo.com  \n"
rest=rest.trim();if(!slashesDenoteHost&&url.split('#').length===1){// Try fast path regexp
var simplePath=simplePathPattern.exec(rest);if(simplePath){this.path=rest;this.href=rest;this.pathname=simplePath[1];if(simplePath[2]){this.search=simplePath[2];if(parseQueryString){this.query=querystring.parse(this.search.substr(1));}else {this.query=this.search.substr(1);}}else if(parseQueryString){this.search='';this.query={};}return this;}}var proto=protocolPattern.exec(rest);if(proto){proto=proto[0];var lowerProto=proto.toLowerCase();this.protocol=lowerProto;rest=rest.substr(proto.length);}// figure out if it's got a host
// user@server is *always* interpreted as a hostname, and url
// resolution will treat //foo/bar as host=foo,path=bar because that's
// how the browser resolves relative URLs.
if(slashesDenoteHost||proto||rest.match(/^\/\/[^@\/]+@[^@\/]+/)){var slashes=rest.substr(0,2)==='//';if(slashes&&!(proto&&hostlessProtocol[proto])){rest=rest.substr(2);this.slashes=true;}}if(!hostlessProtocol[proto]&&(slashes||proto&&!slashedProtocol[proto])){// there's a hostname.
// the first instance of /, ?, ;, or # ends the host.
//
// If there is an @ in the hostname, then non-host chars *are* allowed
// to the left of the last @ sign, unless some host-ending character
// comes *before* the @-sign.
// URLs are obnoxious.
//
// ex:
// http://a@b@c/ => user:a@b host:c
// http://a@b?@c => user:a host:c path:/?@c
// v0.12 TODO(isaacs): This is not quite how Chrome does things.
// Review our test case against browsers more comprehensively.
// find the first instance of any hostEndingChars
var hostEnd=-1;for(var i=0;i<hostEndingChars.length;i++){var hec=rest.indexOf(hostEndingChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// at this point, either we have an explicit point where the
// auth portion cannot go past, or the last @ char is the decider.
var auth,atSign;if(hostEnd===-1){// atSign can be anywhere.
atSign=rest.lastIndexOf('@');}else {// atSign must be in auth portion.
// http://a@b/c@d => host:b auth:a path:/c@d
atSign=rest.lastIndexOf('@',hostEnd);}// Now we have a portion which is definitely the auth.
// Pull that off.
if(atSign!==-1){auth=rest.slice(0,atSign);rest=rest.slice(atSign+1);this.auth=decodeURIComponent(auth);}// the host is the remaining to the left of the first non-host char
hostEnd=-1;for(var i=0;i<nonHostChars.length;i++){var hec=rest.indexOf(nonHostChars[i]);if(hec!==-1&&(hostEnd===-1||hec<hostEnd))hostEnd=hec;}// if we still have not hit it, then the entire thing is a host.
if(hostEnd===-1)hostEnd=rest.length;this.host=rest.slice(0,hostEnd);rest=rest.slice(hostEnd);// pull out port.
this.parseHost();// we've indicated that there is a hostname,
// so even if it's empty, it has to be present.
this.hostname=this.hostname||'';// if hostname begins with [ and ends with ]
// assume that it's an IPv6 address.
var ipv6Hostname=this.hostname[0]==='['&&this.hostname[this.hostname.length-1]===']';// validate a little.
if(!ipv6Hostname){var hostparts=this.hostname.split(/\./);for(var i=0,l=hostparts.length;i<l;i++){var part=hostparts[i];if(!part)continue;if(!part.match(hostnamePartPattern)){var newpart='';for(var j=0,k=part.length;j<k;j++){if(part.charCodeAt(j)>127){// we replace non-ASCII char with a temporary placeholder
// we need this to make sure size of hostname is not
// broken by replacing non-ASCII by nothing
newpart+='x';}else {newpart+=part[j];}}// we test again with ASCII char only
if(!newpart.match(hostnamePartPattern)){var validParts=hostparts.slice(0,i);var notHost=hostparts.slice(i+1);var bit=part.match(hostnamePartStart);if(bit){validParts.push(bit[1]);notHost.unshift(bit[2]);}if(notHost.length){rest='/'+notHost.join('.')+rest;}this.hostname=validParts.join('.');break;}}}}if(this.hostname.length>hostnameMaxLen){this.hostname='';}else {// hostnames are always lower case.
this.hostname=this.hostname.toLowerCase();}if(!ipv6Hostname){// IDNA Support: Returns a punycoded representation of "domain".
// It only converts parts of the domain name that
// have non-ASCII characters, i.e. it doesn't matter if
// you call it with a domain that already is ASCII-only.
this.hostname=punycode.toASCII(this.hostname);}var p=this.port?':'+this.port:'';var h=this.hostname||'';this.host=h+p;this.href+=this.host;// strip [ and ] from the hostname
// the host field still retains them, though
if(ipv6Hostname){this.hostname=this.hostname.substr(1,this.hostname.length-2);if(rest[0]!=='/'){rest='/'+rest;}}}// now rest is set to the post-host stuff.
// chop off any delim chars.
if(!unsafeProtocol[lowerProto]){// First, make 100% sure that any "autoEscape" chars get
// escaped, even if encodeURIComponent doesn't think they
// need to be.
for(var i=0,l=autoEscape.length;i<l;i++){var ae=autoEscape[i];if(rest.indexOf(ae)===-1)continue;var esc=encodeURIComponent(ae);if(esc===ae){esc=escape(ae);}rest=rest.split(ae).join(esc);}}// chop off from the tail first.
var hash=rest.indexOf('#');if(hash!==-1){// got a fragment string.
this.hash=rest.substr(hash);rest=rest.slice(0,hash);}var qm=rest.indexOf('?');if(qm!==-1){this.search=rest.substr(qm);this.query=rest.substr(qm+1);if(parseQueryString){this.query=querystring.parse(this.query);}rest=rest.slice(0,qm);}else if(parseQueryString){// no query string, but parseQueryString still requested
this.search='';this.query={};}if(rest)this.pathname=rest;if(slashedProtocol[lowerProto]&&this.hostname&&!this.pathname){this.pathname='/';}//to support http.request
if(this.pathname||this.search){var p=this.pathname||'';var s=this.search||'';this.path=p+s;}// finally, reconstruct the href based on what has been validated.
this.href=this.format();return this;};// format a parsed object into a url string
function urlFormat(obj){// ensure it's an object, and not a string url.
// If it's an obj, this is a no-op.
// this way, you can call url_format() on strings
// to clean up potentially wonky urls.
if(util.isString(obj))obj=urlParse(obj);if(!(obj instanceof Url))return Url.prototype.format.call(obj);return obj.format();}Url.prototype.format=function(){var auth=this.auth||'';if(auth){auth=encodeURIComponent(auth);auth=auth.replace(/%3A/i,':');auth+='@';}var protocol=this.protocol||'',pathname=this.pathname||'',hash=this.hash||'',host=false,query='';if(this.host){host=auth+this.host;}else if(this.hostname){host=auth+(this.hostname.indexOf(':')===-1?this.hostname:'['+this.hostname+']');if(this.port){host+=':'+this.port;}}if(this.query&&util.isObject(this.query)&&Object.keys(this.query).length){query=querystring.stringify(this.query);}var search=this.search||query&&'?'+query||'';if(protocol&&protocol.substr(-1)!==':')protocol+=':';// only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
// unless they had them to begin with.
if(this.slashes||(!protocol||slashedProtocol[protocol])&&host!==false){host='//'+(host||'');if(pathname&&pathname.charAt(0)!=='/')pathname='/'+pathname;}else if(!host){host='';}if(hash&&hash.charAt(0)!=='#')hash='#'+hash;if(search&&search.charAt(0)!=='?')search='?'+search;pathname=pathname.replace(/[?#]/g,function(match){return encodeURIComponent(match);});search=search.replace('#','%23');return protocol+host+pathname+search+hash;};function urlResolve(source,relative){return urlParse(source,false,true).resolve(relative);}Url.prototype.resolve=function(relative){return this.resolveObject(urlParse(relative,false,true)).format();};function urlResolveObject(source,relative){if(!source)return relative;return urlParse(source,false,true).resolveObject(relative);}Url.prototype.resolveObject=function(relative){if(util.isString(relative)){var rel=new Url();rel.parse(relative,false,true);relative=rel;}var result=new Url();var tkeys=Object.keys(this);for(var tk=0;tk<tkeys.length;tk++){var tkey=tkeys[tk];result[tkey]=this[tkey];}// hash is always overridden, no matter what.
// even href="" will remove it.
result.hash=relative.hash;// if the relative url is empty, then there's nothing left to do here.
if(relative.href===''){result.href=result.format();return result;}// hrefs like //foo/bar always cut to the protocol.
if(relative.slashes&&!relative.protocol){// take everything except the protocol from relative
var rkeys=Object.keys(relative);for(var rk=0;rk<rkeys.length;rk++){var rkey=rkeys[rk];if(rkey!=='protocol')result[rkey]=relative[rkey];}//urlParse appends trailing / to urls like http://www.example.com
if(slashedProtocol[result.protocol]&&result.hostname&&!result.pathname){result.path=result.pathname='/';}result.href=result.format();return result;}if(relative.protocol&&relative.protocol!==result.protocol){// if it's a known url protocol, then changing
// the protocol does weird things
// first, if it's not file:, then we MUST have a host,
// and if there was a path
// to begin with, then we MUST have a path.
// if it is file:, then the host is dropped,
// because that's known to be hostless.
// anything else is assumed to be absolute.
if(!slashedProtocol[relative.protocol]){var keys=Object.keys(relative);for(var v=0;v<keys.length;v++){var k=keys[v];result[k]=relative[k];}result.href=result.format();return result;}result.protocol=relative.protocol;if(!relative.host&&!hostlessProtocol[relative.protocol]){var relPath=(relative.pathname||'').split('/');while(relPath.length&&!(relative.host=relPath.shift())){}if(!relative.host)relative.host='';if(!relative.hostname)relative.hostname='';if(relPath[0]!=='')relPath.unshift('');if(relPath.length<2)relPath.unshift('');result.pathname=relPath.join('/');}else {result.pathname=relative.pathname;}result.search=relative.search;result.query=relative.query;result.host=relative.host||'';result.auth=relative.auth;result.hostname=relative.hostname||relative.host;result.port=relative.port;// to support http.request
if(result.pathname||result.search){var p=result.pathname||'';var s=result.search||'';result.path=p+s;}result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;}var isSourceAbs=result.pathname&&result.pathname.charAt(0)==='/',isRelAbs=relative.host||relative.pathname&&relative.pathname.charAt(0)==='/',mustEndAbs=isRelAbs||isSourceAbs||result.host&&relative.pathname,removeAllDots=mustEndAbs,srcPath=result.pathname&&result.pathname.split('/')||[],relPath=relative.pathname&&relative.pathname.split('/')||[],psychotic=result.protocol&&!slashedProtocol[result.protocol];// if the url is a non-slashed url, then relative
// links like ../.. should be able
// to crawl up to the hostname, as well.  This is strange.
// result.protocol has already been set by now.
// Later on, put the first path part into the host field.
if(psychotic){result.hostname='';result.port=null;if(result.host){if(srcPath[0]==='')srcPath[0]=result.host;else srcPath.unshift(result.host);}result.host='';if(relative.protocol){relative.hostname=null;relative.port=null;if(relative.host){if(relPath[0]==='')relPath[0]=relative.host;else relPath.unshift(relative.host);}relative.host=null;}mustEndAbs=mustEndAbs&&(relPath[0]===''||srcPath[0]==='');}if(isRelAbs){// it's absolute.
result.host=relative.host||relative.host===''?relative.host:result.host;result.hostname=relative.hostname||relative.hostname===''?relative.hostname:result.hostname;result.search=relative.search;result.query=relative.query;srcPath=relPath;// fall through to the dot-handling below.
}else if(relPath.length){// it's relative
// throw away the existing file, and take the new path instead.
if(!srcPath)srcPath=[];srcPath.pop();srcPath=srcPath.concat(relPath);result.search=relative.search;result.query=relative.query;}else if(!util.isNullOrUndefined(relative.search)){// just pull out the search.
// like href='?foo'.
// Put this after the other two cases because it simplifies the booleans
if(psychotic){result.hostname=result.host=srcPath.shift();//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}result.search=relative.search;result.query=relative.query;//to support http.request
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.href=result.format();return result;}if(!srcPath.length){// no path at all.  easy.
// we've already handled the other stuff above.
result.pathname=null;//to support http.request
if(result.search){result.path='/'+result.search;}else {result.path=null;}result.href=result.format();return result;}// if a url ENDs in . or .., then it must get a trailing slash.
// however, if it ends in anything else non-slashy,
// then it must NOT get a trailing slash.
var last=srcPath.slice(-1)[0];var hasTrailingSlash=(result.host||relative.host||srcPath.length>1)&&(last==='.'||last==='..')||last==='';// strip single dots, resolve double dots to parent dir
// if the path tries to go above the root, `up` ends up > 0
var up=0;for(var i=srcPath.length;i>=0;i--){last=srcPath[i];if(last==='.'){srcPath.splice(i,1);}else if(last==='..'){srcPath.splice(i,1);up++;}else if(up){srcPath.splice(i,1);up--;}}// if the path is allowed to go above the root, restore leading ..s
if(!mustEndAbs&&!removeAllDots){for(;up--;up){srcPath.unshift('..');}}if(mustEndAbs&&srcPath[0]!==''&&(!srcPath[0]||srcPath[0].charAt(0)!=='/')){srcPath.unshift('');}if(hasTrailingSlash&&srcPath.join('/').substr(-1)!=='/'){srcPath.push('');}var isAbsolute=srcPath[0]===''||srcPath[0]&&srcPath[0].charAt(0)==='/';// put the host back
if(psychotic){result.hostname=result.host=isAbsolute?'':srcPath.length?srcPath.shift():'';//occationaly the auth can get stuck only in host
//this especially happens in cases like
//url.resolveObject('mailto:local1@domain1', 'local2@domain2')
var authInHost=result.host&&result.host.indexOf('@')>0?result.host.split('@'):false;if(authInHost){result.auth=authInHost.shift();result.host=result.hostname=authInHost.shift();}}mustEndAbs=mustEndAbs||result.host&&srcPath.length;if(mustEndAbs&&!isAbsolute){srcPath.unshift('');}if(!srcPath.length){result.pathname=null;result.path=null;}else {result.pathname=srcPath.join('/');}//to support request.http
if(!util.isNull(result.pathname)||!util.isNull(result.search)){result.path=(result.pathname?result.pathname:'')+(result.search?result.search:'');}result.auth=relative.auth||result.auth;result.slashes=result.slashes||relative.slashes;result.href=result.format();return result;};Url.prototype.parseHost=function(){var host=this.host;var port=portPattern.exec(host);if(port){port=port[0];if(port!==':'){this.port=port.substr(1);}host=host.substr(0,host.length-port.length);}if(host)this.hostname=host;};},{"./util":77,"punycode":51,"querystring":54}],77:[function(require,module,exports){module.exports={isString:function isString(arg){return typeof arg==='string';},isObject:function isObject(arg){return _typeof(arg)==='object'&&arg!==null;},isNull:function isNull(arg){return arg===null;},isNullOrUndefined:function isNullOrUndefined(arg){return arg==null;}};},{}],78:[function(require,module,exports){(function(global){(function(){/**
	 * Module exports.
	 */module.exports=deprecate;/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */function deprecate(fn,msg){if(config('noDeprecation')){return fn;}var warned=false;function deprecated(){if(!warned){if(config('throwDeprecation')){throw new Error(msg);}else if(config('traceDeprecation')){console.trace(msg);}else {console.warn(msg);}warned=true;}return fn.apply(this,arguments);}return deprecated;}/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */function config(name){// accessing global.localStorage can trigger a DOMException in sandboxed iframes
try{if(!global.localStorage)return false;}catch(_){return false;}var val=global.localStorage[name];if(null==val)return false;return String(val).toLowerCase()==='true';}}).call(this);}).call(this,typeof commonjsGlobal!=="undefined"?commonjsGlobal:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{});},{}],79:[function(require,module,exports){// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports=wrappy;function wrappy(fn,cb){if(fn&&cb)return wrappy(fn)(cb);if(typeof fn!=='function')throw new TypeError('need wrapper function');Object.keys(fn).forEach(function(k){wrapper[k]=fn[k];});return wrapper;function wrapper(){var args=new Array(arguments.length);for(var i=0;i<args.length;i++){args[i]=arguments[i];}var ret=fn.apply(this,args);var cb=args[args.length-1];if(typeof ret==='function'&&ret!==cb){Object.keys(cb).forEach(function(k){ret[k]=cb[k];});}return ret;}}},{}],80:[function(require,module,exports){module.exports=function(){throw new Error('ws does not work in the browser. Browser clients must use the native '+'WebSocket object');};},{}],81:[function(require,module,exports){module.exports=extend;var hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){var target={};for(var i=0;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;}},{}],82:[function(require,module,exports){module.exports=function(Yallist){Yallist.prototype[Symbol.iterator]=/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var walker;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:walker=this.head;case 1:if(!walker){_context.next=7;break;}_context.next=4;return walker.value;case 4:walker=walker.next;_context.next=1;break;case 7:case"end":return _context.stop();}}},_callee,this);});};},{}],83:[function(require,module,exports){module.exports=Yallist;Yallist.Node=Node;Yallist.create=Yallist;function Yallist(list){var self=this;if(!(self instanceof Yallist)){self=new Yallist();}self.tail=null;self.head=null;self.length=0;if(list&&typeof list.forEach==='function'){list.forEach(function(item){self.push(item);});}else if(arguments.length>0){for(var i=0,l=arguments.length;i<l;i++){self.push(arguments[i]);}}return self;}Yallist.prototype.removeNode=function(node){if(node.list!==this){throw new Error('removing node which does not belong to this list');}var next=node.next;var prev=node.prev;if(next){next.prev=prev;}if(prev){prev.next=next;}if(node===this.head){this.head=next;}if(node===this.tail){this.tail=prev;}node.list.length--;node.next=null;node.prev=null;node.list=null;return next;};Yallist.prototype.unshiftNode=function(node){if(node===this.head){return;}if(node.list){node.list.removeNode(node);}var head=this.head;node.list=this;node.next=head;if(head){head.prev=node;}this.head=node;if(!this.tail){this.tail=node;}this.length++;};Yallist.prototype.pushNode=function(node){if(node===this.tail){return;}if(node.list){node.list.removeNode(node);}var tail=this.tail;node.list=this;node.prev=tail;if(tail){tail.next=node;}this.tail=node;if(!this.head){this.head=node;}this.length++;};Yallist.prototype.push=function(){for(var i=0,l=arguments.length;i<l;i++){push(this,arguments[i]);}return this.length;};Yallist.prototype.unshift=function(){for(var i=0,l=arguments.length;i<l;i++){unshift(this,arguments[i]);}return this.length;};Yallist.prototype.pop=function(){if(!this.tail){return undefined;}var res=this.tail.value;this.tail=this.tail.prev;if(this.tail){this.tail.next=null;}else {this.head=null;}this.length--;return res;};Yallist.prototype.shift=function(){if(!this.head){return undefined;}var res=this.head.value;this.head=this.head.next;if(this.head){this.head.prev=null;}else {this.tail=null;}this.length--;return res;};Yallist.prototype.forEach=function(fn,thisp){thisp=thisp||this;for(var walker=this.head,i=0;walker!==null;i++){fn.call(thisp,walker.value,i,this);walker=walker.next;}};Yallist.prototype.forEachReverse=function(fn,thisp){thisp=thisp||this;for(var walker=this.tail,i=this.length-1;walker!==null;i--){fn.call(thisp,walker.value,i,this);walker=walker.prev;}};Yallist.prototype.get=function(n){for(var i=0,walker=this.head;walker!==null&&i<n;i++){// abort out of the list early if we hit a cycle
walker=walker.next;}if(i===n&&walker!==null){return walker.value;}};Yallist.prototype.getReverse=function(n){for(var i=0,walker=this.tail;walker!==null&&i<n;i++){// abort out of the list early if we hit a cycle
walker=walker.prev;}if(i===n&&walker!==null){return walker.value;}};Yallist.prototype.map=function(fn,thisp){thisp=thisp||this;var res=new Yallist();for(var walker=this.head;walker!==null;){res.push(fn.call(thisp,walker.value,this));walker=walker.next;}return res;};Yallist.prototype.mapReverse=function(fn,thisp){thisp=thisp||this;var res=new Yallist();for(var walker=this.tail;walker!==null;){res.push(fn.call(thisp,walker.value,this));walker=walker.prev;}return res;};Yallist.prototype.reduce=function(fn,initial){var acc;var walker=this.head;if(arguments.length>1){acc=initial;}else if(this.head){walker=this.head.next;acc=this.head.value;}else {throw new TypeError('Reduce of empty list with no initial value');}for(var i=0;walker!==null;i++){acc=fn(acc,walker.value,i);walker=walker.next;}return acc;};Yallist.prototype.reduceReverse=function(fn,initial){var acc;var walker=this.tail;if(arguments.length>1){acc=initial;}else if(this.tail){walker=this.tail.prev;acc=this.tail.value;}else {throw new TypeError('Reduce of empty list with no initial value');}for(var i=this.length-1;walker!==null;i--){acc=fn(acc,walker.value,i);walker=walker.prev;}return acc;};Yallist.prototype.toArray=function(){var arr=new Array(this.length);for(var i=0,walker=this.head;walker!==null;i++){arr[i]=walker.value;walker=walker.next;}return arr;};Yallist.prototype.toArrayReverse=function(){var arr=new Array(this.length);for(var i=0,walker=this.tail;walker!==null;i++){arr[i]=walker.value;walker=walker.prev;}return arr;};Yallist.prototype.slice=function(from,to){to=to||this.length;if(to<0){to+=this.length;}from=from||0;if(from<0){from+=this.length;}var ret=new Yallist();if(to<from||to<0){return ret;}if(from<0){from=0;}if(to>this.length){to=this.length;}for(var i=0,walker=this.head;walker!==null&&i<from;i++){walker=walker.next;}for(;walker!==null&&i<to;i++,walker=walker.next){ret.push(walker.value);}return ret;};Yallist.prototype.sliceReverse=function(from,to){to=to||this.length;if(to<0){to+=this.length;}from=from||0;if(from<0){from+=this.length;}var ret=new Yallist();if(to<from||to<0){return ret;}if(from<0){from=0;}if(to>this.length){to=this.length;}for(var i=this.length,walker=this.tail;walker!==null&&i>to;i--){walker=walker.prev;}for(;walker!==null&&i>from;i--,walker=walker.prev){ret.push(walker.value);}return ret;};Yallist.prototype.splice=function(start,deleteCount){if(start>this.length){start=this.length-1;}if(start<0){start=this.length+start;}for(var i=0,walker=this.head;walker!==null&&i<start;i++){walker=walker.next;}var ret=[];for(var i=0;walker&&i<deleteCount;i++){ret.push(walker.value);walker=this.removeNode(walker);}if(walker===null){walker=this.tail;}if(walker!==this.head&&walker!==this.tail){walker=walker.prev;}for(var i=0;i<(arguments.length<=2?0:arguments.length-2);i++){walker=insert(this,walker,i+2<2||arguments.length<=i+2?undefined:arguments[i+2]);}return ret;};Yallist.prototype.reverse=function(){var head=this.head;var tail=this.tail;for(var walker=head;walker!==null;walker=walker.prev){var p=walker.prev;walker.prev=walker.next;walker.next=p;}this.head=tail;this.tail=head;return this;};function insert(self,node,value){var inserted=node===self.head?new Node(value,null,node,self):new Node(value,node,node.next,self);if(inserted.next===null){self.tail=inserted;}if(inserted.prev===null){self.head=inserted;}self.length++;return inserted;}function push(self,item){self.tail=new Node(item,self.tail,null,self);if(!self.head){self.head=self.tail;}self.length++;}function unshift(self,item){self.head=new Node(item,null,self.head,self);if(!self.tail){self.tail=self.head;}self.length++;}function Node(value,prev,next,list){if(!(this instanceof Node)){return new Node(value,prev,next,list);}this.list=list;this.value=value;if(prev){prev.next=this;this.prev=prev;}else {this.prev=null;}if(next){next.prev=this;this.next=next;}else {this.next=null;}}try{// add if support for Symbol.iterator is present
require('./iterator.js')(Yallist);}catch(er){}},{"./iterator.js":82}]},{},[12])(12);});})(mqtt$1);var mqtt = /*@__PURE__*/getDefaultExportFromCjs(mqtt$1.exports);

const subscribeGlobalTopic = () => {
    const disposers = [
        subscribeTopic(getNetworkTopic()),
        subscribeTopic(getSmartFeedChannelTopic()),
        subscribeTopic(getSmartFeedSubChannelTopic()),
        subscribeTopic(getSmartFeedMessageTopic()),
        // subscribing to user topic is necessary to handle ban event
        subscribeTopic(getUserTopic(getActiveUser())),
        subscribeTopic(getMarkerUserFeedTopic()),
        subscribeTopic(getLiveStreamTopic()),
    ];
    return () => disposers.forEach(fn => fn());
};

class OnMemoryStorage {
    constructor() {
        this.store = {};
        this.store = {};
    }
    clear() {
        this.store = {};
    }
    getItem(key) {
        return this.store[key] || null;
    }
    setItem(key, value) {
        this.store[key] = String(value);
    }
    removeItem(key) {
        delete this.store[key];
    }
    get length() {
        return Object.keys(this.store).length;
    }
    key(i) {
        const keys = Object.keys(this.store);
        // @ts-ignore
        return keys[i] || null;
    }
}
const windowInstance = () => {
    if (typeof window !== 'undefined' && window.localStorage)
        return window;
    // For JEST
    return { localStorage: new OnMemoryStorage() };
};
const setItem = async (key, value) => {
    return new Promise(resolve => {
        windowInstance().localStorage.setItem(key, value);
        resolve(true);
    });
};
const getItem = async (key) => {
    return new Promise(resolve => {
        const value = windowInstance().localStorage.getItem(key);
        resolve(value);
    });
};

const uuid = () => uuid__default["default"].v4().toString();

// TODO: find a way to uniquely identify the device
let tabIndex = 0;
// This logic is running on browser only
if (typeof BroadcastChannel !== 'undefined' && typeof window !== 'undefined') {
    const tabId = uuid();
    const openedTabs = {};
    const internalBroadcast = new BroadcastChannel('amity_ts_sdk');
    let debouceTimer;
    // Ask nearby opened tabs for indexing
    internalBroadcast.postMessage({ type: 'startup', tabId });
    internalBroadcast.onmessage = ({ data }) => {
        // Ignore messages from self
        if (data.tabId === tabId)
            return;
        if (data.type === 'startup') {
            internalBroadcast.postMessage({ type: 'identify', tabId, tabIndex });
        }
        if (data.type === 'identify' && data.tabIndex !== undefined && data.tabId) {
            openedTabs[data.tabId] = data.tabIndex;
            if (!debouceTimer) {
                debouceTimer = setTimeout(() => {
                    const sorted = Object.values(openedTabs).sort();
                    if (!sorted || sorted.length === 0)
                        return;
                    // @ts-ignore
                    tabIndex = sorted.reduce((acc, currentIndex) => {
                        if (acc < currentIndex) {
                            return acc;
                        }
                        return currentIndex + 1;
                    }, 0);
                }, 15);
            }
        }
    };
}
/** @hidden */
const getDeviceId = async () => {
    // here maybe put some auto-detection of the device id based on if it's react or not?
    // anyhow we let consumer branch out if they want, but it doesn't mean we shouldn't try to be nice
    // and do things automatically
    // https://www.npmjs.com/package/react-native-device-info#getuniqueid
    // how to make sure that the React native package will not be included when build is for web
    var _a;
    const client = getActiveClient();
    const key = `${(_a = client.prefixDeviceIdKey) !== null && _a !== void 0 ? _a : ''}#deviceId`;
    const savedDeviceId = await getItem(key);
    if (savedDeviceId)
        return savedDeviceId;
    const deviceId = `ascWebSdk#${uuid()}`;
    await setItem(key, deviceId);
    return deviceId;
};
const getMQTTClientId = async (userId) => {
    const savedDeviceId = await getDeviceId();
    return `mqttjs_${savedDeviceId}_${userId}_${tabIndex}`;
};
/** @hidden */
const getDeviceModel = () => {
    var _a, _b;
    if ((_a = safeProcess.versions) === null || _a === void 0 ? void 0 : _a.node)
        return safeProcess.versions.node;
    if (navigator)
        return `${navigator.product.toLowerCase()}#${(_b = navigator.userAgent) !== null && _b !== void 0 ? _b : 'unknown_agent'}`;
    return 'unknown_model';
};
/** @hidden */
const getDeviceInfo = () => {
    const model = getDeviceModel();
    return {
        // TODO: replace with: kind: process.versions ? 'node' : 'web', when backend has fixed this
        kind: 'web',
        model,
        sdkVersion: VERSION,
    };
};

/* eslint-disable no-console */
const QOS_FAILURE_CODE = 128;
const RETRY_BASE_TIMEOUT = 1000;
const RETRY_MAX_TIMEOUT = 8000;
var MqttError;
(function (MqttError) {
    MqttError[MqttError["IDENTIFIER_REJECTED"] = 2] = "IDENTIFIER_REJECTED";
    MqttError[MqttError["BAD_USERNAME_OR_PASSWORD"] = 134] = "BAD_USERNAME_OR_PASSWORD";
    MqttError[MqttError["NOT_AUTHORIZED"] = 135] = "NOT_AUTHORIZED";
})(MqttError || (MqttError = {}));
function getMqttOptions(params) {
    return Object.assign({ clean: false, clientId: `mqttjs_ + ${Math.random().toString(16).substring(2, 10)}`, protocolId: 'MQTT', protocolVersion: 4, reconnectPeriod: RETRY_BASE_TIMEOUT, will: {
            topic: 'WillMsg',
            payload: 'Connection Closed abnormally..!',
            qos: 0,
            retain: false,
        }, resubscribe: true }, params);
}
/**
 * Creates a pre-configured socket.io instance
 *
 * @param endpoint The mqtt server's URL
 * @returns A pre-configured (non-connected) mqtt client instance
 *
 * @category Transport
 * @hidden
 */
const createMqttTransport = (endpoint) => {
    let mqttClient;
    async function connect(params) {
        const clientId = await getMQTTClientId(params.userId);
        if (mqttClient) {
            mqttClient.removeAllListeners();
            mqttClient.end(true);
        }
        mqttClient = mqtt.connect(endpoint, getMqttOptions({
            username: params.userId,
            password: params.accessToken,
            clientId,
        }));
        mqttClient.on('connect', () => {
            mqttClient.options.reconnectPeriod = RETRY_BASE_TIMEOUT;
            subscribeGlobalTopic();
        });
        mqttClient.on('error', (error) => {
            // eslint-disable-next-line default-case
            switch (error.code) {
                case 2 /* MqttError.IDENTIFIER_REJECTED */:
                case 134 /* MqttError.BAD_USERNAME_OR_PASSWORD */:
                case 135 /* MqttError.NOT_AUTHORIZED */:
                    mqttClient.end();
            }
        });
        mqttClient.on('reconnect', () => {
            // Double the reconnect period for each attempt
            mqttClient.options.reconnectPeriod = Math.min((mqttClient.options.reconnectPeriod || RETRY_BASE_TIMEOUT) * 2, RETRY_MAX_TIMEOUT);
        });
        return new Promise(resolve => mqttClient.once('connect', () => resolve()));
    }
    return {
        connect,
        async disconnect() {
            if (this.connected) {
                return new Promise(resolve => mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.end(true, undefined, () => resolve()));
            }
        },
        get connected() {
            return !!(mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.connected);
        },
        on(event, handler) {
            mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.on(event, handler);
        },
        once(event, handler) {
            mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.once(event, handler);
        },
        off(event, handler) {
            if (handler !== undefined) {
                mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.off(event, handler);
            }
            else {
                mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.removeAllListeners(event);
            }
        },
        removeAllListeners() {
            mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.removeAllListeners();
        },
        subscribe(topic, callback) {
            const callbackWrapper = (error, granted) => {
                var _a;
                // In MQTT.js, when you subscribe to a topic with QoS 0, the granted parameter
                // in the callback will typically be empty or undefined
                if (error || ((_a = granted[0]) === null || _a === void 0 ? void 0 : _a.qos) === QOS_FAILURE_CODE) {
                    const ascError = error
                        ? new ASCError(error.message, 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */)
                        : // TODO throw the actual error, once BE can tell us the actual error code
                            new ASCUnknownError(800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
                    // Use warning lv instead of error lv to prevent misunderstanding of user
                    console.warn(`Failed to subscribe to topic ${topic}`, ascError);
                    callback === null || callback === void 0 ? void 0 : callback(ascError);
                }
                else {
                    console.log(`Subscribed to topic ${topic}`);
                    callback === null || callback === void 0 ? void 0 : callback();
                }
            };
            if (mqttClient) {
                mqttClient.subscribe(topic, { qos: 0 }, callbackWrapper);
            }
            else {
                callbackWrapper(new Error('No connection to broker'), []);
            }
            return () => mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.unsubscribe(topic);
        },
        unsubscribe(topic) {
            mqttClient === null || mqttClient === void 0 ? void 0 : mqttClient.unsubscribe(topic);
        },
    };
};

/**
 * ```js
 * import { getChatSettings } from '@amityco/ts-sdk'
 * const chatSettings = await getChatSettings()
 * ```
 *
 * Fetches a {@link Amity.ChatSettings} object
 *
 * @returns A Promise of {@link Amity.ChatSettings} object
 *
 * @category Client API
 * @async
 */
const getChatSettings = async () => {
    const client = getActiveClient();
    const { data } = await client.http.get(`/api/v3/network-settings/chat`);
    return data;
};

/**
 * Ingest a payload (v3) into the cache
 *
 * @param payload a "backend v3" payload object
 * @param options caching options like cachedAt or offline
 * @param replace If TRUE it will overwrite the current cache with payload, if FALSE it will merge the payload into cache.
 *
 * @category Cache
 * @hidden
 */
const ingestInCache = (payload = {}, options, replace = true) => {
    Object.entries(payload).forEach(([key, models]) => {
        const type = PAYLOAD2MODEL[key];
        if (!type)
            return;
        const resolver = getResolver(type);
        if (!resolver)
            return;
        models.forEach(model => {
            (replace ? pushToCache : upsertInCache)([type, 'get', resolver(model)], model, options);
        });
    });
};

/**
 * ```js
 * import { pushToTombstone } from '@amityco/ts-sdk'
 * pushToTombstone(["message", "messageId"], { cachedAt: Date.now() })
 * ```
 *
 * Removes an existing {@link Amity.CacheEntry} from the {@link Amity.Client}'s
 * {@link Amity.Cache} from a given {@link Amity.CacheKey}
 *
 * @param model the model to remove and push to Tombstone
 * @param modelId the related model id
 *
 * @category Cache API
 * @hidden
 */
const pushToTombstone = (model, modelId) => {
    const { log, cache } = getActiveClient();
    const cacheKey = [model, CACHE_KEY_TOMBSTONE, modelId];
    const data = { cachedAt: Date.now() };
    if (!cache)
        return;
    log('cache/api/pushToTombstone', { cacheKey, data });
    dropFromCache([model, CACHE_KEY_GET, modelId], true);
    pushToCache(cacheKey, data);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

/**
 * Attach user object to membership model
 * - If cache is not enabled, set user to undefined ({..., user: undefined})
 * - If user object is not found in cache, set user to undefined
 * ({..., user: undefined})
 * - If a user is found in the cache, it attaches the user from the cache
 * ({..., user: { userId, displayName,... }})
 *
 * @param member The membership model object
 * @returns The membership model object that is already mapped to user
 * @hidden
 */
const convertRawMembershipToMembership = (member) => {
    return Object.assign(Object.assign({}, member), { get user() {
            var _a;
            const client = getActiveClient();
            if (!client.cache)
                return undefined;
            const userCache = (_a = pullFromCache(['user', 'get', member.userId])) === null || _a === void 0 ? void 0 : _a.data;
            if (!userCache) {
                return undefined;
            }
            return userCache;
        } });
};
/**
 * Attach user object to membership model
 * - If cache is not enabled, set user to undefined ({..., user: undefined})
 * - If user object is not found in cache, set user to undefined
 * ({..., user: undefined})
 * - If a user is found in the cache, it attaches the user from the cache
 * ({..., user: { userId, displayName,... }})
 *
 * @param member The membership model object
 * @param userIdProp The user ID prop name of membership object
 * @param userProp The user prop name of destination object
 * @returns The membership model object that is already mapped to user
 * @hidden
 */
const withUser = (member, userIdProp = 'userId', userProp = 'user') => {
    // If the user prop already exists, do not overwrite.
    if (member[userProp])
        return member;
    return Object.assign({ get [userProp]() {
            var _a;
            const client = getActiveClient();
            if (!client.cache)
                return undefined;
            const userCache = (_a = pullFromCache([
                'user',
                'get',
                member[userIdProp],
            ])) === null || _a === void 0 ? void 0 : _a.data;
            if (!userCache) {
                return undefined;
            }
            return userCache;
        } }, member);
};
/**
 * Mapping membership model with user object
 *
 * @param members The membership model objects
 * @param userIdProp The user ID prop name of membership object
 * @param userProp The user prop name of destination object
 * @returns The membership model objects that is already
 * mapped to users
 * @hidden
 */
const withUsers = (members, userIdProp = 'userId', userProp = 'user') => {
    var _a;
    return (_a = members === null || members === void 0 ? void 0 : members.map(member => withUser(member, userIdProp, userProp))) !== null && _a !== void 0 ? _a : members;
};
/**
 * Transform members prop in any payload with attached users members
 *
 * @param payload The payload contain members prop
 * @param memberProp A name of members prop
 * @param userIdProp The user ID prop name of membership object
 * @param userProp The user prop name of destination object
 * @returns The transforming payload
 * @hidden
 */
const prepareMembershipPayload = (payload, memberProp, userIdProp = 'userId', userProp = 'user') => {
    const _a = payload, _b = memberProp, memberPayload = _a[_b], rest = __rest(_a, [typeof _b === "symbol" ? _b : _b + ""]);
    const members = withUsers(memberPayload, userIdProp, userProp);
    return Object.assign(Object.assign({}, rest), { [memberProp]: members });
};

function doConvert(markerResponses) {
    return markerResponses.map((_a) => {
        var { isMentioned } = _a, rest = __rest(_a, ["isMentioned"]);
        return (Object.assign({ hasMentioned: isMentioned }, rest));
    });
}
function convertChannelMarkerResponse(channelMarkerResponse) {
    return doConvert(channelMarkerResponse);
}
function convertSubChannelMarkerResponse(subChannelMarkerResponse) {
    return doConvert(subChannelMarkerResponse);
}

/**
 * ```js
 * import { getChannelMarker } from '@amityco/ts-sdk'
 * const channelMarkers = await getChannelMarkers(['ch1', 'ch2'])
 * ```
 *
 * @param channelIds the IDs of the {@link Amity.RawChannel} marker to fetch
 * @returns A List of {@link Amity.ChannelMarker} by channelIds
 *
 * @category Channel API
 * @async
 * @private
 */
const getChannelMarkers = async (channelIds) => {
    const client = getActiveClient();
    client.log('channel/getChannelMarkers', channelIds);
    const { data: queryPayload } = await client.http.get(`/api/v1/markers/channels`, {
        params: {
            channelIds,
        },
    });
    const { userEntityMarkers: userEntityMarkersPayload, userMarkers } = queryPayload;
    const userEntityMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ userEntityMarkers, userMarkers }, { cachedAt });
    fireEvent('local.channelMarker.fetched', {
        userEntityMarkers,
    });
    fireEvent('local.userMarker.fetched', { userMarkers });
    return { data: userEntityMarkers, cachedAt };
};

const getChannelMessagePreview = (channelId) => {
    var _a, _b;
    return ((_b = (_a = pullFromCache(['messagePreviewChannel', 'get', channelId])) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : null);
};

const ANALYTIC_CACHE_KEY = ['analytic', 'normal-priority'];
const HIGH_PRIORITY_ANALYTIC_CACHE_KEY = ['analytic', 'high-priority'];

const syncEvent = async (events) => {
    const client = getActiveClient();
    const params = {
        activities: events,
    };
    await client.http.post('/api/v1/analytics/activities', params);
};

class AnalyticsEventSyncer {
    constructor() {
        this._timer = undefined;
        this._high_priority_timer = undefined;
    }
    start() {
        this.syncCapturedEvent();
        this._timer = setInterval(() => {
            this.syncCapturedEvent();
        }, 1 * MINUTE);
        this._high_priority_timer = setInterval(() => {
            this.syncHighPriorityCapturedEvent();
        }, 10 * SECOND$1);
    }
    stop() {
        if (this._timer) {
            clearInterval(this._timer);
            this._timer = undefined;
        }
        if (this._high_priority_timer) {
            clearInterval(this._high_priority_timer);
            this._high_priority_timer = undefined;
        }
    }
    async syncCapturedEvent() {
        try {
            // Must query only objects that have same userId with current logged-in user.
            // Query captured event with maximum of 1000
            // Order by latest first
            // e.g., If there are 2000 events we will query 1000-2000 first
            const cache = pullFromCache(ANALYTIC_CACHE_KEY);
            if (!(cache === null || cache === void 0 ? void 0 : cache.data))
                return;
            if (cache.data.event.length === 0)
                return;
            const capturedEvents = cache.data.event;
            await syncEvent(capturedEvents);
            dropFromCache(ANALYTIC_CACHE_KEY);
        }
        catch (error) {
            // stop and destroy all events
            this.stop();
            dropFromCache(ANALYTIC_CACHE_KEY);
        }
    }
    async syncHighPriorityCapturedEvent() {
        try {
            // Must query only objects that have same userId with current logged-in user.
            // Query captured event with maximum of 1000
            // Order by latest first
            // e.g., If there are 2000 events we will query 1000-2000 first
            const cache = pullFromCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY);
            if (!(cache === null || cache === void 0 ? void 0 : cache.data))
                return;
            if (cache.data.event.length === 0)
                return;
            const capturedEvents = cache.data.event;
            await syncEvent(capturedEvents);
            dropFromCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY);
        }
        catch (error) {
            // stop and destroy all events
            this.stop();
            dropFromCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY);
        }
    }
}

class AnalyticsEventCapturer {
    constructor() {
        this._expireTime = 5 * MINUTE;
        this._poolLimit = 1000;
        this._recentViewed = {};
        this._recentHighPriorityViewed = {};
        // Story
        this._throttleStoryTimer = undefined;
        this._bufferNewSeenStoryReferenceIds = [];
    }
    isAbleToEnqueue({ uniqueId, expireTime, isHighPriority = false, }) {
        const now = new Date();
        // Get the recent view date (if any)
        const recentViewedDate = isHighPriority
            ? this._recentHighPriorityViewed[uniqueId]
            : this._recentViewed[uniqueId];
        // If this is the first view, always allow it
        if (!recentViewedDate) {
            return true;
        }
        const timeDiff = now.getTime() - recentViewedDate.getTime();
        if (timeDiff < expireTime) {
            // just recently view this post, ignore the event.
            return false;
        }
        return true;
    }
    markAs({ uniqueId, contentId, contentType, activityType, metadata, }) {
        if (!this.isAbleToEnqueue({ uniqueId, expireTime: this._expireTime }))
            return;
        const now = new Date();
        const currentData = { event: [] };
        const cache = pullFromCache(ANALYTIC_CACHE_KEY);
        if (cache === null || cache === void 0 ? void 0 : cache.data) {
            currentData.event = cache.data.event;
        }
        // If the pool is full (Max 1000 items), remove the oldest data
        if (currentData.event.length >= this._poolLimit) {
            // Remove oldest data
            currentData.event.shift();
        }
        const analyticItem = {
            contentId,
            contentType,
            activityType,
            timestamp: now.toISOString(),
        };
        if (metadata) {
            analyticItem.metadata = metadata;
        }
        currentData.event.push(analyticItem);
        upsertInCache(ANALYTIC_CACHE_KEY, currentData);
        this._recentViewed[uniqueId] = now;
    }
    markPostAsViewed(postId) {
        this.markAs({
            uniqueId: postId,
            contentId: postId,
            contentType: "post" /* Amity.AnalyticEventContentType.Post */,
            activityType: "view" /* Amity.AnalyticEventActivityType.View */,
        });
    }
    markStory(story, activityType) {
        if (!story.expiresAt)
            return;
        const now = new Date();
        const expireTime = new Date(story.expiresAt);
        if (!this.isAbleToEnqueue({
            uniqueId: story.storyId,
            expireTime: expireTime.getTime(),
            isHighPriority: true,
        }))
            return;
        const currentData = { event: [] };
        const cache = pullFromCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY);
        if (cache === null || cache === void 0 ? void 0 : cache.data) {
            currentData.event = cache.data.event;
        }
        // If the pool is full (Max 1000 items), remove the oldest data
        if (currentData.event.length >= this._poolLimit) {
            // Remove oldest data
            currentData.event.shift();
        }
        currentData.event.push({
            contentId: story.storyId,
            contentType: "story" /* Amity.AnalyticEventContentType.Story */,
            activityType,
            timestamp: now.toISOString(),
        });
        upsertInCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY, currentData);
        this._recentHighPriorityViewed[story.storyId] = now;
        // Fire internal event if the activity type is not click
        if (activityType === "linkClicked" /* Amity.AnalyticEventActivityType.Click */)
            return;
        // Mark story as SEEN
        pushToCache(["story-seen" /* STORY_KEY_CACHE.IS_SEEN */, 'get', story.storyId], new Date().toISOString());
        // Update the latest timestamp for LocalStoryLastSeen
        const currentLastSeen = pullFromCache([
            "story-last-seen" /* STORY_KEY_CACHE.LAST_SEEN */,
            story.targetId,
        ]);
        if (currentLastSeen === null || currentLastSeen === void 0 ? void 0 : currentLastSeen.data) {
            if (new Date(currentLastSeen.data).getTime() < new Date(story.expiresAt).getTime()) {
                pushToCache(["story-last-seen" /* STORY_KEY_CACHE.LAST_SEEN */, story.targetId], story.expiresAt);
            }
        }
        else {
            pushToCache(["story-last-seen" /* STORY_KEY_CACHE.LAST_SEEN */, story.targetId], story.expiresAt);
        }
        this._bufferNewSeenStoryReferenceIds.push(story.referenceId);
        if (this._throttleStoryTimer)
            return;
        this._throttleStoryTimer = setTimeout(() => {
            clearTimeout(this._throttleStoryTimer);
            fireEvent('local.story.reload', { referenceIds: this._bufferNewSeenStoryReferenceIds });
            this._bufferNewSeenStoryReferenceIds = [];
        }, 300);
    }
    resetAllBuckets() {
        this._recentViewed = {};
        this._recentHighPriorityViewed = {};
        dropFromCache(ANALYTIC_CACHE_KEY);
        dropFromCache(HIGH_PRIORITY_ANALYTIC_CACHE_KEY);
    }
    markStoryAsViewed(story) {
        this.markStory(story, "view" /* Amity.AnalyticEventActivityType.View */);
    }
    markStoryAsClicked(story) {
        this.markStory(story, "linkClicked" /* Amity.AnalyticEventActivityType.Click */);
    }
    markAdAsViewed(ad, placement) {
        const metadata = {
            placement,
        };
        const activityType = "view" /* Amity.AnalyticEventActivityType.View */;
        this.markAs({
            uniqueId: `${ad.adId}.${activityType}.${placement}`,
            contentId: ad.adId,
            contentType: "ad" /* Amity.AnalyticEventContentType.Ad */,
            activityType,
            metadata,
        });
    }
    markAdAsClicked(ad, placement) {
        const metadata = {
            placement,
        };
        const activityType = "linkClicked" /* Amity.AnalyticEventActivityType.Click */;
        this.markAs({
            uniqueId: `${ad.adId}.${activityType}.${placement}`,
            contentId: ad.adId,
            contentType: "ad" /* Amity.AnalyticEventContentType.Ad */,
            activityType,
            metadata,
        });
    }
}

class AnalyticsEngine {
    constructor() {
        this._client = getActiveClient();
        this._eventCapturer = new AnalyticsEventCapturer();
        this._eventSyncer = new AnalyticsEventSyncer();
    }
    markPostAsViewed(postId) {
        if (this._client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */ ||
            this._client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */ // For case token_expired, we assume token is expired and gonna re-connect soon
        ) {
            this._eventCapturer.markPostAsViewed(postId);
        }
    }
    markStoryAsViewed(story) {
        if (this._client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */ ||
            this._client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */ // For case token_expired, we assume token is expired and gonna re-connect soon
        ) {
            this._eventCapturer.markStoryAsViewed(story);
        }
    }
    markAdAsViewed(ad, placement) {
        if (this._client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */ ||
            this._client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            this._eventCapturer.markAdAsViewed(ad, placement);
        }
    }
    markAdAsClicked(ad, placement) {
        if (this._client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */ ||
            this._client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            this._eventCapturer.markAdAsClicked(ad, placement);
        }
    }
    markStoryAsClicked(story) {
        if (this._client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */ ||
            this._client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            this._eventCapturer.markStoryAsClicked(story);
        }
    }
    established() {
        this._eventSyncer.start();
    }
    handleTokenExpired() {
        this._stopAndDestroy();
    }
    destroy() {
        this._stopAndDestroy();
    }
    _stopAndDestroy() {
        this._eventSyncer.stop();
        this._eventCapturer.resetAllBuckets();
    }
}
let instance$5;
var AnalyticsEngine$1 = {
    getInstance: () => {
        if (!instance$5) {
            instance$5 = new AnalyticsEngine();
        }
        return instance$5;
    },
};

const userLinkedObject = (user) => {
    return Object.assign(Object.assign({}, user), { get avatar() {
            var _a;
            if (!user.avatarFileId)
                return undefined;
            const avatar = (_a = pullFromCache([
                'file',
                'get',
                `${user.avatarFileId}`,
            ])) === null || _a === void 0 ? void 0 : _a.data;
            return avatar;
        } });
};

class StoryComputedValue {
    constructor(targetId, lastStoryExpiresAt, lastStorySeenExpiresAt) {
        this._syncingStoriesCount = 0;
        this._errorStoriesCount = 0;
        this._targetId = targetId;
        this._lastStoryExpiresAt = lastStoryExpiresAt;
        this._lastStorySeenExpiresAt = lastStorySeenExpiresAt;
        this.cacheStoryExpireTime = pullFromCache([
            "story-expire" /* STORY_KEY_CACHE.EXPIRE */,
            this._targetId,
        ]);
        this.cacheStoreSeenTime = pullFromCache([
            "story-last-seen" /* STORY_KEY_CACHE.LAST_SEEN */,
            this._targetId,
        ]);
        this.getTotalStoryByStatus();
    }
    get lastStoryExpiresAt() {
        return this._lastStoryExpiresAt ? new Date(this._lastStoryExpiresAt).getTime() : 0;
    }
    get lastStorySeenExpiresAt() {
        return this._lastStorySeenExpiresAt ? new Date(this._lastStorySeenExpiresAt).getTime() : 0;
    }
    get localLastStoryExpires() {
        var _a, _b;
        return ((_a = this.cacheStoryExpireTime) === null || _a === void 0 ? void 0 : _a.data)
            ? new Date((_b = this.cacheStoryExpireTime) === null || _b === void 0 ? void 0 : _b.data).getTime()
            : 0;
    }
    get localLastStorySeenExpiresAt() {
        var _a, _b;
        return ((_a = this.cacheStoreSeenTime) === null || _a === void 0 ? void 0 : _a.data) ? new Date((_b = this.cacheStoreSeenTime) === null || _b === void 0 ? void 0 : _b.data).getTime() : 0;
    }
    get isContainUnSyncedStory() {
        const currentSyncingState = pullFromCache([
            "story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */,
            this._targetId,
        ]);
        if (!(currentSyncingState === null || currentSyncingState === void 0 ? void 0 : currentSyncingState.data))
            return false;
        return ["syncing" /* Amity.SyncState.Syncing */, "error" /* Amity.SyncState.Error */].includes(currentSyncingState.data);
    }
    getLocalLastSortingDate() {
        if (this.isContainUnSyncedStory) {
            return this.localLastStoryExpires;
        }
        return this.lastStoryExpiresAt;
    }
    getHasUnseenFlag() {
        const now = new Date().getTime();
        const highestSeen = Math.max(this.lastStorySeenExpiresAt, this.localLastStorySeenExpiresAt);
        pullFromCache([
            "story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */,
            this._targetId,
        ]);
        if (this.isContainUnSyncedStory) {
            return this.localLastStoryExpires > now && this.localLastStoryExpires > highestSeen;
        }
        return this.lastStoryExpiresAt > now && this.lastStoryExpiresAt > highestSeen;
    }
    getTotalStoryByStatus() {
        const stories = queryCache(["story" /* STORY_KEY_CACHE.STORY */, 'get']);
        if (!stories) {
            this._errorStoriesCount = 0;
            this._syncingStoriesCount = 0;
            return;
        }
        const groupByType = stories.reduce((acc, story) => {
            const { data: { targetId, syncState, isDeleted }, } = story;
            if (targetId === this._targetId && !isDeleted) {
                acc[syncState] += 1;
            }
            return acc;
        }, {
            syncing: 0,
            error: 0,
            synced: 0,
        });
        this._errorStoriesCount = groupByType.error;
        this._syncingStoriesCount = groupByType.syncing;
    }
    get syncingStoriesCount() {
        return this._syncingStoriesCount;
    }
    get failedStoriesCount() {
        return this._errorStoriesCount;
    }
}

const storyTargetLinkedObject = (storyTarget) => {
    const { targetType, targetId, lastStoryExpiresAt, lastStorySeenExpiresAt, targetUpdatedAt, localFilter, } = storyTarget;
    const computedValue = new StoryComputedValue(targetId, lastStoryExpiresAt, lastStorySeenExpiresAt);
    return {
        targetType,
        targetId,
        lastStoryExpiresAt,
        updatedAt: targetUpdatedAt,
        // Additional data
        hasUnseen: computedValue.getHasUnseenFlag(),
        syncingStoriesCount: computedValue.syncingStoriesCount,
        failedStoriesCount: computedValue.failedStoriesCount,
        localFilter,
        localLastExpires: computedValue.localLastStoryExpires,
        localLastSeen: computedValue.localLastStorySeenExpiresAt,
        localSortingDate: computedValue.getLocalLastSortingDate(),
    };
};

const storyLinkedObject = (story) => {
    const analyticsEngineInstance = AnalyticsEngine$1.getInstance();
    const storyTargetCache = pullFromCache([
        "storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */,
        'get',
        story.targetId,
    ]);
    const communityCacheData = pullFromCache(['community', 'get', story.targetId]);
    return Object.assign(Object.assign({}, story), { analytics: {
            markAsSeen: () => {
                if (!story.expiresAt)
                    return;
                if (story.syncState !== "synced" /* Amity.SyncState.Synced */)
                    return;
                analyticsEngineInstance.markStoryAsViewed(story);
            },
            markLinkAsClicked: () => {
                if (!story.expiresAt)
                    return;
                if (story.syncState !== "synced" /* Amity.SyncState.Synced */)
                    return;
                analyticsEngineInstance.markStoryAsClicked(story);
            },
        }, get videoData() {
            var _a, _b;
            const cache = pullFromCache([
                'file',
                'get',
                (_b = (_a = story.data) === null || _a === void 0 ? void 0 : _a.videoFileId) === null || _b === void 0 ? void 0 : _b.original,
            ]);
            if (!cache)
                return undefined;
            const { data } = cache;
            return data || undefined;
        },
        get imageData() {
            var _a, _b;
            if (!((_a = story.data) === null || _a === void 0 ? void 0 : _a.fileId))
                return undefined;
            const cache = pullFromCache(['file', 'get', (_b = story.data) === null || _b === void 0 ? void 0 : _b.fileId]);
            if (!cache)
                return undefined;
            const { data } = cache;
            if (!data)
                return undefined;
            return Object.assign(Object.assign({}, data), { fileUrl: `${data.fileUrl}?size=full` });
        },
        get community() {
            if (story.targetType !== 'community')
                return undefined;
            if (!communityCacheData)
                return undefined;
            return (communityCacheData === null || communityCacheData === void 0 ? void 0 : communityCacheData.data) || undefined;
        },
        get communityCategories() {
            if (story.targetType !== 'community')
                return undefined;
            if (!communityCacheData)
                return undefined;
            const { data: { categoryIds }, } = communityCacheData;
            if (categoryIds.length === 0)
                return undefined;
            return categoryIds
                .map(categoryId => {
                const categoryCacheData = pullFromCache(['category', 'get', categoryId]);
                return (categoryCacheData === null || categoryCacheData === void 0 ? void 0 : categoryCacheData.data) || undefined;
            })
                .filter(category => category !== undefined);
        },
        get creator() {
            const cacheData = pullFromCache(['user', 'get', story.creatorPublicId]);
            if (!(cacheData === null || cacheData === void 0 ? void 0 : cacheData.data))
                return;
            return userLinkedObject(cacheData.data);
        },
        get storyTarget() {
            if (!(storyTargetCache === null || storyTargetCache === void 0 ? void 0 : storyTargetCache.data))
                return;
            return storyTargetLinkedObject(storyTargetCache.data);
        },
        get isSeen() {
            const cacheData = pullFromCache(["story-last-seen" /* STORY_KEY_CACHE.LAST_SEEN */, story.targetId]);
            if (!(storyTargetCache === null || storyTargetCache === void 0 ? void 0 : storyTargetCache.data))
                return false;
            const localLastSeen = (cacheData === null || cacheData === void 0 ? void 0 : cacheData.data) ? new Date(cacheData.data).getTime() : 0;
            const serverLastSeen = new Date(storyTargetCache === null || storyTargetCache === void 0 ? void 0 : storyTargetCache.data.lastStorySeenExpiresAt).getTime() || 0;
            const expiresAt = new Date(story.expiresAt).getTime();
            return Math.max(localLastSeen, serverLastSeen) >= expiresAt;
        } });
};

const streamLinkedObject = (stream) => {
    return Object.assign(Object.assign({}, stream), { get moderation() {
            var _a;
            return (_a = pullFromCache(['streamModeration', 'get', stream.streamId])) === null || _a === void 0 ? void 0 : _a.data;
        },
        get post() {
            var _a;
            if (stream.referenceType !== 'post')
                return;
            return (_a = pullFromCache(['post', 'get', stream.referenceId])) === null || _a === void 0 ? void 0 : _a.data;
        },
        get community() {
            var _a;
            if (stream.targetType !== 'community')
                return;
            return (_a = pullFromCache(['community', 'get', stream.targetId])) === null || _a === void 0 ? void 0 : _a.data;
        },
        get user() {
            var _a;
            return (_a = pullFromCache(['user', 'get', stream.userId])) === null || _a === void 0 ? void 0 : _a.data;
        } });
};

const categoryLinkedObject = (category) => {
    return Object.assign(Object.assign({}, category), { get avatar() {
            var _a;
            if (!category.avatarFileId)
                return undefined;
            const avatar = (_a = pullFromCache([
                'file',
                'get',
                `${category.avatarFileId}`,
            ])) === null || _a === void 0 ? void 0 : _a.data;
            return avatar;
        } });
};

/**
 * ```js
 * import { isEqual } from '~/utils/isEqual'
 * const isEqual = isEqual(post1, post2)
 * ```
 *
 * Compares two Amity.Model
 *
 * @param x the Amity.Model to compare
 * @param y the Amity.Model to compare wit x
 * @returns a boolean based on equality
 *
 * @category utility
 * @private
 */
function isEqual(x, y) {
    if (x === null || x === undefined || y === null || y === undefined) {
        return x === y;
    }
    // after this just checking type of one would be enough
    if (x.constructor !== y.constructor) {
        return false;
    }
    // if they are functions, they should exactly refer to same one (because of closures)
    if (x instanceof Function) {
        return x === y;
    }
    // if they are regexps, they should exactly refer to same one
    if (x instanceof RegExp) {
        return x === y;
    }
    if (x === y || x.valueOf() === y.valueOf()) {
        return true;
    }
    if (Array.isArray(x) && x.length !== y.length) {
        return false;
    }
    // check each element of the array for equality
    if (Array.isArray(x) && Array.isArray(y)) {
        if (x.length !== y.length)
            return false;
        for (let i = 0; i < x.length; i += 1) {
            if (!isEqual(x[i], y[i]))
                return false;
        }
        // if all elements are equal, the arrays are equal
        return true;
    }
    // if they are dates, they must had equal valueOf
    if (x instanceof Date) {
        return false;
    }
    // if they are strictly equal, they both need to be object at least
    if (!(x instanceof Object)) {
        return false;
    }
    if (!(y instanceof Object)) {
        return false;
    }
    // recursive object equality check
    const p = Object.keys(x);
    return (Object.keys(y).every(i => {
        // @ts-ignore
        return p.indexOf(i) !== -1;
    }) &&
        p.every(i => {
            return isEqual(x[i], y[i]);
        }));
}

function isNonNullable(value) {
    return value != null;
}

const commentLinkedObject = (comment) => {
    return Object.assign(Object.assign({}, comment), { get target() {
            const commentTypes = {
                type: comment.targetType,
            };
            if (comment.targetType === 'user') {
                return Object.assign(Object.assign({}, commentTypes), { userId: comment.targetId });
            }
            if (commentTypes.type === 'content') {
                return Object.assign(Object.assign({}, commentTypes), { contentId: comment.targetId });
            }
            if (commentTypes.type === 'community') {
                const cacheData = pullFromCache([
                    'communityUsers',
                    'get',
                    `${comment.targetId}#${comment.userId}`,
                ]);
                return Object.assign(Object.assign({}, commentTypes), { communityId: comment.targetId, creatorMember: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data });
            }
            return {
                type: 'unknown',
            };
        },
        get creator() {
            const cacheData = pullFromCache(['user', 'get', comment.userId]);
            if (cacheData === null || cacheData === void 0 ? void 0 : cacheData.data)
                return userLinkedObject(cacheData.data);
            return undefined;
        },
        get childrenComment() {
            return comment.children
                .map(childCommentId => {
                const commentCache = pullFromCache([
                    'comment',
                    'get',
                    childCommentId,
                ]);
                if (!(commentCache === null || commentCache === void 0 ? void 0 : commentCache.data))
                    return;
                return commentCache === null || commentCache === void 0 ? void 0 : commentCache.data;
            })
                .filter(isNonNullable)
                .map(item => commentLinkedObject(item));
        } });
};

const postLinkedObject = (post) => {
    return Object.assign(Object.assign({}, post), { analytics: {
            markAsViewed: () => {
                const analyticsEngineInstance = AnalyticsEngine$1.getInstance();
                analyticsEngineInstance.markPostAsViewed(post.postId);
            },
        }, get latestComments() {
            if (!post.comments)
                return [];
            return (post.comments
                .map(commentId => {
                var _a;
                const commentCached = (_a = pullFromCache([
                    'comment',
                    'get',
                    commentId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!commentCached)
                    return null;
                return commentLinkedObject(commentCached);
            })
                .filter(Boolean) || []);
        },
        get creator() {
            const cacheData = pullFromCache(['user', 'get', post.postedUserId]);
            if (!(cacheData === null || cacheData === void 0 ? void 0 : cacheData.data))
                return;
            return userLinkedObject(cacheData.data);
        } });
};

const getCachedMarker$2 = (message) => {
    var _a, _b;
    const key = {
        creatorId: 'creatorPrivateId' in message ? message.creatorPrivateId : message.creatorId,
        feedId: (_a = message.messageFeedId) !== null && _a !== void 0 ? _a : message.subChannelId,
        contentId: message.messageId,
    };
    return (_b = pullFromCache([
        'messageMarker',
        'get',
        getResolver('messageMarker')(key),
    ])) === null || _b === void 0 ? void 0 : _b.data;
};
const getMessageReadCount = (message, marker) => {
    var _a;
    // Look in the marker param first
    return (_a = marker !== null && marker !== void 0 ? marker : 
    // If the marker param is not set, look in the cache
    getCachedMarker$2(message)) !== null && _a !== void 0 ? _a : { readCount: 0, deliveredCount: 0 };
}; // and if not found in cache use default value `0`

/**
 *
 * Mark subChannel as read by readToSegment
 *
 * @param subChannelIds the IDs of the {@link Amity.SubChannel} to update
 * @param readToSegment the segment to mark as read
 * @returns a success boolean if the {@link Amity.SubChannel} was updated
 *
 * @category Channel API
 * @async
 */
const markChannelsAsReadBySegment = async (readings) => {
    const client = getActiveClient();
    try {
        await client.http.post('api/v3/channels/seen', { channels: readings });
        return true;
    }
    catch (e) {
        return false;
    }
};

class MessageReadReceiptSyncEngine {
    constructor() {
        this.isActive = true;
        this.MAX_RETRY = 3;
        this.JOB_QUEUE_SIZE = 120;
        this.jobQueue = [];
        // Interval for message read receipt sync in seconds
        this.RECEIPT_SYNC_INTERVAL = 1;
        this.client = getActiveClient();
        // Get remaining unsync read receipts from cache
        this.getUnsyncJobs();
    }
    //  Call this when client call client.login
    startSyncReadReceipt() {
        // Start timer when start receipt sync
        this.timer = setInterval(() => {
            this.syncReadReceipts();
        }, this.RECEIPT_SYNC_INTERVAL * 1000);
    }
    // Read receipt observer handling
    syncReadReceipts() {
        if (this.jobQueue.length === 0 || this.isActive === false)
            return;
        const readReceipts = this.getReadReceipts();
        if (readReceipts) {
            this.markReadApi(readReceipts);
        }
    }
    getUnsyncJobs() {
        var _a;
        // Get all read receipts that has latestSyncSegment < latestSegment
        const readReceipts = (_a = queryCache(['readReceipt'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
            return data.latestSyncSegment < data.latestSegment;
        });
        // Enqueue unsync read receipts to the job queue
        readReceipts === null || readReceipts === void 0 ? void 0 : readReceipts.forEach(({ data: readReceipt }) => {
            this.enqueueReadReceipt(readReceipt.channelId, readReceipt.latestSegment);
        });
    }
    getReadReceipts() {
        // get all read receipts from queue, now the queue is empty
        const syncJob = this.jobQueue.splice(0, this.jobQueue.length);
        if (syncJob.length === 0)
            return;
        return syncJob.filter(job => {
            var _a;
            const readReceipt = (_a = pullFromCache(['readReceipt', job.channelId])) === null || _a === void 0 ? void 0 : _a.data;
            if (!readReceipt)
                return false;
            if (readReceipt.latestSegment > readReceipt.latestSyncSegment)
                return true;
            return false;
        });
    }
    async markReadApi(syncJobs) {
        var _a;
        // constuct payload
        // example: [{ channelId: 'channelId', readToSegment: 2 }]
        const syncJobsPayload = syncJobs.map(job => {
            return {
                channelId: job.channelId,
                readToSegment: job.segment,
            };
        });
        const response = await markChannelsAsReadBySegment(syncJobsPayload);
        if (response) {
            for (let i = 0; i < syncJobs.length; i += 1) {
                // update lastestSyncSegment in read receipt cache
                const cacheKey = ['readReceipt', syncJobs[i].channelId];
                const readReceiptCache = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                pushToCache(cacheKey, Object.assign(Object.assign({}, readReceiptCache), { latestSyncSegment: syncJobs[i].segment }));
            }
        }
        else {
            for (let i = 0; i < syncJobs.length; i += 1) {
                // push them back to queue if the syncing is failed and retry count is less than max retry
                if (syncJobs[i].retryCount >= this.MAX_RETRY)
                    return;
                const updatedJob = Object.assign(Object.assign({}, syncJobs[i]), { syncState: "create" /* Amity.ReadReceiptSyncState.CREATED */, retryCount: syncJobs[i].retryCount + 1 });
                this.enqueueJob(updatedJob);
            }
        }
    }
    startObservingReadReceiptQueue() {
        if (this.client.useLegacyUnreadCount) {
            this.isActive = true;
            this.startSyncReadReceipt();
        }
    }
    stopObservingReadReceiptQueue() {
        this.isActive = false;
        this.jobQueue.map(job => {
            if (job.syncState === "syncing" /* Amity.ReadReceiptSyncState.SYNCING */) {
                return Object.assign(Object.assign({}, job), { syncState: "create" /* Amity.ReadReceiptSyncState.CREATED */ });
            }
            return job;
        });
        if (this.timer)
            clearInterval(this.timer);
    }
    // Session Management
    onSessionEstablished() {
        this.startObservingReadReceiptQueue();
    }
    onSessionDestroyed() {
        this.stopObservingReadReceiptQueue();
        this.jobQueue = [];
    }
    onTokenExpired() {
        this.stopObservingReadReceiptQueue();
    }
    // Network Connection Management
    onNetworkOffline() {
        // Stop observing to the read receipt queue.
        this.stopObservingReadReceiptQueue();
    }
    onNetworkOnline() {
        // Resume observing to the read receipt queue.
        this.startObservingReadReceiptQueue();
    }
    markRead(channelId, segment) {
        var _a;
        // Step 1: Optimistic update of channelUnread.readToSegment to message.segment and update unreadCount value
        const cacheKey = ['channelUnread', 'get', channelId];
        const channelUnread = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (typeof (channelUnread === null || channelUnread === void 0 ? void 0 : channelUnread.readToSegment) === 'number' &&
            channelUnread &&
            segment > channelUnread.readToSegment) {
            channelUnread.readToSegment = segment;
            channelUnread.unreadCount = Math.max(channelUnread.lastSegment - segment, 0);
            pushToCache(cacheKey, channelUnread);
            fireEvent('local.channelUnread.updated', channelUnread);
        }
        // Step 2: Enqueue the read receipt
        this.enqueueReadReceipt(channelId, segment);
    }
    enqueueReadReceipt(channelId, segment) {
        var _a;
        const readReceipt = (_a = pullFromCache(['readReceipt', channelId])) === null || _a === void 0 ? void 0 : _a.data;
        // Create new read receipt if it's not exists and add the job to queue
        if (!readReceipt) {
            const readReceiptChannel = {
                channelId,
                latestSegment: segment,
                latestSyncSegment: 0,
            };
            pushToCache(['readReceipt', channelId], readReceiptChannel);
        }
        else if (readReceipt.latestSegment < segment) {
            // Update latestSegment in read receipt cache
            pushToCache(['readReceipt', channelId], Object.assign(Object.assign({}, readReceipt), { latestSegment: segment }));
        }
        else if (readReceipt.latestSyncSegment >= segment) {
            // Skip the job when lastSyncSegment > = segment
            return;
        }
        let syncJob = this.getSyncJob(channelId);
        if (syncJob === null || syncJob.syncState === "syncing" /* Amity.ReadReceiptSyncState.SYNCING */) {
            syncJob = {
                channelId,
                segment,
                syncState: "create" /* Amity.ReadReceiptSyncState.CREATED */,
                retryCount: 0,
            };
            this.enqueueJob(syncJob);
        }
        else if (syncJob.segment < segment) {
            syncJob.segment = segment;
        }
    }
    getSyncJob(channelId) {
        const { jobQueue } = this;
        const targetJob = jobQueue.find(job => job.channelId === channelId);
        return targetJob || null;
    }
    enqueueJob(syncJob) {
        if (this.jobQueue.length < this.JOB_QUEUE_SIZE) {
            this.jobQueue.push(syncJob);
        }
        else {
            // Remove oldest job when queue reach maximum capacity
            this.jobQueue.shift();
            this.jobQueue.push(syncJob);
        }
    }
}
let instance$4 = null;
var ReadReceiptSyncEngine = {
    getInstance: () => {
        if (!instance$4)
            instance$4 = new MessageReadReceiptSyncEngine();
        return instance$4;
    },
};

/**
 *
 * Mark subChannel as read by readToSegment
 *
 * @param subChannelIds the IDs of the {@link Amity.SubChannel} to update
 * @param readToSegment the segment to mark as read
 * @returns a success boolean if the {@link Amity.SubChannel} was updated
 *
 * @category Channel API
 * @async
 */
const markAsReadBySegment = async ({ subChannelId, readToSegment, }) => {
    const client = getActiveClient();
    client.log('subChannel/markAsReadBySegment', subChannelId);
    try {
        await client.http.put(`/api/v1/markers/message-feeds/${subChannelId}/mark-read`, { readToSegment });
        return true;
    }
    catch (e) {
        return false;
    }
};

const reCalculateChannelUnreadInfo = (channelId) => {
    var _a;
    const cacheKeyChannelUnread = ['channelUnreadInfo', 'get', channelId];
    const cacheChannelUnreadInfo = (_a = pullFromCache(cacheKeyChannelUnread)) === null || _a === void 0 ? void 0 : _a.data;
    const cacheKeySubChannelUnread = ['subChannelUnreadInfo', 'get'];
    const cachedSubChannelUnreadInfo = queryCache(cacheKeySubChannelUnread);
    let channelUnreads = 0;
    let isMentioned = false;
    if (cachedSubChannelUnreadInfo && (cachedSubChannelUnreadInfo === null || cachedSubChannelUnreadInfo === void 0 ? void 0 : cachedSubChannelUnreadInfo.length) > 0) {
        const subChannelUnreadsInfo = cachedSubChannelUnreadInfo === null || cachedSubChannelUnreadInfo === void 0 ? void 0 : cachedSubChannelUnreadInfo.filter(({ data }) => {
            return data.channelId === channelId && !data.isDeleted;
        });
        channelUnreads = subChannelUnreadsInfo
            .map(({ data }) => data.unreadCount)
            .reduce((acc, cur) => acc + cur, 0);
        isMentioned = subChannelUnreadsInfo.some(({ data }) => data.isMentioned);
    }
    const channelUnreadInfo = Object.assign(Object.assign({}, (cacheChannelUnreadInfo !== null && cacheChannelUnreadInfo !== void 0 ? cacheChannelUnreadInfo : {
        channelId,
        createdAt: new Date().toISOString(),
    })), { updatedAt: new Date().toISOString(), unreadCount: channelUnreads, isMentioned });
    pushToCache(cacheKeyChannelUnread, channelUnreadInfo);
    return channelUnreadInfo;
};

class LegacyMessageReadReceiptSyncEngine {
    constructor() {
        this.isActive = true;
        this.MAX_RETRY = 3;
        this.JOB_QUEUE_SIZE = 120;
        this.jobQueue = [];
        // Interval for message read receipt sync in seconds
        this.RECEIPT_SYNC_INTERVAL = 1;
        this.client = getActiveClient();
        // Get remaining unsync read receipts from cache
        this.getUnsyncJobs();
    }
    //  Call this when client call client.login
    startSyncReadReceipt() {
        // Start timer when start receipt sync
        this.timer = setInterval(() => {
            this.syncReadReceipts();
        }, this.RECEIPT_SYNC_INTERVAL * 1000);
    }
    // Read receipt observer handling
    syncReadReceipts() {
        if (this.jobQueue.length === 0 || this.isActive === false)
            return;
        const readReceipt = this.getReadReceipt();
        if (readReceipt) {
            this.markReadApi(readReceipt);
        }
    }
    getUnsyncJobs() {
        var _a;
        // Get all read receipts that has latestSyncSegment < latestSegment
        const readReceipts = (_a = queryCache(['legacyReadReceipt'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
            return data.latestSyncSegment < data.latestSegment;
        });
        // Enqueue unsync read receipts to the job queue
        readReceipts === null || readReceipts === void 0 ? void 0 : readReceipts.forEach(({ data: readReceipt }) => {
            this.enqueueReadReceipt(readReceipt.subChannelId, readReceipt.latestSegment);
        });
    }
    getReadReceipt() {
        var _a;
        // Get first read receipt in queue
        const syncJob = this.jobQueue[0];
        if (!syncJob)
            return;
        // Skip when it's syncing
        if (syncJob.syncState === "syncing" /* Amity.ReadReceiptSyncState.SYNCING */)
            return;
        // Get readReceipt from cache by subChannelId
        const readReceipt = (_a = pullFromCache([
            'legacyReadReceipt',
            syncJob.subChannelId,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (!readReceipt)
            return;
        if ((readReceipt === null || readReceipt === void 0 ? void 0 : readReceipt.latestSegment) > (readReceipt === null || readReceipt === void 0 ? void 0 : readReceipt.latestSyncSegment)) {
            syncJob.segment = readReceipt.latestSegment;
            return syncJob;
        }
        // Clear all synced job in job queue
        this.removeSynedReceipt(readReceipt.subChannelId, readReceipt.latestSegment);
        // Recursion getReadReceipt() until get unsync read receipt or job queue is empty
        return this.getReadReceipt();
    }
    async markReadApi(syncJob) {
        var _a;
        const newSyncJob = syncJob;
        newSyncJob.syncState = "syncing" /* Amity.ReadReceiptSyncState.SYNCING */;
        const { subChannelId, segment } = newSyncJob;
        const response = await markAsReadBySegment({ subChannelId, readToSegment: segment });
        if (response) {
            this.removeSynedReceipt(syncJob.subChannelId, syncJob.segment);
            const readReceiptCache = (_a = pullFromCache([
                'legacyReadReceipt',
                subChannelId,
            ])) === null || _a === void 0 ? void 0 : _a.data;
            pushToCache(['legacyReadReceipt', subChannelId], Object.assign(Object.assign({}, readReceiptCache), { latestSyncSegment: segment }));
        }
        else if (!response) {
            if (newSyncJob.retryCount > this.MAX_RETRY) {
                this.removeJobFromQueue(newSyncJob);
            }
            else {
                newSyncJob.retryCount += 1;
                newSyncJob.syncState = "create" /* Amity.ReadReceiptSyncState.CREATED */;
            }
        }
    }
    removeSynedReceipt(subChannelId, segment) {
        const syncJobs = this.jobQueue;
        syncJobs.forEach(job => {
            if (job.subChannelId === subChannelId && job.segment <= segment) {
                this.removeJobFromQueue(job);
            }
        });
    }
    startObservingReadReceiptQueue() {
        if (this.client.isUnreadCountEnabled) {
            this.isActive = true;
            this.startSyncReadReceipt();
        }
    }
    stopObservingReadReceiptQueue() {
        this.isActive = false;
        const syncJobs = this.jobQueue;
        syncJobs.map(job => {
            if (job.syncState === "syncing" /* Amity.ReadReceiptSyncState.SYNCING */) {
                return Object.assign(Object.assign({}, job), { syncState: "create" /* Amity.ReadReceiptSyncState.CREATED */ });
            }
            return job;
        });
        if (this.timer)
            clearInterval(this.timer);
    }
    // Session Management
    onSessionEstablished() {
        this.startObservingReadReceiptQueue();
    }
    onSessionDestroyed() {
        this.stopObservingReadReceiptQueue();
        this.jobQueue = [];
    }
    onTokenExpired() {
        this.stopObservingReadReceiptQueue();
    }
    // Network Connection Management
    onNetworkOffline() {
        // Stop observing to the read receipt queue.
        this.stopObservingReadReceiptQueue();
    }
    onNetworkOnline() {
        // Resume observing to the read receipt queue.
        this.startObservingReadReceiptQueue();
    }
    markRead(subChannelId, segment) {
        var _a;
        // Step 1: Optimistic update of subChannelUnreadInfo.readToSegment to message.segment
        const cacheKey = ['subChannelUnreadInfo', 'get', subChannelId];
        const subChannelUnreadInfo = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (subChannelUnreadInfo && segment > subChannelUnreadInfo.readToSegment) {
            subChannelUnreadInfo.readToSegment = segment;
            subChannelUnreadInfo.unreadCount = Math.max(subChannelUnreadInfo.lastSegment - segment, 0);
            const channelUnreadInfo = reCalculateChannelUnreadInfo(subChannelUnreadInfo.channelId);
            fireEvent('local.channelUnreadInfo.updated', channelUnreadInfo);
            pushToCache(cacheKey, subChannelUnreadInfo);
            fireEvent('local.subChannelUnread.updated', subChannelUnreadInfo);
        }
        // Step 2: Enqueue the read receipt
        this.enqueueReadReceipt(subChannelId, segment);
    }
    enqueueReadReceipt(subChannelId, segment) {
        var _a;
        const readReceipt = (_a = pullFromCache([
            'legacyReadReceipt',
            subChannelId,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        // Create new read receipt if it's not exists and add job to queue
        if (!readReceipt) {
            const readReceiptSubChannel = {
                subChannelId,
                latestSegment: segment,
                latestSyncSegment: 0,
            };
            pushToCache(['legacyReadReceipt', subChannelId], readReceiptSubChannel);
        }
        else if (readReceipt.latestSegment < segment) {
            pushToCache(['legacyReadReceipt', subChannelId], Object.assign(Object.assign({}, readReceipt), { latestSegment: segment }));
        }
        else if (readReceipt.latestSyncSegment >= segment) {
            // Skip the job when lastSyncSegment > = segment
            return;
        }
        let syncJob = this.getSyncJob(subChannelId);
        if (syncJob === null || syncJob.syncState === "syncing" /* Amity.ReadReceiptSyncState.SYNCING */) {
            syncJob = {
                subChannelId,
                segment,
                syncState: "create" /* Amity.ReadReceiptSyncState.CREATED */,
                retryCount: 0,
            };
            this.enqueueJob(syncJob);
        }
        else if (syncJob.segment < segment) {
            syncJob.segment = segment;
        }
    }
    getSyncJob(subChannelId) {
        const syncJobs = this.jobQueue;
        const targetJob = syncJobs.find(job => job.subChannelId === subChannelId);
        return targetJob || null;
    }
    enqueueJob(syncJob) {
        if (this.jobQueue.length < this.JOB_QUEUE_SIZE) {
            this.jobQueue.push(syncJob);
        }
        else {
            // Remove oldest job when queue reach maximum capacity
            this.jobQueue.shift();
            this.jobQueue.push(syncJob);
        }
    }
    removeJobFromQueue(item) {
        const index = this.jobQueue.indexOf(item);
        if (index > -1) {
            this.jobQueue.splice(index, 1);
        }
    }
}
let instance$3 = null;
var LegacyReadReceiptSyncEngine = {
    getInstance: () => {
        if (!instance$3)
            instance$3 = new LegacyMessageReadReceiptSyncEngine();
        return instance$3;
    },
};

const markReadMessage = (message) => {
    const client = getActiveClient();
    if (client.useLegacyUnreadCount) {
        const markReadReceiptEngine = ReadReceiptSyncEngine.getInstance();
        markReadReceiptEngine.markRead(message.channelId, message.channelSegment);
    }
    else {
        const markReadReceiptEngine = LegacyReadReceiptSyncEngine.getInstance();
        markReadReceiptEngine.markRead(message.subChannelId, message.channelSegment);
    }
};

const messageLinkedObject = (message) => {
    const rest = __rest(message, ["creatorPrivateId"]);
    return Object.assign(Object.assign({}, rest), { get readCount() {
            return getMessageReadCount(message).readCount;
        },
        get deliveredCount() {
            return getMessageReadCount(message).deliveredCount;
        },
        get creator() {
            var _a;
            return (_a = pullFromCache(['user', 'get', message.creatorId])) === null || _a === void 0 ? void 0 : _a.data;
        }, markRead: () => markReadMessage(message) });
};

const reactorLinkedObject = (reactor) => {
    return Object.assign(Object.assign({}, reactor), { get user() {
            var _a;
            const user = (_a = pullFromCache(['user', 'get', reactor.userId])) === null || _a === void 0 ? void 0 : _a.data;
            if (!user)
                return undefined;
            return userLinkedObject(user);
        } });
};

/**
 * ```js
 * import { ChannelRepository } from '@amityco/ts-sdk'
 * const success = await ChannelRepository.markAsRead('channelId')
 * ```
 * Updating all {@link Amity.SubChannel} in specify {@link Amity.Channel} as read
 *
 * @param channelId the ID of to specify {@link Amity.Channel}
 * @returns A success boolean if the {@link Amity.Channel} was mark read
 *
 * @category Channel API
 * @async
 */
const markAsRead = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/markAsRead', channelId);
    const { data } = await client.http.put(`/api/v1/markers/channels/${channelId}/mark-read`);
    const { userMarkers, userEntityMarkers: userEntityMarkersPayload, userFeedMarkers: userFeedMarkersPayload } = data, rest = __rest(data, ["userMarkers", "userEntityMarkers", "userFeedMarkers"]);
    const cachedAt = client.cache && Date.now();
    const channelMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
    const subChannelMarkers = convertSubChannelMarkerResponse(userFeedMarkersPayload);
    if (client.cache)
        ingestInCache(Object.assign({ userMarkers, userEntityMarkers: channelMarkers, userFeedMarkers: subChannelMarkers }, rest), { cachedAt });
    fireEvent('local.channelMarker.updated', {
        userEntityMarkers: channelMarkers,
    });
    fireEvent('local.subChannelMarker.updated', {
        userFeedMarkers: subChannelMarkers,
    });
    return true;
};

/**
 * ```js
 * import { shallowClone } from '~/utils/shallowClone'
 * const newObj = shallowClone(obj)
 * ```
 *
 * Clone an object with same prototype and properties
 *
 * @param obj the object to clone
 * @returns new object with same prototype and properties
 *
 * @category utility
 * @private
 */
function shallowClone(source, target) {
    return Object.create(Object.getPrototypeOf(source), Object.assign(Object.assign({}, Object.getOwnPropertyDescriptors(source)), Object.getOwnPropertyDescriptors(target)));
}

const channelLinkedObject = (channel) => {
    return shallowClone(channel, {
        markAsRead: () => markAsRead(channel.channelInternalId),
    });
};

const adLinkedObject = (ad) => {
    const analyticsEngineInstance = AnalyticsEngine$1.getInstance();
    const { image9_16: image916, image1_1: image11 } = ad, restAds = __rest(ad, ["image9_16", "image1_1"]);
    return Object.assign(Object.assign({}, restAds), { analytics: {
            markAsSeen: (placement) => {
                analyticsEngineInstance.markAdAsViewed(ad, placement);
            },
            markLinkAsClicked: (placement) => {
                analyticsEngineInstance.markAdAsClicked(ad, placement);
            },
        }, get advertiser() {
            var _a, _b;
            const advertiserData = (_a = pullFromCache([
                'advertiser',
                'get',
                ad.advertiserId,
            ])) === null || _a === void 0 ? void 0 : _a.data;
            if (!advertiserData)
                return;
            const avatarFile = (_b = pullFromCache([
                'file',
                'get',
                advertiserData.avatarFileId,
            ])) === null || _b === void 0 ? void 0 : _b.data;
            return Object.assign(Object.assign({}, advertiserData), { avatar: avatarFile });
        },
        get image1_1() {
            const cacheData = pullFromCache(['file', 'get', image11]);
            if (!cacheData)
                return undefined;
            return cacheData.data || undefined;
        },
        get image9_16() {
            const cacheData = pullFromCache(['file', 'get', image916]);
            if (!cacheData)
                return undefined;
            return cacheData.data || undefined;
        } });
};

const pinnedPostLinkedObject = (pinnedPost) => {
    var _a;
    const postCached = pullFromCache(['post', 'get', pinnedPost.referenceId]);
    const pinnedBy = (_a = queryCache(['user', 'get']).find(cache => {
        var _a;
        return ((_a = cache.data) === null || _a === void 0 ? void 0 : _a.userInternalId) === pinnedPost.pinnedBy;
    })) === null || _a === void 0 ? void 0 : _a.data;
    return Object.assign(Object.assign({}, pinnedPost), { pinnedBy,
        get post() {
            if (!(postCached === null || postCached === void 0 ? void 0 : postCached.data))
                return;
            return postLinkedObject(postCached.data);
        },
        get target() {
            const pinTarget = pullFromCache([
                'pinTarget',
                'get',
                postCached === null || postCached === void 0 ? void 0 : postCached.data.targetId,
            ]);
            if (!(pinTarget === null || pinTarget === void 0 ? void 0 : pinTarget.data))
                return;
            return pinTarget === null || pinTarget === void 0 ? void 0 : pinTarget.data;
        } });
};

const notificationTrayLinkedObject = (noti) => {
    return Object.assign(Object.assign({}, noti), { isSeen: noti.lastSeenAt > noti.lastOccurredAt, isRecent: new Date(noti.lastOccurredAt).getTime() >= Date.now() - WEEK, users: noti.actors
            .map(({ publicId }) => pullFromCache(['user', 'get', publicId]))
            .filter(isNonNullable)
            .map(({ data }) => data)
            .map(user => userLinkedObject(user)) });
};

const LinkedObject = {
    ad: adLinkedObject,
    comment: commentLinkedObject,
    post: postLinkedObject,
    user: userLinkedObject,
    category: categoryLinkedObject,
    stream: streamLinkedObject,
    story: storyLinkedObject,
    storyTarget: storyTargetLinkedObject,
    message: messageLinkedObject,
    reactor: reactorLinkedObject,
    channel: channelLinkedObject,
    pinnedPost: pinnedPostLinkedObject,
    notificationTray: notificationTrayLinkedObject,
};

const getChannelMessagePreviewWithUser = (channel) => {
    var _a;
    const messagePreview = channel.messagePreviewId
        ? getChannelMessagePreview(channel.channelId)
        : null;
    const internalUser = (_a = pullFromCache([
        'user',
        'get',
        messagePreview === null || messagePreview === void 0 ? void 0 : messagePreview.creatorId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    const messagePreviewWithUser = messagePreview
        ? Object.assign(Object.assign({}, messagePreview), { user: internalUser ? LinkedObject.user(internalUser) : undefined }) : null;
    return Object.assign(Object.assign({}, channel), { messagePreview: messagePreviewWithUser });
};

const updateChannelMessagePreviewCache = (rawPayload) => {
    var _a, _b;
    const withMessageFeedInfo = (messagePreview) => {
        var _a;
        const messageFeedInfo = (_a = rawPayload.messageFeedsInfo) === null || _a === void 0 ? void 0 : _a.find(messageFeed => {
            return messageFeed.messageFeedId === messagePreview.messageFeedId;
        });
        const { channelPublicId: channelId, messageFeedId: subChannelId, data, dataType, isDeleted, segment, creatorPublicId: creatorId, createdAt, updatedAt, } = messagePreview;
        return {
            channelId,
            subChannelId,
            data,
            dataType,
            isDeleted,
            segment,
            creatorId,
            createdAt,
            updatedAt,
            subChannelName: messageFeedInfo === null || messageFeedInfo === void 0 ? void 0 : messageFeedInfo.name,
            messagePreviewId: messageFeedInfo === null || messageFeedInfo === void 0 ? void 0 : messageFeedInfo.messagePreviewId,
            subChannelUpdatedAt: messageFeedInfo === null || messageFeedInfo === void 0 ? void 0 : messageFeedInfo.updatedAt,
        };
    };
    const newData = {
        messagePreviewChannel: (_b = (_a = rawPayload.messagePreviews) === null || _a === void 0 ? void 0 : _a.map(messagePreview => withMessageFeedInfo(messagePreview))) !== null && _b !== void 0 ? _b : [],
    };
    ingestInCache(newData);
};

const getSubChannelMessagePreview = (subChannelId) => {
    var _a, _b;
    return ((_b = (_a = pullFromCache(['messagePreviewSubChannel', 'get', subChannelId])) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : null);
};

const getSubChannelMessagePreviewWithUser = (subChannel) => {
    var _a;
    const messagePreview = subChannel.messagePreviewId
        ? getSubChannelMessagePreview(subChannel.subChannelId)
        : null;
    const messagePreviewWithUser = messagePreview
        ? Object.assign(Object.assign({}, messagePreview), { user: (_a = pullFromCache(['user', 'get', messagePreview === null || messagePreview === void 0 ? void 0 : messagePreview.creatorId])) === null || _a === void 0 ? void 0 : _a.data }) : null;
    return Object.assign(Object.assign({}, subChannel), { messagePreview: messagePreviewWithUser });
};

const updateSubChannelMessagePreviewCache = (rawPayload) => {
    var _a, _b;
    const withMessageFeedInfo = (messagePreview) => {
        var _a;
        const messageFeedInfo = (_a = rawPayload.messageFeeds) === null || _a === void 0 ? void 0 : _a.find(messageFeed => {
            return messageFeed.messageFeedId === messagePreview.messageFeedId;
        });
        const { channelPublicId: channelId, messageFeedId: subChannelId, messageId: messagePreviewId, creatorPublicId: creatorId, data, dataType, isDeleted, segment, createdAt, updatedAt, } = messagePreview;
        return {
            messagePreviewId,
            channelId,
            subChannelId,
            data,
            dataType,
            isDeleted,
            segment,
            creatorId,
            createdAt,
            updatedAt,
            subChannelName: messageFeedInfo === null || messageFeedInfo === void 0 ? void 0 : messageFeedInfo.name,
            subChannelUpdatedAt: messageFeedInfo === null || messageFeedInfo === void 0 ? void 0 : messageFeedInfo.updatedAt,
        };
    };
    const newData = {
        messagePreviewSubChannel: (_b = (_a = rawPayload.messages) === null || _a === void 0 ? void 0 : _a.map(messagePreview => withMessageFeedInfo(messagePreview))) !== null && _b !== void 0 ? _b : [],
    };
    ingestInCache(newData);
};

function updateSubChannelCache(subChannelId, subChannel, params) {
    pushToCache(['subChannel', 'get', subChannelId], 
    // eslint-disable-next-line prefer-object-spread
    shallowClone(subChannel, params));
}

/**
 * ```js
 * import { isInTombstone } from '@amityco/ts-sdk'
 * const user = isInTombstone(["message", "messageId"])
 * ```
 *
 * Checks if the {@link Amity.TombstoneCacheOptions} exists
 * in cache and it's not expired means it's in tombstone
 * and we throw an Error
 *
 * @param model the model to check
 * @param modelId the object id to check
 * @returns the matching cache entry, or undefined.
 *
 * @category Cache API
 */
const isInTombstone = (model, modelId) => {
    const { log, cache } = getActiveClient();
    const key = [model, CACHE_KEY_TOMBSTONE, modelId];
    if (!cache)
        return;
    log('cache/api/isInTombstone', key);
    const isInTombstone = pullFromCache(key);
    const { lifeSpan } = queryOptions('cache_then_server', CACHE_LIFESPAN_TOMBSTONE);
    if (isInTombstone && isFresh(isInTombstone.data, lifeSpan)) {
        throw new ASCApiError('Item not found!', 400400 /* Amity.ServerError.ITEM_NOT_FOUND */, "error" /* Amity.ErrorLevel.ERROR */);
    }
};

/**
 * ```js
 * import { getMessageMarkers } from '@amityco/ts-sdk'
 * const messageMarkers = await getMessageMarkers(['sch1', 'sch2'])
 * ```
 *
 * Fetches a list of {@link Amity.MessageMarker} by messageIds
 *
 * @param messageIds the feed IDs of the {@link Amity.RawMessage} marker to fetch
 * @returns A list of {@link Amity.MessageMarker} by messageIds
 *
 * @category Channel API
 * @async
 * @private
 */
const getMessageMarkers = async (messageIds) => {
    const client = getActiveClient();
    client.log('channel/getMessageMarkers', messageIds);
    const { data: queryPayload } = await client.http.get(`/api/v1/markers/messages`, {
        params: {
            messageIds,
        },
    });
    const { contentMarkers, feedMarkers, userMarkers } = queryPayload;
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ contentMarkers, feedMarkers, userMarkers }, { cachedAt });
    fireEvent('local.feedMarker.fetched', { feedMarkers });
    fireEvent('local.messageMarker.fetched', { contentMarkers });
    fireEvent('local.userMarker.fetched', { userMarkers });
    return { data: contentMarkers, cachedAt };
};

const persistUnreadCountInfo = (payload) => {
    const { feedMarkers, userFeedMarkers } = payload;
    // calculate sub channel unread info and channel unread info
    if (feedMarkers.length > 0 && userFeedMarkers.length > 0) {
        const channelIds = [];
        const feedMarkerMap = new Map(feedMarkers.map(fm => [fm.feedId, fm]));
        userFeedMarkers.forEach(userFeedMarker => {
            const feedMarker = feedMarkerMap.get(userFeedMarker.feedId);
            if (!feedMarker)
                return;
            if (feedMarker.feedId === userFeedMarker.feedId) {
                const unreadCount = feedMarker.lastSegment - userFeedMarker.readToSegment;
                const subChannelUnreadInfo = {
                    subChannelId: feedMarker.feedId,
                    channelId: feedMarker.entityId,
                    readToSegment: userFeedMarker.readToSegment,
                    lastSegment: feedMarker.lastSegment,
                    lastMentionSegment: userFeedMarker.lastMentionSegment,
                    unreadCount: Math.max(0, unreadCount),
                    isMentioned: userFeedMarker.isMentioned,
                    isDeleted: feedMarker.isDeleted,
                    createdAt: userFeedMarker.createdAt,
                    updatedAt: userFeedMarker.updatedAt,
                };
                // update sub channel unread info in cache
                ingestInCache({ subChannelUnreadInfo: [subChannelUnreadInfo] });
                if (!channelIds.includes(feedMarker.entityId)) {
                    channelIds.push(feedMarker.entityId);
                }
            }
        });
        // re-calculate channel unread info in cache
        channelIds.forEach(channelId => {
            reCalculateChannelUnreadInfo(channelId);
        });
    }
};

/**
 * ```js
 * import { getSubChannelMarkers } from '@amityco/ts-sdk'
 * const subChannelMarkers = await getSubChannelMarkers(['sch1', 'sch2'])
 * ```
 *
 * Fetches a paginable list of {@link Amity.SubChannelMarker} objects
 *
 * @param messageFeedIds the feed IDs of the {@link Amity.RawSubChannel} marker to fetch
 * @param page
 * @returns A page of {@link Amity.SubChannelMarker} objects
 *
 * @category Channel API
 * @async
 * @private
 */
const getSubChannelMarkers = async (messageFeedIds, page = { limit: 100 }) => {
    const client = getActiveClient();
    client.log('channel/getSubChannelMarkers', messageFeedIds, page);
    const { data: queryPayload } = await client.http.get(`/api/v1/markers/message-feeds`, {
        params: {
            messageFeedIds,
            options: {
                token: toToken(page, 'skiplimit'),
            },
        },
    });
    const { paging } = queryPayload, payload = __rest(queryPayload, ["paging"]);
    const { userEntityMarkers: userEntityMarkersPayload, userFeedMarkers: userFeedMarkersPayload, userMarkers, feedMarkers: feedMarkersPayload, } = payload;
    // if consistent mode is enabled, persist the unread count info to the cache
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        persistUnreadCountInfo({
            feedMarkers: feedMarkersPayload,
            userFeedMarkers: userFeedMarkersPayload,
        });
    }
    const userEntityMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
    const userFeedMarkers = convertSubChannelMarkerResponse(userFeedMarkersPayload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ userEntityMarkers, userFeedMarkers, userMarkers }, { cachedAt });
    fireEvent('local.channelMarker.fetched', { userEntityMarkers });
    fireEvent('local.subChannelMarker.fetched', { userFeedMarkers });
    fireEvent('local.userMarker.fetched', { userMarkers });
    const nextPage = toPage(paging.next);
    const prevPage = toPage(paging.previous);
    return { data: userFeedMarkers, cachedAt, prevPage, nextPage };
};

const getUserMarker = async () => {
    const client = getActiveClient();
    client.log('channel/getUserMarker');
    const { data: payload } = await client.http.get(`/api/v1/markers/userMarker`);
    const { userMarkers } = payload;
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ userMarkers }, { cachedAt });
    fireEvent('local.userMarker.fetched', { userMarkers });
    const latestUserMarker = userMarkers.reduce((maxUserMarker, userMarker) => {
        if (maxUserMarker == null ||
            new Date(maxUserMarker.lastSyncAt).getTime() < new Date(userMarker.lastSyncAt).getTime()) {
            return userMarker;
        }
        return maxUserMarker;
    }, undefined);
    return { data: latestUserMarker, cachedAt };
};

/** @hidden */
/*
 * @param message payload from http request without myReactions
 * add myReactions to http response if the event was a reaction event
 */
const prepareMessagePayloadForCache = (payload, reactors, event) => {
    const client = getActiveClient();
    const cached = pullFromCache(['message', 'get', payload.messageId]);
    // '[]' in cases where the new reaction is the first one
    const myReactions = (cached === null || cached === void 0 ? void 0 : cached.data.myReactions) || [];
    // add myReactions to the payload
    Object.assign(payload, { myReactions });
    // check if there are any updates to the reactions
    const latestReaction = reactors[0];
    const isLatestReactionMine = latestReaction && latestReaction.userId === client.userId;
    if (!isLatestReactionMine) {
        return;
    }
    // new reaction added
    if (event === 'message.reactionAdded' && !myReactions.includes(latestReaction.reactionName)) {
        Object.assign(payload, {
            myReactions: [...myReactions, latestReaction.reactionName],
        });
    }
    // existing reaction removed
    if (event === 'message.reactionRemoved' && myReactions.includes(latestReaction.reactionName)) {
        Object.assign(payload, {
            myReactions: myReactions.filter(x => x !== latestReaction.reactionName),
        });
    }
};

/*
 * This is a simple utility that infers the value of isDeleted based on the
 * value of includeDeleted
 *
 * There are two important things to note here:
 *  1. `includeDeleted` is purely client side query param and not recognized by
 *  the server
 *  2. The only values we wish to expose with regards to `isDeleted` (the server
 *  param for queries) is false | undefined and want to disallow users to query
 *  for deleted entities
 *
 *  Although this is a very simple utility, it's only purpose is to keep things
 *  DRY
 */
const inferIsDeleted = (includeDeleted) => includeDeleted === true ? undefined : false;

function getSubChannelIsMentioned(channelId, subChannelId, marker) {
    var _a, _b;
    // Look for `unreadCount` in the marker param first
    if (marker) {
        return marker.hasMentioned;
    }
    const client = getActiveClient();
    // If consistent mode is enabled, look in the SubChannelUnreadCountInfo cache
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        const cachedUnreadCount = (_a = pullFromCache([
            'subChannelUnreadInfo',
            'get',
            subChannelId,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (cachedUnreadCount) {
            return cachedUnreadCount.isMentioned;
        }
        return false;
    }
    const key = {
        entityId: channelId,
        feedId: subChannelId,
        userId: getActiveUser()._id,
    };
    // If the marker param is not set, look in the cache
    const cachedMarker = (_b = pullFromCache([
        'subChannelMarker',
        'get',
        getResolver('subChannelMarker')(key),
    ])) === null || _b === void 0 ? void 0 : _b.data;
    if (cachedMarker) {
        return cachedMarker.hasMentioned;
    }
    // and if not found in cache use default value `false`
    return false;
}

function getSubChannelUnreadCount(channelId, subChannelId, marker) {
    var _a, _b;
    // Look for `unreadCount` in the marker param first
    if (marker) {
        return marker.unreadCount;
    }
    const client = getActiveClient();
    // If consistent mode is enabled, look in the SubChannelUnreadCountInfo cache
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        const cachedUnreadCount = (_a = pullFromCache([
            'subChannelUnreadInfo',
            'get',
            subChannelId,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (cachedUnreadCount) {
            return cachedUnreadCount.isDeleted ? 0 : cachedUnreadCount.unreadCount;
        }
        return 0;
    }
    const key = {
        entityId: channelId,
        feedId: subChannelId,
        userId: getActiveUser()._id,
    };
    // If the marker param is not set, look in the cache
    const cachedMarker = (_b = pullFromCache([
        'subChannelMarker',
        'get',
        getResolver('subChannelMarker')(key),
    ])) === null || _b === void 0 ? void 0 : _b.data;
    if (cachedMarker) {
        return cachedMarker.unreadCount;
    }
    // and if not found in cache use default value `0`
    return 0;
}

const MARKER_INCLUDED_SUB_CHANNEL_TYPE$1 = ['broadcast', 'conversation', 'community'];
const isUnreadCountSupport$2 = ({ channelType }) => MARKER_INCLUDED_SUB_CHANNEL_TYPE$1.includes(channelType);
function convertFromRaw$2(_a) {
    var { channelId, channelPublicId, channelType, childCount, creatorId, creatorPublicId, lastMessageId, lastMessageTimestamp, messageFeedId, name } = _a, rest = __rest(_a, ["channelId", "channelPublicId", "channelType", "childCount", "creatorId", "creatorPublicId", "lastMessageId", "lastMessageTimestamp", "messageFeedId", "name"]);
    return Object.assign(Object.assign({ get unreadCount() {
            return getSubChannelUnreadCount(channelId, messageFeedId);
        },
        get hasMentioned() {
            return getSubChannelIsMentioned(channelId, messageFeedId);
        },
        get isMentioned() {
            return getSubChannelIsMentioned(channelId, messageFeedId);
        } }, rest), { channelId: channelPublicId, creatorId: creatorPublicId, displayName: name, lastActivity: lastMessageTimestamp, latestMessageId: lastMessageId, messageCount: childCount, subChannelId: messageFeedId, isUnreadCountSupport: isUnreadCountSupport$2({ channelType }) });
}

const mergePayloadWithLocal = (payload) => {
    var _a, _b, _c;
    const localMessage = (_b = (_a = queryCache(['message', 'get'])) === null || _a === void 0 ? void 0 : _a.find(({ data }) => data.messageId === payload.messageId)) === null || _b === void 0 ? void 0 : _b.data;
    if (localMessage) {
        return Object.assign(Object.assign(Object.assign({}, localMessage), payload), { 
            // NOTE: referenceId is missing in the some payload event. If we have local message data with referenceId, use it instead.
            referenceId: (_c = localMessage.referenceId) !== null && _c !== void 0 ? _c : payload.referenceId });
    }
    return payload;
};
function convertFromRaw$1(message, reactors, event) {
    var _a;
    const mergeMessage = mergePayloadWithLocal(message);
    const { channelPublicId, childCount, creatorPublicId, mentionedUsers, messageFeedId, myReactions, reactionCount, reactions, referenceId, segment, messageId, creatorId } = mergeMessage, rest = __rest(mergeMessage, ["channelPublicId", "childCount", "creatorPublicId", "mentionedUsers", "messageFeedId", "myReactions", "reactionCount", "reactions", "referenceId", "segment", "messageId", "creatorId"]);
    let cache;
    if (referenceId) {
        cache = pullFromCache(['message', 'get', referenceId]);
    }
    if (!cache) {
        cache = pullFromCache(['message', 'get', messageId]);
    }
    const out = Object.assign(Object.assign({}, rest), { messageId, channelId: channelPublicId, channelSegment: segment, childrenNumber: childCount, creatorId: creatorPublicId, creatorPrivateId: message.creatorId, reactions: reactions !== null && reactions !== void 0 ? reactions : {}, 
        /*
         * Previously, myReactions were added only if it was part of the payload.
         * So empty myReactions were not present. So I've edited the payload to add
         * a default for those cases.
         *
         * Check git blame for previous iteration
         */
        myReactions: myReactions || ((_a = cache === null || cache === void 0 ? void 0 : cache.data.myReactions) !== null && _a !== void 0 ? _a : []), reactionsCount: reactionCount, subChannelId: messageFeedId, uniqueId: cache ? cache.data.uniqueId : messageId, referenceId, syncState: "synced" /* Amity.SyncState.Synced */ });
    if (mentionedUsers) {
        out.mentionees = mentionedUsers.map(mention => {
            if (mention.type === 'channel') {
                return mention;
            }
            return { type: 'user', userIds: mention.userPublicIds };
        });
    }
    if (reactors && reactors.length && event) {
        // mqtt event
        prepareMessagePayloadForCache(out, reactors, event);
    }
    return out;
}
const preUpdateMessageCache = (rawPayload) => {
    ingestInCache({
        messages: rawPayload.messages.map(message => convertFromRaw$1(message, rawPayload.reactions)),
    });
};
const DEBOUNCE_TIME = 2000;
const currentDebounceMap = {};
const prepareMessagePayload = async (payload, event) => {
    const markerIds = payload.messages.map(({ messageId }) => messageId);
    if (markerIds.length > 0) {
        // since the get markers method requires a channel cache to function with the reducer.
        preUpdateMessageCache(payload);
        const markerIdsKey = markerIds.join('');
        if (currentDebounceMap[markerIdsKey]) {
            clearTimeout(currentDebounceMap[markerIdsKey]);
        }
        currentDebounceMap[markerIdsKey] = setTimeout(() => {
            try {
                getMessageMarkers(markerIds);
            }
            catch (_error) {
                // do nothing
            }
        }, DEBOUNCE_TIME);
    }
    const { messageFeeds } = payload, restPayload = __rest(payload, ["messageFeeds"]);
    // upsert messageFeeds to subchannel cache because messageFeeds from event payload not include messagePreviewId
    if (messageFeeds && messageFeeds.length > 0) {
        messageFeeds === null || messageFeeds === void 0 ? void 0 : messageFeeds.forEach(messageFeed => {
            var _a, _b;
            const subChannelCache = (_b = (_a = pullFromCache(['subChannel', 'get', messageFeed.messageFeedId])) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {};
            // exclude getter properties from existing subChannel cache, update only other properties to existing subChannel cache
            const _c = convertFromRaw$2(messageFeed), restSubChannel = __rest(_c, ["unreadCount", "isMentioned"]);
            updateSubChannelCache(messageFeed.messageFeedId, subChannelCache, restSubChannel);
        });
    }
    return Object.assign(Object.assign({}, restPayload), { messages: payload.messages.map(m => convertFromRaw$1(m, payload.reactions, event)) });
};
function convertParams(_a) {
    var { subChannelId, mentionees, dataType, data } = _a, rest = __rest(_a, ["subChannelId", "mentionees", "dataType", "data"]);
    if (dataType === MessageContentType.IMAGE || dataType === MessageContentType.FILE) {
        return Object.assign({ messageFeedId: subChannelId, mentionedUsers: mentionees, dataType, data: Object.assign({ caption: '' }, data) }, rest);
    }
    return Object.assign({ messageFeedId: subChannelId, mentionedUsers: mentionees, dataType, data }, rest);
}
function convertQueryParams$1(_a) {
    var { sortBy, subChannelId, includingTags, excludingTags, includeDeleted, aroundMessageId, limit, type } = _a, rest = __rest(_a, ["sortBy", "subChannelId", "includingTags", "excludingTags", "includeDeleted", "aroundMessageId", "limit", "type"]);
    const out = Object.assign(Object.assign({}, rest), { messageFeedId: subChannelId, isDeleted: inferIsDeleted(includeDeleted), options: {
            sortBy,
            limit: limit || COLLECTION_DEFAULT_PAGINATION_LIMIT,
            around: aroundMessageId,
        } });
    if (includingTags) {
        out.includeTags = includingTags;
    }
    if (type) {
        out.dataType = type;
    }
    if (excludingTags) {
        out.excludeTags = excludingTags;
    }
    return out;
}

const MARKER_INCLUDED_SUB_CHANNEL_TYPE = ['broadcast', 'conversation', 'community'];
/**
 * Filter sub channel by type. Only conversation, community and broadcast type are included.
 */
const isUnreadCountSupport$1 = ({ channelType }) => MARKER_INCLUDED_SUB_CHANNEL_TYPE.includes(channelType);
const preUpdateSubChannelCache = (rawPayload) => {
    ingestInCache({
        messageFeeds: rawPayload.messageFeeds.map(messageFeed => convertFromRaw$2(messageFeed)),
    });
};
const prepareSubChannelPayload = async (rawPayload) => {
    const markerIds = rawPayload.messageFeeds
        .filter(isUnreadCountSupport$1)
        .map(({ messageFeedId }) => messageFeedId);
    if (markerIds.length > 0) {
        // since the get markers method requires a channel cache to function with the reducer.
        preUpdateSubChannelCache(rawPayload);
        try {
            await getSubChannelMarkers(markerIds);
        }
        catch (e) {
            // empty block (from the spec, allow marker fetch to fail without having to do anything)
        }
    }
    updateSubChannelMessagePreviewCache(rawPayload);
    // attach marker to sub channel
    const messageFeeds = rawPayload.messageFeeds.map(convertFromRaw$2);
    const messages = rawPayload.messages.map(m => convertFromRaw$1(m));
    return Object.assign(Object.assign({}, rawPayload), { messageFeeds,
        messages });
};
function convertQueryParams(_a) {
    var { excludeDefaultSubChannel } = _a, rest = __rest(_a, ["excludeDefaultSubChannel"]);
    const out = Object.assign({}, rest);
    if (excludeDefaultSubChannel !== undefined) {
        out.excludeDefaultMessageFeed = excludeDefaultSubChannel;
    }
    return out;
}

/**
 * ```js
 * import { getSubChannel } from '@amityco/ts-sdk'
 * const subChannel = await getSubChannel('foobar')
 * ```
 *
 * Fetches a {@link Amity.SubChannel} object
 *
 * @param subChannelId the ID of the {@link Amity.SubChannel} to fetch
 * @returns the associated {@link Amity.SubChannel} object
 *
 * @category Channel API
 * @async
 */
const getSubChannel$1 = async (subChannelId) => {
    const client = getActiveClient();
    client.log('channel/getSubChannel', subChannelId);
    isInTombstone('subChannel', subChannelId);
    try {
        const response = await client.http.get(`/api/v5/message-feeds/${encodeURIComponent(subChannelId)}`);
        const data = await prepareSubChannelPayload(response.data);
        const cachedAt = client.cache && Date.now();
        if (client.cache)
            ingestInCache(data, { cachedAt });
        fireEvent('local.message-feed.fetched', data);
        return {
            data: data.messageFeeds[0],
            cachedAt,
        };
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('subChannel', subChannelId);
        }
        throw error;
    }
};
/**
 * ```js
 * import { getSubChannel } from '@amityco/ts-sdk'
 * const subChannel = getSubChannel.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.SubChannel} object from cache
 *
 * @param subChannelId the ID of the {@link Amity.SubChannel} to fetch
 * @returns the associated {@link Amity.SubChannel} object
 *
 * @category Channel API
 */
getSubChannel$1.locally = (subChannelId) => {
    const client = getActiveClient();
    client.log('channel/getSubChannel.locally', subChannelId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['subChannel', 'get', subChannelId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

const convertDateStringToTimestamp = (dateString) => {
    return new Date(dateString).getTime();
};

const getMessagePreviewSetting$1 = async () => {
    const client = getActiveClient();
    return client.getMessagePreviewSetting(false);
};
const getSubChannelCache = async (subChannelId) => {
    var _a;
    let subChannelCache = (_a = pullFromCache(['subChannel', 'get', subChannelId])) === null || _a === void 0 ? void 0 : _a.data;
    if (!subChannelCache) {
        subChannelCache = (await getSubChannel$1(subChannelId)).data;
    }
    return subChannelCache;
};
const isLastestMessageOnSubchannel = (message) => {
    var _a;
    const cache = (_a = pullFromCache([
        'messagePreviewSubChannel',
        'get',
        message.subChannelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    // The message payload from optimistic created event has no segment, so we check createdAt instead.
    return (!cache ||
        cache.segment <= message.channelSegment ||
        convertDateStringToTimestamp(cache.createdAt) <= convertDateStringToTimestamp(message.createdAt));
};
const isLastestMessageOnChannel = (message) => {
    var _a;
    const cache = (_a = pullFromCache([
        'messagePreviewChannel',
        'get',
        message.channelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    return (!cache ||
        convertDateStringToTimestamp(cache.createdAt) <= convertDateStringToTimestamp(message.createdAt));
};
const handleMessageCreatedOnSubChannel = async (message) => {
    const messagePreviewSetting = await getMessagePreviewSetting$1();
    const { channelId, messageId: messagePreviewId, creatorId, createdAt, updatedAt, data, dataType, subChannelId, channelSegment: segment, isDeleted, } = message;
    // 1. get subChannel from cache, if not exist fetch from server
    const subChannelCache = await getSubChannelCache(subChannelId);
    // 2. if messagePreviewSetting is NO_MESSAGE_PREVEIW, update only lastActiviy in subChannel cache
    if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */) {
        // 2.1 if the message is the latest message, update lastActivity to be createdAt in subChannel cache
        if (convertDateStringToTimestamp(subChannelCache.lastActivity) <
            convertDateStringToTimestamp(createdAt))
            updateSubChannelCache(message.subChannelId, subChannelCache, {
                lastActivity: createdAt,
            });
        return;
    }
    // 3. if messagePreviewSetting is `NOT` NO_MESSAGE_PREVEIW, update messagePreviewSubChannel and subChannel cache
    // 3.1 check if the message is the latest message, if not ignore the message.
    if (!isLastestMessageOnSubchannel(message))
        return;
    // 3.2 if the message is the latest message, update messagePreviewSubChannel and subChannel cache
    pushToCache(['messagePreviewSubChannel', 'get', message.subChannelId], {
        channelId,
        creatorId,
        messagePreviewId,
        createdAt,
        updatedAt,
        subChannelId,
        data,
        dataType,
        segment,
        isDeleted,
        subChannelUpdatedAt: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.updatedAt,
        subChannelName: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.displayName,
    });
    updateSubChannelCache(message.subChannelId, subChannelCache, {
        lastActivity: createdAt,
        messagePreviewId,
    });
};
const handleMessageUpdatedOnSubChannel = async (message) => {
    var _a;
    const { channelId, messageId: messagePreviewId, creatorId, createdAt, updatedAt, data, dataType, subChannelId, channelSegment: segment, isDeleted, } = message;
    const messagePreviewSubChannelCache = (_a = pullFromCache([
        'messagePreviewSubChannel',
        'get',
        message.subChannelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    // if messagePreviewSubChannel is not exist, ignore the message.
    if (messagePreviewSubChannelCache &&
        messagePreviewSubChannelCache.messagePreviewId === message.messageId) {
        const subChannelCache = await getSubChannelCache(subChannelId);
        pushToCache(['messagePreviewSubChannel', 'get', message.subChannelId], {
            channelId,
            creatorId,
            messagePreviewId,
            createdAt,
            updatedAt,
            subChannelId,
            data,
            dataType,
            segment,
            isDeleted,
            subChannelUpdatedAt: subChannelCache.updatedAt,
            subChannelName: messagePreviewSubChannelCache.subChannelName,
        });
    }
};
const handleMessageCreated = async (message) => {
    const { channelId, messageId: messagePreviewId, creatorId, createdAt, updatedAt, data, dataType, subChannelId, channelSegment: segment, isDeleted, } = message;
    if (isLastestMessageOnChannel(message)) {
        const subChannelCache = await getSubChannelCache(subChannelId);
        pushToCache(['messagePreviewChannel', 'get', message.channelId], {
            channelId,
            creatorId,
            messagePreviewId,
            createdAt,
            updatedAt,
            subChannelId,
            data,
            dataType,
            segment,
            isDeleted,
            subChannelUpdatedAt: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.updatedAt,
            subChannelName: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.displayName,
        });
    }
};
const handleMessageUpdated = async (message) => {
    /**
     * Channel Case
     */
    var _a;
    const { channelId, messageId: messagePreviewId, creatorId, createdAt, updatedAt, data, dataType, subChannelId, channelSegment: segment, isDeleted, } = message;
    const messagePreviewChannelCache = (_a = pullFromCache([
        'messagePreviewChannel',
        'get',
        message.channelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (messagePreviewChannelCache &&
        messagePreviewChannelCache.messagePreviewId === message.messageId) {
        const subChannelCache = await getSubChannelCache(subChannelId);
        pushToCache(['messagePreviewChannel', 'get', message.channelId], {
            channelId,
            creatorId,
            messagePreviewId,
            createdAt,
            updatedAt,
            subChannelId,
            data,
            dataType,
            segment,
            isDeleted,
            subChannelUpdatedAt: subChannelCache.updatedAt,
            subChannelName: messagePreviewChannelCache.subChannelName,
        });
    }
};
const handleSubChannelUpdated = async (subChannel) => {
    var _a, _b, _c, _d;
    const { channelId, subChannelId } = subChannel;
    /** Channel Case */
    const messagePreviewChannelCache = (_a = pullFromCache([
        'messagePreviewChannel',
        'get',
        channelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if ((messagePreviewChannelCache === null || messagePreviewChannelCache === void 0 ? void 0 : messagePreviewChannelCache.subChannelId) === subChannelId) {
        const subChannelCache = (_b = pullFromCache([
            'subChannel',
            'get',
            subChannelId,
        ])) === null || _b === void 0 ? void 0 : _b.data;
        pushToCache(['messagePreviewChannel', 'get', channelId], Object.assign(Object.assign({}, messagePreviewChannelCache), { subChannelName: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.displayName, subChannelUpdatedAt: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.updatedAt }));
    }
    /** SubChannel Case */
    const messagePreviewSubChannelCache = (_c = pullFromCache([
        'messagePreviewSubChannel',
        'get',
        subChannelId,
    ])) === null || _c === void 0 ? void 0 : _c.data;
    if (messagePreviewSubChannelCache &&
        new Date(messagePreviewSubChannelCache.updatedAt).valueOf() >
            new Date(subChannel.updatedAt).valueOf()) {
        const subChannelCache = (_d = pullFromCache([
            'subChannel',
            'get',
            subChannelId,
        ])) === null || _d === void 0 ? void 0 : _d.data;
        pushToCache(['messagePreviewSubChannel', 'get', subChannelId], Object.assign(Object.assign({}, messagePreviewSubChannelCache), { subChannelName: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.displayName, subChannelUpdatedAt: subChannelCache === null || subChannelCache === void 0 ? void 0 : subChannelCache.updatedAt }));
    }
};

function convertRawUserToInternalUser(rawUser) {
    return Object.assign(Object.assign({}, rawUser), { isGlobalBanned: (rawUser === null || rawUser === void 0 ? void 0 : rawUser.isGlobalBan) || false });
}

const MARKER_INCLUDED_CHANNEL_TYPE = ['broadcast', 'conversation', 'community'];
const isUnreadCountSupport = ({ type }) => MARKER_INCLUDED_CHANNEL_TYPE.includes(type);
function convertFromRaw(channel, options = { isMessagePreviewUpdated: true }) {
    var _a;
    let { messagePreviewId } = channel;
    const messagePreviewChannelCache = (_a = pullFromCache([
        'messagePreviewChannel',
        'get',
        channel.channelId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if ((messagePreviewChannelCache === null || messagePreviewChannelCache === void 0 ? void 0 : messagePreviewChannelCache.messagePreviewId) && !options.isMessagePreviewUpdated) {
        messagePreviewId = messagePreviewChannelCache.messagePreviewId;
    }
    return Object.assign(Object.assign({}, channel), { defaultSubChannelId: channel.channelInternalId, isUnreadCountSupport: isUnreadCountSupport(channel), messagePreviewId });
}
const preUpdateChannelCache = (rawPayload, options = { isMessagePreviewUpdated: true }) => {
    ingestInCache({
        channels: rawPayload.channels.map(channel => convertFromRaw(channel, { isMessagePreviewUpdated: options.isMessagePreviewUpdated })),
    });
};
const updateChannelUnread = ({ currentUserId, channels, channelUsers, }) => {
    for (let i = 0; i < channels.length; i += 1) {
        const cacheKey = ['channelUnread', 'get', channels[i].channelId];
        const channelUser = channelUsers.find(channelUser => channelUser.channelId === channels[i].channelId && channelUser.userId === currentUserId);
        let unreadCount = 0;
        let readToSegment = null;
        let lastMentionedSegment = null;
        let isMentioned = false;
        if (channelUser) {
            readToSegment = channelUser.readToSegment;
            lastMentionedSegment = channelUser.lastMentionedSegment;
            unreadCount = Math.max(channels[i].messageCount - readToSegment, 0);
            isMentioned = lastMentionedSegment > readToSegment;
        }
        const cacheChannelUnread = {
            channelId: channels[i].channelId,
            lastSegment: channels[i].messageCount,
            readToSegment,
            lastMentionedSegment,
            unreadCount,
            isMentioned,
            isDeleted: channels[i].isDeleted || false,
        };
        pushToCache(cacheKey, cacheChannelUnread);
    }
};
const prepareChannelPayload = async (rawPayload, options = { isMessagePreviewUpdated: true }) => {
    const client = getActiveClient();
    const networkPreviewSetting = await client.getMessagePreviewSetting(false);
    if (options.isMessagePreviewUpdated &&
        networkPreviewSetting !== "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */ &&
        rawPayload.messagePreviews &&
        rawPayload.messagePreviews.length > 0) {
        updateChannelMessagePreviewCache(rawPayload);
    }
    if (client.useLegacyUnreadCount) {
        updateChannelUnread({
            channels: rawPayload.channels,
            channelUsers: rawPayload.channelUsers,
            currentUserId: client.userId,
        });
    }
    else {
        const markerIds = rawPayload.channels
            // filter channel by type. Only conversation, community and broadcast type are included.
            .filter(isUnreadCountSupport)
            .map(({ channelInternalId }) => channelInternalId);
        if (markerIds.length > 0) {
            // since the get markers method requires a channel cache to function with the reducer.
            preUpdateChannelCache(rawPayload, {
                isMessagePreviewUpdated: options.isMessagePreviewUpdated,
            });
            try {
                await getChannelMarkers(markerIds);
            }
            catch (e) {
                // empty block (from the spec, allow marker fetch to fail without having to do anything)
            }
        }
    }
    // convert raw channel to internal channel
    const channels = rawPayload.channels.map(payload => convertFromRaw(payload, { isMessagePreviewUpdated: options.isMessagePreviewUpdated }));
    // convert raw channel user to membership (add user object)
    const channelUsers = rawPayload.channelUsers.map(channelUser => {
        return convertRawMembershipToMembership(channelUser);
    });
    const users = rawPayload.users.map(convertRawUserToInternalUser);
    const restRawPayload = __rest(rawPayload, ["messageFeedsInfo", "messagePreviews"]);
    return Object.assign(Object.assign({}, restRawPayload), { users,
        channels,
        channelUsers });
};

/**
 * ```js
 * import { getSubChannelMarkers } from '@amityco/ts-sdk'
 * const subChannelMarkers = await getSubChannelMarkers(['sch1', 'sch2'])
 * ```
 *
 * Fetches a paginable list of {@link Amity.SubChannelMarker} objects
 *
 * @param messageFeedIds the feed IDs of the {@link Amity.RawSubChannel} marker to fetch
 * @param page
 * @returns A page of {@link Amity.SubChannelMarker} objects
 *
 * @category Channel API
 * @async
 * @private
 */
const getUserMessageFeedMakers = async (channelIds) => {
    const client = getActiveClient();
    client.log('channel/getUserMessageFeedMakers', channelIds);
    const { data } = await client.http.get(`/api/v1/markers/user-message-feed`, {
        params: {
            channelIds,
        },
    });
    fireEvent('local.userMessageFeedMarker.fetched', { userMessageFeedMarker: data });
    return data;
};

const prepareUnreadCountInfo = async (rawPayload) => {
    const client = getActiveClient();
    // if consistent mode is enabled, persist the unread count info to the cache
    // Marker service API uses channelInternalId as channelId
    const queryPayload = await getUserMessageFeedMakers(rawPayload.channels.map(({ channelInternalId }) => channelInternalId));
    const { feedMarkers, userFeedMarkers } = queryPayload;
    persistUnreadCountInfo({
        feedMarkers,
        userFeedMarkers,
    });
    client.log('channel/prepareUnreadCountInfo', rawPayload.channels);
};

const getCachedMarker$1 = (entityId) => {
    var _a;
    const key = {
        entityId,
        userId: getActiveUser()._id,
    };
    return (_a = pullFromCache([
        'channelMarker',
        'get',
        getResolver('channelMarker')(key),
    ])) === null || _a === void 0 ? void 0 : _a.data;
};
const getUnreadInfoCached$1 = (channelId) => {
    var _a;
    return (_a = pullFromCache(['channelUnreadInfo', 'get', channelId])) === null || _a === void 0 ? void 0 : _a.data;
};
/**
 * The function use to get value of hasMentioned or isMentioned field.
 * function will get the value from marker params first, if there is no hasMentioned field, will look in to the cache.
 *
 * If consistent mode is enabled, the function will return the value from the channelUnreadCountInfo cache.
 * If not, the function will return the value from the channelMarker cache.
 * If not found in the both cache, use `false` as defaul value.
 */
const getChannelIsMentioned = (channel, marker) => {
    var _a, _b, _c, _d;
    const client = getActiveClient();
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        return (_b = (_a = getUnreadInfoCached$1(channel.channelPublicId)) === null || _a === void 0 ? void 0 : _a.isMentioned) !== null && _b !== void 0 ? _b : false;
    }
    return (marker === null || marker === void 0 ? void 0 : marker.hasMentioned) !== undefined
        ? marker === null || marker === void 0 ? void 0 : marker.hasMentioned
        : (_d = (_c = getCachedMarker$1(channel.channelPublicId)) === null || _c === void 0 ? void 0 : _c.hasMentioned) !== null && _d !== void 0 ? _d : false;
};

const getCachedMarker = (entityId) => {
    var _a;
    const key = {
        entityId,
        userId: getActiveUser()._id,
    };
    return (_a = pullFromCache([
        'channelMarker',
        'get',
        getResolver('channelMarker')(key),
    ])) === null || _a === void 0 ? void 0 : _a.data;
};
const getUnreadInfoCached = (channelId) => {
    var _a;
    return (_a = pullFromCache(['channelUnreadInfo', 'get', channelId])) === null || _a === void 0 ? void 0 : _a.data;
};
/**
 * The function use to get value of unreadCount field.
 * function will get the value from marker params first, if there is no hasMentioned field, will look in to the cache.
 *
 * If consistent mode is enabled, the function will return the value from the channelUnreadCountInfo cache.
 * If not, the function will return the value from the channelMarker cache.
 * If not found in the both cache, use `0` as defaul value.
 */
const getSubChannelsUnreadCount = (channel, marker) => {
    var _a, _b, _c, _d, _e;
    const client = getActiveClient();
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        // Marker service API uses channelInternalId as channelId
        return (_b = (_a = getUnreadInfoCached(channel.channelInternalId)) === null || _a === void 0 ? void 0 : _a.unreadCount) !== null && _b !== void 0 ? _b : 0;
    }
    if (marker === null || marker === void 0 ? void 0 : marker.isDeleted) {
        // NOTE: This is a temporary solution to handle the channel marker when the user is forced to
        // leave the channel because currently backend can't handle this, so every time a user is banned
        // from a channel or the channel is deleted the channel's unread count will reset to zero
        return 0;
    }
    return (_e = (_c = marker === null || marker === void 0 ? void 0 : marker.unreadCount) !== null && _c !== void 0 ? _c : (_d = getCachedMarker(channel.channelInternalId)) === null || _d === void 0 ? void 0 : _d.unreadCount) !== null && _e !== void 0 ? _e : 0;
};

const getLegacyChannelUnread = (channelId) => {
    var _a;
    return (_a = pullFromCache(['channelUnread', 'get', channelId])) === null || _a === void 0 ? void 0 : _a.data;
};

const constructChannelDynamicValue = (channel) => {
    const client = getActiveClient();
    const rest = __rest(channel, ["messageCount"]);
    return shallowClone(rest, {
        get unreadCount() {
            var _a, _b;
            return (_b = (_a = getLegacyChannelUnread(rest.channelId)) === null || _a === void 0 ? void 0 : _a.unreadCount) !== null && _b !== void 0 ? _b : 0;
        },
        get subChannelsUnreadCount() {
            return getSubChannelsUnreadCount(rest);
        },
        get isMentioned() {
            var _a, _b;
            if (client.useLegacyUnreadCount)
                return (_b = (_a = getLegacyChannelUnread(rest.channelId)) === null || _a === void 0 ? void 0 : _a.isMentioned) !== null && _b !== void 0 ? _b : false;
            return getChannelIsMentioned(rest);
        },
    });
};

const constructChannelObject = (channel) => {
    /**
     * convert internal cache data to be public channel data
     * 1. [getChannelMessagePreviewWithUser] add messagePreview >> Amity.InternalChannel -> Amity.InternalChannel
     * 2. [constructChannelDynamicValue] construct getter value >> Amity.StaticInternalChannel -> Amity.Channel
     * 3. [LinkedObject.channel] add markAsRead >> Amity.InternalChannel -> Amity.Channel
     */
    return LinkedObject.channel(constructChannelDynamicValue(getChannelMessagePreviewWithUser(channel)));
};

/**
 * ```js
 * import { getChannelByIds } from '@amityco/ts-sdk'
 * const channels = await getChannelByIds(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Channel} objects
 *
 * @param channelIds the IDs of the {@link Amity.Channel} to fetch
 * @returns the associated collection of {@link Amity.Channel} objects
 *
 * @category Channel API
 * @async
 */
const getChannelByIds$1 = async (channelIds) => {
    const client = getActiveClient();
    client.log('channel/getChannelByIds', channelIds);
    const encodedChannelIds = channelIds.map(channelId => encodeURIComponent(channelId));
    let payload;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/channels/list`, {
            params: { channelIds: encodedChannelIds },
        });
        payload = response.data;
    }
    catch (error) {
        channelIds.forEach(channelId => {
            if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
                // NOTE: use channelPublicId as tombstone cache key since we cannot get the channelPrivateId that come along with channel data from server
                pushToTombstone('channel', channelId);
            }
        });
        throw error;
    }
    const data = await prepareChannelPayload(payload);
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        await prepareUnreadCountInfo(payload);
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('local.channel.fetched', data.channels);
    return {
        data: data.channels.map(channel => constructChannelObject(channel)),
        cachedAt,
    };
};
/**
 * ```js
 * import { getChannelByIds } from '@amityco/ts-sdk'
 * const channels = getChannelByIds.locally(['foo', 'bar']) ?? []
 * ```
 *
 * Fetches a collection of {@link Amity.Channel} objects from cache
 *
 * @param channelIds the IDs of the {@link Amity.Channel} to fetch
 * @returns the associated collection of {@link Amity.Channel} objects
 *
 * @category Channel API
 */
getChannelByIds$1.locally = (channelIds) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('channel/getChannelByIds.locally', channelIds);
    if (!client.cache)
        return;
    const cached = (_a = queryCache(['channel', 'get'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
        return channelIds.includes(data.channelPublicId);
    });
    if (!cached || (cached === null || cached === void 0 ? void 0 : cached.length) < channelIds.length)
        return;
    const channels = cached.map(({ data }) => data);
    const oldest = (_b = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _b === void 0 ? void 0 : _b[0];
    return {
        data: channels.map(channel => constructChannelObject(channel)),
        cachedAt: oldest.cachedAt,
    };
};

class SessionWatcher {
    constructor() {
        this._sessionState = "notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */;
        this._listener = new Map();
    }
    onSessionStateChange(callback) {
        this._listener.set(callback, callback);
        return () => {
            this._listener.delete(callback);
        };
    }
    setSessionState(state) {
        if (this._sessionState === state)
            return;
        this._sessionState = state;
        this._listener.forEach(cb => cb(state));
    }
    destroy() {
        this._listener.clear();
    }
}
let instance$2;
var SessionWatcher$1 = {
    getInstance: () => {
        if (!instance$2) {
            instance$2 = new SessionWatcher();
        }
        return instance$2;
    },
};

/**
 * ```js
 * import { onSessionStateChange } from '@amityco/ts-sdk'
 * const dispose = onSessionStateChange((state: Amity.SessionStates) => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.Client} has a session state change
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Client Events
 */
const onSessionStateChange = (callback) => SessionWatcher$1.getInstance().onSessionStateChange(callback);

const setIntervalTask = (handler, timeout) => {
    const timer = setInterval(handler, timeout);
    return () => clearInterval(timer);
};

/**
 * ```js
 * import { SubChannel } from '@amityco/ts-sdk'
 * const success = await SubChannel('foo')
 * ```
 *
 * Mark all messages as read and start reading message inside channel
 *
 * @param messageFeedIds - Sub channel ID list to start reading.
 * @return A success boolean if reading of the sub channel had begun.
 *
 * @category Channel API
 * @async
 * @private
 */
const readingAPI = async (messageFeedIds) => {
    const client = getActiveClient();
    client.log('subChannel/readingAPI', messageFeedIds);
    const { data: payload } = await client.http.post(`/api/v1/markers/message-feeds/reading`, { messageFeedIds });
    const { userEntityMarkers: userEntityMarkersPayload, userFeedMarkers: userFeedMarkersPayload, feedMarkers, userMarkers, } = payload;
    const userEntityMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
    const userFeedMarkers = convertSubChannelMarkerResponse(userFeedMarkersPayload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ userEntityMarkers, userFeedMarkers, feedMarkers, userMarkers }, { cachedAt });
    fireEvent('local.feedMarker.fetched', { feedMarkers });
    fireEvent('local.channelMarker.fetched', { userEntityMarkers });
    fireEvent('local.subChannelMarker.fetched', { userFeedMarkers });
    fireEvent('local.userMarker.fetched', { userMarkers });
    return true;
};

const START_READING_INTERVAL_TIME = 30000;
let isSyncRunning$1 = false;
/**
 * map contains subChannelId and isReading flag to determine which subChannel is on reading state
 */
const isReadingMap = {};
const getReadingSubChannels = () => {
    return Object.entries(isReadingMap)
        .filter(([, value]) => value)
        .map(([key]) => key);
};
/**
 * call start reading API with reading list
 */
const startReadingFromReadingList = async () => {
    const isReadingSubChannelIds = getReadingSubChannels();
    if (isReadingSubChannelIds.length === 0) {
        // no subChannel that require to call start reading API
        return false;
    }
    return readingAPI(isReadingSubChannelIds);
};
const startIntervalTask = () => {
    isSyncRunning$1 = true;
};
const stopIntervalTask = () => {
    isSyncRunning$1 = false;
};
/**
 * global task for mark read engines runs when the client is authenticated.
 *
 * NOTE: This task will be refactored again in the future. When the session component improved
 * Relate Ticket: https://ekoapp.atlassian.net/browse/ASC-13542
 */
const markReadEngineOnLoginHandler = () => {
    startIntervalTask();
    onSessionStateChange(state => {
        if (state === "notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */) {
            stopIntervalTask();
        }
    });
    return () => {
        stopIntervalTask();
    };
};
setIntervalTask(async () => {
    if (!isSyncRunning$1)
        return;
    await startReadingFromReadingList();
}, START_READING_INTERVAL_TIME);

/**
 * ```js
 * import { getSubChannels } from '@amityco/ts-sdk'
 * const subChannels = await getSubChannels(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.SubChannel} objects
 *
 * @param subChannelIds the IDs of the {@link Amity.SubChannel} to fetch
 * @returns the associated collection of {@link Amity.SubChannel} objects
 *
 * @category Channel API
 * @async
 */
const getSubChannels$1 = async (subChannelIds) => {
    const client = getActiveClient();
    client.log('channel/getSubChannels', subChannelIds);
    const response = await client.http.get('/api/v5/message-feeds/list', {
        params: { messageFeedIds: subChannelIds.map(encodeURIComponent) },
    });
    const data = await prepareSubChannelPayload(response.data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('local.message-feed.fetched', data);
    return {
        data: data.messageFeeds,
        cachedAt,
    };
};
/**
 * ```js
 * import { getSubChannels } from '@amityco/ts-sdk'
 * const subChannels = getSubChannels.locally(['foo', 'bar']) ?? []
 * ```
 *
 * Fetches a collection of {@link Amity.SubChannel} objects from cache
 *
 * @param subChannelIds the IDs of the {@link Amity.SubChannel} to fetch
 * @returns the associated collection of {@link Amity.SubChannel} objects
 *
 * @category Channel API
 */
getSubChannels$1.locally = (subChannelIds) => {
    var _a;
    const client = getActiveClient();
    client.log('channel/getSubChannels.locally', subChannelIds);
    if (!client.cache)
        return;
    const cached = subChannelIds
        .map(channelId => pullFromCache(['subChannel', 'get', channelId]))
        .filter(Boolean);
    if ((cached === null || cached === void 0 ? void 0 : cached.length) < subChannelIds.length)
        return;
    const subChannels = cached.map(({ data }) => data);
    const oldest = (_a = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _a === void 0 ? void 0 : _a[0];
    return {
        data: subChannels,
        cachedAt: oldest.cachedAt,
    };
};

const convertMessagePreviewSetting = (chatSetting) => {
    if (!chatSetting.messagePreview.enabled)
        return "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */;
    if (!chatSetting.messagePreview.isIncludeDeleted)
        return "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */;
    return "message-preview-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_INCLUDE_DELETED */;
};
/**
 * ```js
 * import { getMessagePreviewSetting } from '@amityco/ts-sdk'
 * const messagePreviewSetting = await getMessagePreviewSetting();
 * ```
 *
 * A util to getMessagePreviewSetting from cache or fetch from server
 * @returns A a {@link Amity.MessagePreviewSetting} enum
 *
 * @category private
 * @async
 */
const getMessagePreviewSetting = async (refresh = true) => {
    var _a;
    const messagePreviewSetting = (_a = pullFromCache([
        'MessagePreviewSetting',
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (!refresh && messagePreviewSetting)
        return messagePreviewSetting;
    const newChatSettings = await getChatSettings();
    const newMessagePreviewSetting = convertMessagePreviewSetting(newChatSettings);
    return newMessagePreviewSetting;
};
/**
 * get messagePreviewSetting from cache and compare with new messagePreviewSetting
 * if new messagePreviewSetting is different from cache, check setting and update data in cache
 * @returns void
 *
 * @category private
 * @async
 */
const initializeMessagePreviewSetting = async () => {
    var _a;
    const newMessagePreviewSetting = await getMessagePreviewSetting();
    const messagePreviewSetting = (_a = pullFromCache([
        'MessagePreviewSetting',
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (newMessagePreviewSetting === messagePreviewSetting)
        return;
    pushToCache(['MessagePreviewSetting'], newMessagePreviewSetting);
    const channelWithIsDeletedTrue = [];
    const subChannelWithIsDeletedTrue = [];
    if (newMessagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */) {
        /* remove alll messagePreview cache */
        const messagePreviewCache = queryCache(['MessagePreview']);
        if (messagePreviewCache && (messagePreviewCache === null || messagePreviewCache === void 0 ? void 0 : messagePreviewCache.length) > 0) {
            messagePreviewCache.forEach(({ key, data }) => {
                dropFromCache(key);
                if (key.includes('MessagePreviewChannel')) {
                    channelWithIsDeletedTrue.push(data.channelId);
                }
                if (key.includes('MessagePreviewSubChannel')) {
                    subChannelWithIsDeletedTrue.push(data.subChannelId);
                }
            });
        }
    }
    else if (newMessagePreviewSetting === "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */) {
        /* remove messagePreview cache which isDelete = true */
        const messagePreviewCache = queryCache(['MessagePreview']);
        if (messagePreviewCache && (messagePreviewCache === null || messagePreviewCache === void 0 ? void 0 : messagePreviewCache.length) > 0) {
            messagePreviewCache.forEach(({ key, data }) => {
                if (data === null || data === void 0 ? void 0 : data.isDeleted) {
                    dropFromCache(key);
                    if (key.includes('MessagePreviewChannel')) {
                        channelWithIsDeletedTrue.push(data.channelId);
                    }
                    if (key.includes('MessagePreviewSubChannel')) {
                        subChannelWithIsDeletedTrue.push(data.subChannelId);
                    }
                }
            });
        }
        /**
         * update messagePreviewId in case of
         * 1. message preview is disabled and there is messagePreviewId in cache
         * 2. channel and subChannel which isDelete = true
         */
        if (channelWithIsDeletedTrue.length !== 0)
            await getChannelByIds$1(channelWithIsDeletedTrue);
        if (subChannelWithIsDeletedTrue.length !== 0)
            await getSubChannels$1(subChannelWithIsDeletedTrue);
    }
};

/**
 * ```js
 * import { getSocialSettings } from '@amityco/ts-sdk'
 * const socialSettings = await getSocialSettings()
 * ```
 *
 * Fetches a {@link Amity.SocialSettings} object
 *
 * @returns A Promise of {@link Amity.SocialSettings} object
 *
 * @category Client API
 * @async
 */
const getSocialSettings = async () => {
    const client = getActiveClient();
    const { data } = await client.http.get(`/api/v3/network-settings/social`);
    return data.socialNetworkSetting;
};

const checkUserPermission = (userId, permission) => {
    var _a;
    const user = (_a = pullFromCache(['user', 'get', userId])) === null || _a === void 0 ? void 0 : _a.data;
    if (!user)
        return false;
    return user.permissions.some(x => x === permission);
};

const checkCommunityPermission = (userId, permission, communityId) => {
    var _a;
    if (!userId)
        return false;
    const member = (_a = pullFromCache([
        'communityUsers',
        'get',
        `${communityId}#${userId}`,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (!member)
        return false;
    if (member.permissions.some(x => x === permission))
        return true;
    return checkUserPermission(userId, permission);
};

const checkChannelPermission = (userId, permission, channelId) => {
    var _a;
    if (!userId)
        return false;
    const member = (_a = pullFromCache([
        'channelUsers',
        'get',
        `${channelId}#${userId}`,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (!member)
        return false;
    if (member.permissions.some(x => x === permission))
        return true;
    return checkUserPermission(userId, permission);
};

const hasPermission$1 = (permission) => {
    const { userId } = getActiveClient();
    return {
        currentUser: () => checkUserPermission(userId, permission),
        community: (communityId) => checkCommunityPermission(userId, permission, communityId),
        channel: (channelId) => checkChannelPermission(userId, permission, channelId),
    };
};

/**
 * Validate a list of urls
 * @param urls  array of strings to validate (max 10 items)
 *
 * @category Client API
 */
const validateUrls = async (urls) => {
    const client = getActiveClient();
    client.log('channel/markerSync');
    if (urls.length === 0)
        return false;
    const { data: payload } = await client.http.post('/api/v3/allowlists/verify', {
        data: urls,
    });
    return payload.success;
};

/**
 * Validate a list of texts
 * @param texts array of strings to validate (max 10 items)
 *
 * @category Client API
 */
const validateTexts = async (texts) => {
    const client = getActiveClient();
    client.log('channel/markerSync');
    if (texts.length === 0)
        return false;
    const { data: payload } = await client.http.post('/api/v3/blocklists/verify', {
        data: texts,
    });
    return payload.success;
};

/**
 * ```js
 * import { getFeedSettings } from '@amityco/ts-sdk'
 * const feedSettings = await getFeedSettings()
 * const postFeedSetting = feedSettings.post
 * ```
 *
 * Fetches a {@link Amity.FeedSettings} object
 *
 * @returns A Promise of {@link Amity.FeedSettings} object
 *
 * @category Client API
 * @async
 */
const getFeedSettings = async () => {
    const client = getActiveClient();
    const { data } = await client.http.get(`/api/v3/network-settings/feed-setting`);
    return Object.fromEntries(data.feedSettings.map(({ feedType, contentSettings }) => {
        return [feedType, contentSettings];
    }));
};

/*
 * Session States cannot be set arbitrarily.
 * These are the possible new states based on the current state
 * Check tech spec for details:
 * https://ekoapp.atlassian.net/wiki/spaces/UP/pages/2082537485/ASC+Core+-+Session+Management+3.0#Session-State
 */
const sessionStateTransitions = {
    // notLoggedIn -> establishing
    ["notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */]: ["establishing" /* Amity.SessionStates.ESTABLISHING */],
    // terminated -> establishing
    ["terminated" /* Amity.SessionStates.TERMINATED */]: ["establishing" /* Amity.SessionStates.ESTABLISHING */],
    // establishing -> notLoggedIn, established
    ["establishing" /* Amity.SessionStates.ESTABLISHING */]: [
        "notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */,
        "established" /* Amity.SessionStates.ESTABLISHED */,
    ],
    /*
     * established -> notLoggedIn, terminated, tokenExpired, establishing (for
     * cases when logging in the same user)
     */
    ["established" /* Amity.SessionStates.ESTABLISHED */]: [
        "notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */,
        "terminated" /* Amity.SessionStates.TERMINATED */,
        "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */,
        "establishing" /* Amity.SessionStates.ESTABLISHING */,
    ],
    // tokenExpired -> establishing
    ["tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */]: ["establishing" /* Amity.SessionStates.ESTABLISHING */],
};
const isValidStateChange = (prevState, nextState) => {
    return sessionStateTransitions[prevState].includes(nextState);
};
/**
 * Checks if a {@link Amity.Client} instance is connected to ASC servers
 *
 *
 * @param state the new session state
 * @returns a success boolean if connected
 *
 * @category private
 */
const setSessionState = (state) => {
    const client = getActiveClient();
    client.log('client/api/setSessionState', state);
    const { sessionState: prevState } = client;
    if (prevState === state)
        return false;
    // check if transition is valid
    if (!isValidStateChange(prevState, state)) {
        throw new ASCError(`Session state cannot change from ${prevState} to ${state}`, 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
    }
    client.sessionState = state;
    SessionWatcher$1.getInstance().setSessionState(state);
    return true;
};

/**
 * Retrieves a pair of {@link Amity.Tokens} necessary for connection
 *
 * @param params.userId The userId to use to issue a token
 * @param params.displayName The user's displayName
 * @param params.deviceId The user's device Id (can be manually set for native users)
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @return The accessToken for the given userId
 *
 * @category Client API
 * @hidden
 */
const getToken = async ({ params, options, }) => {
    const client = getActiveClient();
    client.log('client/api/getToken', params);
    const deviceInfo = getDeviceInfo();
    const { data } = await client.http.post('/api/v5/sessions', Object.assign(Object.assign({}, params), { deviceInfo }), {
        headers: {
            'X-API-Key': client.apiKey,
            'set-access-token-cookie': (options === null || options === void 0 ? void 0 : options.setAccessTokenCookie) || false,
        },
    });
    return data;
};

/**
 * A util to set or refresh client token
 *
 * @param params.userId the user ID for the current session
 * @param params.displayName the user's displayName for the current session
 * @param params.deviceId Manual override of the user's device id (for device management)
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @returns token & user info
 *
 * @category private
 * @async
 */
const setClientToken = async (params) => {
    const client = getActiveClient();
    // begin establishing session
    setSessionState("establishing" /* Amity.SessionStates.ESTABLISHING */);
    const { accessToken, users, expiresAt, issuedAt } = await getToken(params);
    // manually setup the token for http transport
    client.http.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
    client.http.defaults.metadata = {
        tokenExpiry: expiresAt,
        isGlobalBanned: false,
        isUserDeleted: false,
    };
    client.upload.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
    client.upload.defaults.metadata = {
        tokenExpiry: expiresAt,
        isGlobalBanned: false,
        isUserDeleted: false,
    };
    // manually setup the token for ws transport
    if (client.ws)
        client.ws.io.opts.query = { token: accessToken };
    client.token = { accessToken, issuedAt, expiresAt };
    setSessionState("established" /* Amity.SessionStates.ESTABLISHED */);
    return { accessToken, users };
};

const addFlagIsDeletedSubChannelUnreadByChannelId = (channelId) => {
    const cacheKey = ['subChannelUnreadInfo', 'get'];
    const cachedSubChannelUnread = queryCache(cacheKey);
    if (cachedSubChannelUnread) {
        const cachedTargetSubChannelUnread = cachedSubChannelUnread === null || cachedSubChannelUnread === void 0 ? void 0 : cachedSubChannelUnread.filter(({ data }) => data.channelId === channelId);
        cachedTargetSubChannelUnread.forEach(({ key, data }) => {
            pushToCache(key, Object.assign(Object.assign({}, data), { isDeleted: true }));
        });
    }
};

const deleteChannelUnreadByChannelId = (channelId) => {
    var _a;
    const channelUnreadInfoCacheKey = ['channelUnreadInfo', 'get', channelId];
    const channelUnreadInfoCache = (_a = pullFromCache(channelUnreadInfoCacheKey)) === null || _a === void 0 ? void 0 : _a.data;
    if (channelUnreadInfoCache) {
        dropFromCache(channelUnreadInfoCacheKey);
    }
};

const callbacks$b = [];
let mainDisposer$a = null;
const dispose$b = (cb) => {
    const index = callbacks$b.indexOf(cb);
    if (index > -1) {
        callbacks$b.splice(index, 1);
    }
    if (callbacks$b.length === 0) {
        mainDisposer$a === null || mainDisposer$a === void 0 ? void 0 : mainDisposer$a();
    }
};
const onChannelDeleted = (callback) => {
    if (callbacks$b.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const data = await prepareChannelPayload(payload);
            const isConsistentMode = client.getMarkerSyncConsistentMode() && client.isUnreadCountEnabled;
            const isLegacyUnreadCount = client.useLegacyUnreadCount;
            data.channels.forEach(channel => {
                if (isConsistentMode) {
                    addFlagIsDeletedSubChannelUnreadByChannelId(channel.channelId);
                    deleteChannelUnreadByChannelId(channel.channelId);
                }
                else if (isLegacyUnreadCount) {
                    const cacheKey = ['channelUnread', 'get', channel.channelId];
                    const cache = pullFromCache(cacheKey);
                    if (cache) {
                        pushToCache(cacheKey, Object.assign(Object.assign({}, cache), { isDeleted: true }));
                    }
                }
            });
            ingestInCache(data);
            callbacks$b.forEach(cb => cb(data.channels[0]));
        };
        mainDisposer$a = createEventSubscriber(client, 'onChannelDeleted', 'channel.deleted', filter);
    }
    callbacks$b.push(callback);
    return () => dispose$b(callback);
};

const callbacks$a = [];
let mainDisposer$9 = null;
const dispose$a = (cb) => {
    const index = callbacks$a.indexOf(cb);
    if (index > -1) {
        callbacks$a.splice(index, 1);
    }
    if (callbacks$a.length === 0) {
        mainDisposer$9 === null || mainDisposer$9 === void 0 ? void 0 : mainDisposer$9();
    }
};
const onChannelMemberBanned = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const preparedPayload = await prepareChannelPayload(payload);
        const { channels, channelUsers } = preparedPayload;
        const isCurrentUserBanned = channelUsers.some(cu => cu.membership === 'banned' && cu.userId === client.userId);
        if (client.isUnreadCountEnabled &&
            client.getMarkerSyncConsistentMode() &&
            isCurrentUserBanned) {
            preparedPayload.channels.forEach(channel => {
                addFlagIsDeletedSubChannelUnreadByChannelId(channel.channelId);
                deleteChannelUnreadByChannelId(channel.channelId);
            });
        }
        ingestInCache(preparedPayload);
        callbacks$a.forEach(cb => cb(channels[0], channelUsers.find(cu => cu.membership === 'banned')));
    };
    mainDisposer$9 = createEventSubscriber(client, 'onChannelMemberBanned', 'channel.banned', filter);
    callbacks$a.push(callback);
    return () => dispose$a(callback);
};

function prepareUserPayload(response) {
    return {
        users: response.users.map(convertRawUserToInternalUser),
        files: response.files,
    };
}

const createUserEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (data) => {
        const payload = prepareUserPayload(data);
        if (client.cache) {
            ingestInCache(payload);
        }
        callback(payload.users[0]);
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onUserDeleted } from '@amityco/ts-sdk'
 * const dispose = onUserDeleted(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalUser} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserDeleted$2 = (callback) => createUserEventSubscriber('user.deleted', callback);

var analyticsEngineOnLoginHandler = () => {
    const analyticsEngine = AnalyticsEngine$1.getInstance();
    analyticsEngine.established();
    onSessionStateChange(state => {
        if (state === "established" /* Amity.SessionStates.ESTABLISHED */) {
            analyticsEngine.established();
        }
        else {
            analyticsEngine.handleTokenExpired();
        }
    });
    return () => {
        analyticsEngine.destroy();
    };
};

var readReceiptSyncEngineOnLoginHandler = () => {
    const readReceiptSyncEngine = ReadReceiptSyncEngine.getInstance();
    readReceiptSyncEngine.startSyncReadReceipt();
    onSessionStateChange(state => {
        if (state === "established" /* Amity.SessionStates.ESTABLISHED */) {
            readReceiptSyncEngine.onSessionEstablished();
        }
        else if (state === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            readReceiptSyncEngine.onTokenExpired();
        }
        else {
            readReceiptSyncEngine.onSessionDestroyed();
        }
    });
    return () => {
        readReceiptSyncEngine.onSessionDestroyed();
    };
};

var legacyReadReceiptSyncEngineOnLoginHandler = () => {
    const readReceiptSyncEngine = LegacyReadReceiptSyncEngine.getInstance();
    readReceiptSyncEngine.startSyncReadReceipt();
    onSessionStateChange(state => {
        if (state === "established" /* Amity.SessionStates.ESTABLISHED */) {
            readReceiptSyncEngine.onSessionEstablished();
        }
        else if (state === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            readReceiptSyncEngine.onTokenExpired();
        }
        else {
            readReceiptSyncEngine.onSessionDestroyed();
        }
    });
    return () => {
        readReceiptSyncEngine.onSessionDestroyed();
    };
};

const onOnline = (callback) => {
    if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('online', callback);
        return () => window.removeEventListener('online', callback);
    }
    if (typeof document !== 'undefined' && document.addEventListener) {
        document.addEventListener('online', callback);
        return () => document.removeEventListener('online', callback);
    }
    // Handle unsupported environment
    console.error('Unsupported environment');
    return () => console.error('Unsupported environment');
};

const onOffline = (callback) => {
    if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('offline', callback);
        return () => window.removeEventListener('offline', callback);
    }
    if (typeof document !== 'undefined' && document.addEventListener) {
        document.addEventListener('offline', callback);
        return () => document.removeEventListener('offline', callback);
    }
    // Handle unsupported environment
    console.error('Unsupported environment');
    return () => console.error('Unsupported environment');
};

/**
 * ```js
 * import { getChannelByIds } from '@amityco/ts-sdk'
 * const channels = await getChannelByIds(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Channel} objects
 *
 * @param channelIds the IDs of the {@link Amity.Channel} to fetch
 * @returns the associated collection of {@link Amity.Channel} objects
 *
 * @category Channel API
 * @async
 */
const getChannelByIds = async (channelIds) => {
    const client = getActiveClient();
    client.log('channel/getChannelByIds', channelIds);
    const encodedChannelIds = channelIds.map(channelId => encodeURIComponent(channelId));
    let payload;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/channels/list`, {
            params: { channelIds: encodedChannelIds },
        });
        payload = response.data;
    }
    catch (error) {
        channelIds.forEach(channelId => {
            if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
                // NOTE: use channelPublicId as tombstone cache key since we cannot get the channelPrivateId that come along with channel data from server
                pushToTombstone('channel', channelId);
            }
        });
        throw error;
    }
    const data = await prepareChannelPayload(payload);
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        await prepareUnreadCountInfo(payload);
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('local.channel.fetched', data.channels);
    return {
        data: data.channels,
        cachedAt,
    };
};
/**
 * ```js
 * import { getChannelByIds } from '@amityco/ts-sdk'
 * const channels = getChannelByIds.locally(['foo', 'bar']) ?? []
 * ```
 *
 * Fetches a collection of {@link Amity.Channel} objects from cache
 *
 * @param channelIds the IDs of the {@link Amity.Channel} to fetch
 * @returns the associated collection of {@link Amity.Channel} objects
 *
 * @category Channel API
 */
getChannelByIds.locally = (channelIds) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('channel/getChannelByIds.locally', channelIds);
    if (!client.cache)
        return;
    const cached = (_a = queryCache(['channel', 'get'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
        return channelIds.includes(data.channelPublicId);
    });
    if (!cached || (cached === null || cached === void 0 ? void 0 : cached.length) < channelIds.length)
        return;
    const channels = cached.map(({ data }) => data);
    const oldest = (_b = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _b === void 0 ? void 0 : _b[0];
    return {
        data: channels,
        cachedAt: oldest.cachedAt,
    };
};

const resolveChannels = async (channelIds) => {
    var _a, _b, _c;
    await getChannelByIds(channelIds);
    const channels = (_c = (_b = (_a = queryCache(['channel', 'get'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => data.channelPublicId && channelIds.includes(data.channelPublicId))) === null || _b === void 0 ? void 0 : _b.map(({ data }) => data)) !== null && _c !== void 0 ? _c : [];
    fireEvent('local.channel.resolved', channels);
};

const resolveUserMessageFeedMarkers = async (channelIds) => {
    const queryPayload = await getUserMessageFeedMakers(channelIds);
    const { feedMarkers, userFeedMarkers } = queryPayload;
    persistUnreadCountInfo({
        feedMarkers,
        userFeedMarkers,
    });
    fireEvent('local.userMessageFeedMarkers.resolved', { feedMarkers, userFeedMarkers });
};

class ObjectResolverEngine {
    constructor() {
        this.TIMER_INTERVAL_MS = SECOND$1;
        this.BUFFER_ID_LIMIT = 100;
        this.buffer = {
            ["channel" /* Amity.ReferenceType.CHANNEL */]: [],
            ["userMessageFeedMarker" /* Amity.ReferenceType.USER_MESSAGE_FEED_MARKER */]: [],
        };
        this.isResolvingTask = false;
        this.connectionListener = [];
        this.isConnected = true;
        this.addConnectionListener();
    }
    startResolver() {
        if (!this.timer) {
            this.timer = setInterval(() => {
                if (this.isConnected)
                    this.resolveObjects();
            }, this.TIMER_INTERVAL_MS);
        }
    }
    stopResolver() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = undefined;
        }
    }
    resolve(id, referenceType) {
        const objectIdList = this.getBuffer(referenceType);
        if (objectIdList.includes(id))
            return;
        if (objectIdList.length >= this.BUFFER_ID_LIMIT) {
            objectIdList.shift(); // Remove first element of the array
        }
        objectIdList.push(id);
    }
    addConnectionListener() {
        if (this.connectionListener.length > 0)
            return;
        this.connectionListener.push(onOnline(() => {
            this.isConnected = true;
        }));
        this.connectionListener.push(onOffline(() => {
            this.isConnected = false;
        }));
    }
    removeConnectionListener() {
        if (this.connectionListener.length > 0)
            this.connectionListener.forEach(listener => listener());
    }
    resolveObjects() {
        if (this.isResolvingTask) {
            return;
        }
        this.isResolvingTask = true;
        // Get first 100 ids for all reference type supported.
        const channelIds = this.getBuffer("channel" /* Amity.ReferenceType.CHANNEL */);
        const userMessageFeedMarkerIds = this.getBuffer("userMessageFeedMarker" /* Amity.ReferenceType.USER_MESSAGE_FEED_MARKER */);
        // Clear buffer
        this.clearBuffer();
        // Send Requests.
        // Incase of failure: Ignore
        // Incase of success: Persist in Domain DB & Notify Live collection
        if (channelIds.length > 0)
            resolveChannels(channelIds);
        if (userMessageFeedMarkerIds.length > 0)
            resolveUserMessageFeedMarkers(userMessageFeedMarkerIds);
        // After sending request
        this.isResolvingTask = false;
    }
    clearBuffer() {
        this.buffer = {
            ["channel" /* Amity.ReferenceType.CHANNEL */]: [],
            ["userMessageFeedMarker" /* Amity.ReferenceType.USER_MESSAGE_FEED_MARKER */]: [],
        };
    }
    getBuffer(referenceType) {
        return this.buffer[referenceType];
    }
    // Session Management : SessionComponent
    onSessionEstablished() {
        this.startResolver();
        this.addConnectionListener();
    }
    onSessionDestroyed() {
        // Stop timer
        this.stopResolver();
        // Clear buffer
        this.clearBuffer();
        // Reset state
        this.isResolvingTask = false;
        // remove connection listener
        this.removeConnectionListener();
    }
    onTokenExpired() {
        this.stopResolver();
    }
}
let instance$1 = null;
var ObjectResolverEngine$1 = {
    getInstance: () => {
        if (!instance$1)
            instance$1 = new ObjectResolverEngine();
        return instance$1;
    },
};

var objectResolverEngineOnLoginHandler = () => {
    const objectResolverEngine = ObjectResolverEngine$1.getInstance();
    objectResolverEngine.startResolver();
    onSessionStateChange(state => {
        if (state === "established" /* Amity.SessionStates.ESTABLISHED */) {
            objectResolverEngine.onSessionEstablished();
        }
        else if (state === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */) {
            objectResolverEngine.onTokenExpired();
        }
        else {
            objectResolverEngine.onSessionDestroyed();
        }
    });
    return () => {
        objectResolverEngine.onSessionDestroyed();
    };
};

/* begin_public_function
  id: client.logout
*/
/**
 * ```js
 * import { Client } from '@amityco/ts-sdk';
 * const success = await Client.logout()
 * ```
 *
 * Disconnects an {@link Amity.Client} instance from ASC servers
 *
 * @returns a success boolean if disconnected
 *
 * @category Client API
 * @async
 */
const logout = async () => {
    var _a, _b;
    const client = getActiveClient();
    client.log('client/api/disconnectClient');
    if (client.mqtt && client.mqtt.connected) {
        client.mqtt.disconnect();
    }
    if (client.ws && client.ws.connected) {
        client.ws.disconnect();
    }
    /*
     * for cases when session state is terminated (example on ban) or token expired,
     * the terminating block will set session state to terminated or for the or
     * in the case of expired token the same happens
     *
     * establishing state also ignored in cases where accessTokenExpiryWatcher
     * calls renewal. There is a possibility that renewal will be called before
     * disconnectClient finishes execution
     *
     * IMPORTANT: call this before `emitter.all.clear()`, otherwise the session
     * event will never be triggered
     */
    if (client.sessionState === "established" /* Amity.SessionStates.ESTABLISHED */)
        setSessionState("notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */);
    client.emitter.all.clear();
    // FIXME: it removes listener in ws.ts, it breaks global ban event
    (_a = client.ws) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
    (_b = client.mqtt) === null || _b === void 0 ? void 0 : _b.removeAllListeners();
    client.userId = undefined;
    client.token = undefined;
    client.http.defaults.headers.common.Authorization = '';
    client.http.defaults.metadata = {
        tokenExpiry: '',
        isGlobalBanned: false,
        isUserDeleted: false,
    };
    if (client.ws)
        client.ws.io.opts.query = { token: '' };
    if (typeof document !== 'undefined') {
        document.cookie = '_ascSession=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
    }
    /*
     * Cache should be usable if tokenExpired
     * https://ekoapp.atlassian.net/wiki/spaces/UP/pages/2082537485/ASC+Core+-+Session+Management+3.0#SDK-usability-based-on-Session-State
     */
    if (client.sessionState !== "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */ && client.cache) {
        client.cache = { data: {} };
    }
    return true;
};
/* end_public_function */

/**
 * Terminates {@link Amity.Client} instance
 *
 *
 *
 * @category private
 */
const terminateClient = (terminationReason) => {
    const client = getActiveClient();
    setSessionState("terminated" /* Amity.SessionStates.TERMINATED */);
    if (client.http.defaults.metadata) {
        if (terminationReason === "globalBan" /* Amity.TokenTerminationReason.GLOBAL_BAN */)
            client.http.defaults.metadata.isGlobalBanned = true;
        if (terminationReason === "userDeleted" /* Amity.TokenTerminationReason.USER_DELETED */)
            client.http.defaults.metadata.isUserDeleted = true;
    }
    client.sessionHandler = undefined;
    logout();
};

const EVENTS = [
    'disconnected',
    'error',
    'connect_error',
    'reconnect_error',
    'reconnect_failed',
];
/**
 * ```js
 * import { onConnectionError } from '@amityco/ts-sdk'
 * const dispose = onClientBanned(() => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.Client} have been banned from the platform
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Client Events
 */
const onConnectionError = (callback) => {
    const client = getActiveClient();
    const subscribers = EVENTS.map(event => createEventSubscriber(client, `client/onConnectionError(${event})`, event, response => {
        const error = (response === null || response === void 0 ? void 0 : response.code)
            ? new ASCError(response.message, response.code, "fatal" /* Amity.ErrorLevel.FATAL */)
            : new ASCConnectionError(event);
        callback(error);
    }));
    return () => {
        subscribers.forEach(fn => fn());
    };
};

/**
 * ```js
 * import { onClientDisconnected } from '@amityco/ts-sdk'
 * const dispose = onClientDisconnected(() => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.Client} have been disconnected
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Client Events
 */
const onClientDisconnected = (callback) => {
    return onConnectionError(({ code }) => {
        code === 800211 /* Amity.ClientError.DISCONNECTED */ && callback();
    });
};

/**
 * ```js
 * import { onClientBanned } from '@amityco/ts-sdk'
 * const dispose = onClientBanned(() => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.Client} have been banned from the platform
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Client Events
 */
const onClientBanned = (callback) => {
    const client = getActiveClient();
    return createEventSubscriber(client, `client/onConnectionError(user.didGlobalBan)`, 'user.didGlobalBan', callback);
};

/**
 *
 * Fired when any {@link Amity.Client} has a session state change
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Client Events
 */
const onNetworkActivities = (callback) => NetworkActivitiesWatcher$1.getInstance().onNetworkActivities(callback);

/**
 * ```js
 * import { onTokenExpired } from '@amityco/ts-sdk'
 * const dispose = onTokenExpired((state: Amity.SessionStates.TOKEN_EXPIRED) => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.Client} session state has expired
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category private
 */
const onTokenExpired = (callback) => {
    const client = getActiveClient();
    return createEventSubscriber(client, `client/onTokenExpired`, 'tokenExpired', callback);
};

/**
 *
 * Fired when any {@link Amity.Client} session state has terminated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category private
 */
const onTokenTerminated = (callback) => {
    const client = getActiveClient();
    return createEventSubscriber(client, `client/onTokenTerminated`, 'tokenTerminated', callback);
};

const removeChannelMarkerCache = (channel) => {
    const id = getResolver('channelMarker')({
        userId: getActiveUser()._id,
        entityId: channel.channelId,
    });
    dropFromCache(['channelMarker', 'get', id], true);
};

const callbacks$9 = [];
let mainDisposer$8 = null;
const dispose$9 = (cb) => {
    const index = callbacks$9.indexOf(cb);
    if (index > -1) {
        callbacks$9.splice(index, 1);
    }
    if (callbacks$9.length === 0) {
        mainDisposer$8 === null || mainDisposer$8 === void 0 ? void 0 : mainDisposer$8();
    }
};
const onChannelCreated = (callback) => {
    if (callbacks$9.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const data = await prepareChannelPayload(payload);
            ingestInCache(data);
            callbacks$9.forEach(cb => cb(data.channels[0]));
        };
        mainDisposer$8 = createEventSubscriber(client, 'onChannelCreated', 'channel.created', filter);
    }
    callbacks$9.push(callback);
    return () => dispose$9(callback);
};

const callbacks$8 = [];
const mainDisposers = [];
const dispose$8 = (cb) => {
    const index = callbacks$8.indexOf(cb);
    if (index > -1) {
        callbacks$8.splice(index, 1);
    }
    if (callbacks$8.length === 0) {
        mainDisposers.forEach(fn => fn());
    }
};
const onChannelUpdated = (callback) => {
    const client = getActiveClient();
    if (callbacks$8.length === 0) {
        const filter = async (payload) => {
            const data = await prepareChannelPayload(payload);
            ingestInCache(data);
            callbacks$8.forEach(cb => cb(data.channels[0]));
        };
        mainDisposers.push(createEventSubscriber(client, 'onChannelUpdated', 'channel.updated', filter));
        mainDisposers.push(createEventSubscriber(client, 'onChannelUpdated', 'local.channel.updated', payload => callbacks$8.forEach(cb => cb(payload.channels[0]))));
    }
    callbacks$8.push(callback);
    return () => dispose$8(callback);
};

const callbacks$7 = [];
let mainDisposer$7 = null;
const dispose$7 = (cb) => {
    const index = callbacks$7.indexOf(cb);
    if (index > -1) {
        callbacks$7.splice(index, 1);
    }
    if (callbacks$7.length === 0) {
        mainDisposer$7 === null || mainDisposer$7 === void 0 ? void 0 : mainDisposer$7();
    }
};
const onChannelJoined = (callback) => {
    if (callbacks$7.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const preparedPayload = await prepareChannelPayload(payload);
            const { channels, channelUsers } = preparedPayload;
            ingestInCache(preparedPayload);
            callbacks$7.forEach(cb => cb(channels[0], channelUsers[0]));
        };
        mainDisposer$7 = createEventSubscriber(client, 'onChannelJoined', 'channel.joined', filter);
    }
    callbacks$7.push(callback);
    return () => dispose$7(callback);
};

const callbacks$6 = [];
let mainDisposer$6 = null;
const dispose$6 = (cb) => {
    const index = callbacks$6.indexOf(cb);
    if (index > -1) {
        callbacks$6.splice(index, 1);
    }
    if (callbacks$6.length === 0) {
        mainDisposer$6 === null || mainDisposer$6 === void 0 ? void 0 : mainDisposer$6();
    }
};
const onChannelLeft = (callback) => {
    if (callbacks$6.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const { userId } = getActiveClient();
            const { channelUsers: leftUsers } = payload;
            const isLeftByMe = leftUsers.some(user => user.userId === userId);
            const preparedPayload = await prepareChannelPayload(payload, {
                isMessagePreviewUpdated: isLeftByMe,
            });
            const isConsistentMode = client.getMarkerSyncConsistentMode() && client.isUnreadCountEnabled;
            const isLegacyUnreadCount = client.useLegacyUnreadCount;
            if (isLeftByMe) {
                preparedPayload.channels.forEach(channel => {
                    if (isConsistentMode) {
                        addFlagIsDeletedSubChannelUnreadByChannelId(channel.channelId);
                        deleteChannelUnreadByChannelId(channel.channelId);
                    }
                    else if (isLegacyUnreadCount) {
                        dropFromCache(['channelUnread', 'get', channel.channelId]);
                    }
                });
            }
            const { channels, channelUsers } = preparedPayload;
            ingestInCache(preparedPayload);
            callbacks$6.forEach(cb => cb(channels[0], channelUsers[0]));
        };
        mainDisposer$6 = createEventSubscriber(client, 'onChannelLeft', 'channel.left', filter);
    }
    callbacks$6.push(callback);
    return () => dispose$6(callback);
};

const callbacks$5 = [];
let mainDisposer$5 = null;
const dispose$5 = (cb) => {
    const index = callbacks$5.indexOf(cb);
    if (index > -1) {
        callbacks$5.splice(index, 1);
    }
    if (callbacks$5.length === 0) {
        mainDisposer$5 === null || mainDisposer$5 === void 0 ? void 0 : mainDisposer$5();
    }
};
const onChannelMuted = (callback) => {
    if (callbacks$5.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const data = await prepareChannelPayload(payload);
            ingestInCache(data);
            callbacks$5.forEach(cb => cb(data.channels[0]));
        };
        mainDisposer$5 = createEventSubscriber(client, 'onChannelMuted', 'channel.setMuted', filter);
    }
    callbacks$5.push(callback);
    return () => dispose$5(callback);
};

const callbacks$4 = [];
let mainDisposer$4 = null;
const dispose$4 = (cb) => {
    const index = callbacks$4.indexOf(cb);
    if (index > -1) {
        callbacks$4.splice(index, 1);
    }
    if (callbacks$4.length === 0) {
        mainDisposer$4 === null || mainDisposer$4 === void 0 ? void 0 : mainDisposer$4();
    }
};
const onChannelMemberAdded = (callback) => {
    if (callbacks$4.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const preparedPayload = await prepareChannelPayload(payload);
            const { channels, channelUsers } = preparedPayload;
            ingestInCache(preparedPayload);
            callbacks$4.forEach(cb => cb(channels[0], channelUsers.find(cu => cu.membership === 'member')));
        };
        mainDisposer$4 = createEventSubscriber(client, 'onChannelMemberAdded', 'channel.membersAdded', filter);
    }
    callbacks$4.push(callback);
    return () => dispose$4(callback);
};

const callbacks$3 = [];
let mainDisposer$3 = null;
const dispose$3 = (cb) => {
    const index = callbacks$3.indexOf(cb);
    if (index > -1) {
        callbacks$3.splice(index, 1);
    }
    if (callbacks$3.length === 0) {
        mainDisposer$3 === null || mainDisposer$3 === void 0 ? void 0 : mainDisposer$3();
    }
};
const onChannelMemberRemoved = (callback) => {
    if (callbacks$3.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const preparedPayload = await prepareChannelPayload(payload);
            const { channels, channelUsers } = preparedPayload;
            ingestInCache(preparedPayload);
            callbacks$3.forEach(cb => cb(channels[0], channelUsers[0]));
        };
        mainDisposer$3 = createEventSubscriber(client, 'onChannelMemberRemoved', 'channel.membersRemoved', filter);
    }
    callbacks$3.push(callback);
    return () => dispose$3(callback);
};

const callbacks$2 = [];
let mainDisposer$2 = null;
const dispose$2 = (cb) => {
    const index = callbacks$2.indexOf(cb);
    if (index > -1) {
        callbacks$2.splice(index, 1);
    }
    if (callbacks$2.length === 0) {
        mainDisposer$2 === null || mainDisposer$2 === void 0 ? void 0 : mainDisposer$2();
    }
};
const onChannelMemberUnbanned = (callback) => {
    if (callbacks$2.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const preparedPayload = await prepareChannelPayload(payload);
            const { channels, channelUsers } = preparedPayload;
            ingestInCache(preparedPayload);
            callbacks$2.forEach(cb => cb(channels[0], channelUsers.find(cu => cu.membership === 'none')));
        };
        mainDisposer$2 = createEventSubscriber(client, 'onChannelMemberUnbanned', 'channel.unbanned', filter);
    }
    callbacks$2.push(callback);
    return () => dispose$2(callback);
};

const callbacks$1 = [];
let mainDisposer$1 = null;
const dispose$1 = (cb) => {
    const index = callbacks$1.indexOf(cb);
    if (index > -1) {
        callbacks$1.splice(index, 1);
    }
    if (callbacks$1.length === 0) {
        mainDisposer$1 === null || mainDisposer$1 === void 0 ? void 0 : mainDisposer$1();
    }
};
const onChannelMemberRoleAdded = (callback) => {
    if (callbacks$1.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const { channels, channelUsers } = payload;
            callbacks$1.forEach(cb => cb(channels[0], channelUsers.find(channelUser => channelUser.membership === 'member')));
        };
        mainDisposer$1 = createEventSubscriber(client, 'onChannelMemberRoleAdded', 'local.channel-moderator.role-added', filter);
    }
    callbacks$1.push(callback);
    return () => dispose$1(callback);
};

const callbacks = [];
let mainDisposer = null;
const dispose = (cb) => {
    const index = callbacks.indexOf(cb);
    if (index > -1) {
        callbacks.splice(index, 1);
    }
    if (callbacks.length === 0) {
        mainDisposer === null || mainDisposer === void 0 ? void 0 : mainDisposer();
    }
};
const onChannelMemberRoleRemoved = (callback) => {
    if (callbacks.length === 0) {
        const client = getActiveClient();
        const filter = async (payload) => {
            const { channels, channelUsers } = payload;
            callback(channels[0], channelUsers.find(channelUser => channelUser.membership === 'member'));
        };
        mainDisposer = createEventSubscriber(client, 'onChannelMemberRoleRemoved', 'local.channel-moderator.role-removed', filter);
    }
    callbacks.push(callback);
    return () => dispose(callback);
};

/**
 * ```js
 * import { onUserMarkerSync } from '@amityco/ts-sdk'
 * const dispose = onUserMarkerSync(UserMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.UserMarker} has been sync
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category UserMarker Events
 */
const onUserMarkerSync = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        const { userMarkers, userEntityMarkers: userEntityMarkersPayload, userFeedMarkers: userFeedMarkersPayload } = payload, rest = __rest(payload, ["userMarkers", "userEntityMarkers", "userFeedMarkers"]);
        const userEntityMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
        const userFeedMarker = convertSubChannelMarkerResponse(userFeedMarkersPayload);
        ingestInCache(Object.assign({ userMarkers, userEntityMarkers, userFeedMarker }, rest));
        callback(userMarkers[0]);
    };
    return createEventSubscriber(client, 'UserMarker/onUserMarkerSync', 'marker.user-sync', filter);
};

/**
 * ```js
 * import { onFeedMarkerUpdated } from '@amityco/ts-sdk'
 * const dispose = onFeedMarkerUpdated(feedMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.FeedMarker} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category FeedMarker Events
 */
const onFeedMarkerUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.feedMarkers[0]);
    };
    return createEventSubscriber(client, 'feedMarker/onFeedMarkerUpdated', 'marker.feed-updated', filter);
};

const updateSubChannelUnreadFromMessage = (message) => {
    var _a;
    const client = getActiveClient();
    const cacheKeyUnreadCount = ['subChannelUnreadInfo', 'get', message.messageFeedId];
    const cachedUnreadCount = (_a = pullFromCache(cacheKeyUnreadCount)) === null || _a === void 0 ? void 0 : _a.data;
    if (!cachedUnreadCount)
        return;
    const lastSegment = cachedUnreadCount.lastSegment < message.segment
        ? message.segment
        : cachedUnreadCount.lastSegment;
    const unreadCount = lastSegment - cachedUnreadCount.readToSegment;
    let { lastMentionSegment } = cachedUnreadCount;
    if (message.mentionedUsers && message.mentionedUsers.length > 0) {
        message.mentionedUsers.forEach(mention => {
            if (mention.type === 'channel' ||
                (mention.type === 'user' && client.userId && mention.userPublicIds.includes(client.userId))) {
                lastMentionSegment = message.segment;
            }
        });
    }
    const updatedCachedUnreadCount = Object.assign(Object.assign({}, cachedUnreadCount), { lastMentionSegment,
        lastSegment, isMentioned: !(cachedUnreadCount.readToSegment >= lastMentionSegment), unreadCount: Math.max(unreadCount, 0) });
    pushToCache(cacheKeyUnreadCount, updatedCachedUnreadCount);
};

/**
 * ```js
 * import { onMessageCreated } from '@amityco/ts-sdk'
 * const dispose = onMessageCreated(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} has been created
 *
 * @param callback The function to call when the event was fired
 * @param local Trigger when an event occurs from a local event or not
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageCreatedMqtt = (callback) => {
    const client = getActiveClient();
    const user = getActiveUser();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        // update unreadCountInfo in cache
        if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
            rawPayload.messages.forEach(message => {
                updateSubChannelUnreadFromMessage(message);
                reCalculateChannelUnreadInfo(message.channelId);
            });
        }
        if (client.useLegacyUnreadCount) {
            rawPayload.messages.forEach(message => {
                var _a, _b;
                const channelUnread = (_a = pullFromCache([
                    'channelUnread',
                    'get',
                    message.channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!channelUnread ||
                    channelUnread.lastSegment >= message.segment ||
                    typeof channelUnread.readToSegment !== 'number' ||
                    typeof channelUnread.lastMentionedSegment !== 'number')
                    return;
                const lastSegment = message.segment;
                const isMentionedInMessage = (_b = message.mentionedUsers) === null || _b === void 0 ? void 0 : _b.some(mention => {
                    return (mention.type === 'channel' ||
                        (mention.type === 'user' &&
                            client.userId &&
                            mention.userPublicIds.includes(client.userId)));
                });
                const lastMentionedSegment = isMentionedInMessage
                    ? message.segment
                    : channelUnread.lastMentionedSegment;
                const updatedChannelUnread = Object.assign(Object.assign({}, channelUnread), { lastSegment, unreadCount: Math.max(lastSegment - channelUnread.readToSegment, 0), lastMentionedSegment, isMentioned: !(channelUnread.readToSegment >= lastMentionedSegment) });
                pushToCache(['channelUnread', 'get', message.channelId], updatedChannelUnread);
                fireEvent('local.channelUnread.updated', updatedChannelUnread);
            });
        }
        // Update in cache
        ingestInCache(payload);
        payload.messages.forEach(message => {
            if (message.creatorPrivateId === user._id)
                markReadMessage(message);
            callback(message);
        });
    };
    const disposers = [
        createEventSubscriber(client, 'message/onMessageCreated', 'message.created', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};
const onMessageCreatedLocal = (callback) => {
    const client = getActiveClient();
    const disposers = [
        createEventSubscriber(client, 'message/onMessageCreated', 'local.message.created', async (payload) => {
            ingestInCache(payload);
            return payload.messages.forEach(message => {
                callback(message);
            });
        }),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const persistOptimisticUnreadInfo = (subChannelOptimisticInfo) => {
    const { channelId, subChannelId, createdAt, updatedAt } = subChannelOptimisticInfo;
    const subChannelUnreadInfo = {
        channelId,
        subChannelId,
        unreadCount: 0,
        readToSegment: 0,
        lastMentionSegment: 0,
        lastSegment: 0,
        isMentioned: false,
        isDeleted: false,
        createdAt,
        updatedAt,
    };
    pushToCache(['subChannelUnreadInfo', 'get', subChannelUnreadInfo.subChannelId], subChannelUnreadInfo);
};

/**
 * ```js
 * import { onChannelSubCreated } from '@amityco/ts-sdk'
 * const dispose = onSubChannelCreated(subChannel => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.SubChannel} have been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Channel Events
 */
const onSubChannelCreated = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareSubChannelPayload(rawPayload);
        // optimistically create subChannelUnreadInfo
        if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
            rawPayload.messageFeeds.forEach(subChannel => {
                persistOptimisticUnreadInfo({
                    channelId: subChannel.channelId,
                    subChannelId: subChannel.messageFeedId,
                    createdAt: subChannel.createdAt,
                    updatedAt: subChannel.updatedAt,
                });
            });
        }
        ingestInCache(payload);
        callback(payload.messageFeeds[0]);
    };
    return createEventSubscriber(client, 'onSubChannelCreated', 'message-feed.created', filter);
};

const addFlagIsDeletedSubChannelUnreadBySubChannelId = (subChannelId) => {
    var _a;
    const cacheKey = ['subChannelUnreadInfo', 'get', subChannelId];
    const cachedSubChannelUnread = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
    if (cachedSubChannelUnread) {
        pushToCache(cacheKey, Object.assign(Object.assign({}, cachedSubChannelUnread), { isDeleted: true }));
    }
};

/**
 * ```js
 * import { onSubChannelDeleted } from '@amityco/ts-sdk'
 * const dispose = onSubChannelDeleted(subChannel => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.SubChannel} have been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Channel Events
 */
const onSubChannelDeleted = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareSubChannelPayload(rawPayload);
        if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
            payload.messageFeeds.forEach(subChannel => {
                addFlagIsDeletedSubChannelUnreadBySubChannelId(subChannel.subChannelId);
                reCalculateChannelUnreadInfo(subChannel.channelId);
            });
        }
        ingestInCache(payload);
        callback(payload.messageFeeds[0]);
    };
    const disposers = [
        createEventSubscriber(client, 'onSubChannelDeleted', 'message-feed.deleted', filter),
        createEventSubscriber(client, 'local.message-feed.deleted', 'local.message-feed.deleted', payload => callback(payload.messageFeeds[0])),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

/**
 * ```js
 * import { markerSync } from '@amityco/ts-sdk'
 * const success = await markerSync()
 * ```
 *
 * Make all markers synced
 * * If response is empty means that the sync has ended.
 * * If response is not empty, the sync has not ended. You must call markerSync
 * again to continue syncing.
 *
 * @return {hasMore} A success boolean if the marker sync was ended.
 *
 * @category Marker API
 * @async
 * @private
 */
const markerSync = async (deviceLastSyncAt) => {
    const client = getActiveClient();
    client.log('channel/markerSync');
    const { data: payload } = await client.http.post(`/api/v1/markers/sync`, { deviceLastSyncAt });
    const { userEntityMarkers: userEntityMarkersPayload, userFeedMarkers: userFeedMarkersPayload, feedMarkers, userMarkers, } = payload;
    const userEntityMarkers = convertChannelMarkerResponse(userEntityMarkersPayload);
    const userFeedMarkers = convertSubChannelMarkerResponse(userFeedMarkersPayload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ userEntityMarkers, userFeedMarkers, feedMarkers, userMarkers }, { cachedAt });
    fireEvent('local.feedMarker.fetched', { feedMarkers });
    fireEvent('local.channelMarker.fetched', { userEntityMarkers });
    fireEvent('local.subChannelMarker.fetched', { userFeedMarkers });
    fireEvent('local.userMarker.fetched', { userMarkers });
    return {
        data: payload,
        hasMore: payload.feedMarkers.length > 0,
    };
};

const enableUnreadCount = () => {
    const client = getActiveClient();
    client.log('client/api/isUnreadCountEnabled', client.isUnreadCountEnabled);
    if (!client) {
        throw new ASCError('There is no active client', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "fatal" /* Amity.ErrorLevel.FATAL */);
    }
    if (client.isUnreadCountEnabled)
        return false;
    client.isUnreadCountEnabled = true;
    client.useLegacyUnreadCount = false;
    client.emitter.emit('unreadCountEnabled', true);
    return true;
};

/**
 * ```js
 * import { onFeedMarkerUpdated } from '@amityco/ts-sdk'
 * const dispose = onFeedMarkerUpdated(feedMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.UserFeedMarker} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category FeedMarker Events
 */
const onUserFeedMarkerUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        persistUnreadCountInfo(payload);
        payload.feedMarkers.forEach(feedMarker => {
            callback(feedMarker);
        });
    };
    return createEventSubscriber(client, 'feedMarker/onUserFeedMarkerUpdated', 'marker.userFeed-updated', filter);
};

const SYNC_TRIGGER_INTERVAL_TIME = 2000;
const ON_SUB_CHANNEL_DELETE_SYNC_TRIGGER_DELAY = 2000;
let isSyncRunning = false;
let disposers$1 = [];
let isWaitingForResponse = false;
let isConsistentMode = true;
let deviceLastSyncAt = null;
const getDeviceLastSyncAt = () => {
    if (deviceLastSyncAt == null) {
        return new Date();
    }
    return deviceLastSyncAt;
};
const saveDeviceLastSyncAt = (lastSyncAt) => {
    if (lastSyncAt == null)
        return;
    if (!deviceLastSyncAt || lastSyncAt.getTime() > deviceLastSyncAt.getTime()) {
        deviceLastSyncAt = lastSyncAt;
    }
};
const fetchDeviceLastSyncAt = async () => {
    const { data: userMarker } = await getUserMarker();
    if (userMarker == null)
        return;
    saveDeviceLastSyncAt(new Date(userMarker.lastSyncAt));
};
/**
 * list of conditions that make timer still trigger the syncing process.
 * If it's empty, it means sync is stopped.
 * if it's not empty, sync will resume.
 */
let events = [];
/**
 * get current marker sync event list
 * @private
 */
const getMarkerSyncEvents = () => events;
/**
 * set marker sync events
 * @private
 */
const setMarkerSyncEvents = (newEvents) => {
    events = newEvents;
};
/**
 * push new event to marker sync events
 * @private
 */
const pushMarkerSyncEvent = (event) => events.push(event);
/**
 * interval task
 * @private
 */
const markerSyncTrigger = async () => {
    if (isWaitingForResponse) {
        // waiting for the response no need to make another API call
        return;
    }
    if (events.length === 0) {
        // no event that require to call marker sync API
        return;
    }
    try {
        isWaitingForResponse = true;
        // any past events are considered processed here.
        // however during waiting for the response, RTE could add the new message event;
        // which will make the engine trigger another call next round.
        events = [];
        const response = await markerSync(getDeviceLastSyncAt().toISOString());
        const latestLastSyncAt = response.data.userMarkers.reduce((maxLastSyncAt, userMarker) => {
            if (maxLastSyncAt == null ||
                maxLastSyncAt.getTime() < new Date(userMarker.lastSyncAt).getTime()) {
                return new Date(userMarker.lastSyncAt);
            }
            return maxLastSyncAt;
        }, null);
        saveDeviceLastSyncAt(latestLastSyncAt);
        if (response.hasMore) {
            events.push("has_more" /* Amity.MarkerSyncEvent.HAS_MORE */);
        }
    }
    catch (_a) {
        // prevent sync from stopping
    }
    finally {
        if (isWaitingForResponse) {
            isWaitingForResponse = false;
        }
    }
};
const registerEventListeners = () => {
    if (disposers$1.length > 0) {
        return;
    }
    // based on the tech spec design, we designed a fetch marker in case of these events
    // - new message
    // - create channel
    // - remove channel
    // - app going to online again after offline
    disposers$1.push(onOnline(() => {
        // should add RESUME to the event to trigger marker syncing again
        events.push("resume" /* Amity.MarkerSyncEvent.RESUME */);
    }), onMessageCreatedMqtt(message => {
        // only conversation, community and broadcast types can sync
        const client = getActiveClient();
        if (isUnreadCountSupport$1(message) && message.creatorId !== client.userId)
            events.push("new message" /* Amity.MarkerSyncEvent.NEW_MESSAGE */);
    }), onChannelCreated(() => events.push("subchannel is created" /* Amity.MarkerSyncEvent.CHANNEL_CREATED */)), onChannelDeleted(() => events.push("subchannel is deleted" /* Amity.MarkerSyncEvent.CHANNEL_DELETED */)), onChannelJoined(() => events.push("subchannel is joined" /* Amity.MarkerSyncEvent.CHANNEL_JOINED */)), onChannelLeft(() => events.push("subchannel is left" /* Amity.MarkerSyncEvent.CHANNEL_LEFT */)), onSubChannelCreated(() => events.push("subchannel is created" /* Amity.MarkerSyncEvent.SUB_CHANNEL_CREATED */)), onSubChannelDeleted(() => 
    /*
     workaround: when receiving the event for sub-channel deletion,
     before triggering marker update, the SDK will have to add a 2-second delay.
     so that the unread count is calculated correctly.
    */
    setTimeout(() => events.push("subchannel is deleted" /* Amity.MarkerSyncEvent.SUBCHANNEL_IS_DELETED */), ON_SUB_CHANNEL_DELETE_SYNC_TRIGGER_DELAY)), onFeedMarkerUpdated(() => events.push("feed marker updated" /* Amity.MarkerSyncEvent.MARKER_UPDATED */)), onUserMarkerSync(() => events.push("feed marker updated" /* Amity.MarkerSyncEvent.MARKER_UPDATED */)), onUserFeedMarkerUpdated(() => events.push("feed marker updated" /* Amity.MarkerSyncEvent.MARKER_UPDATED */)));
};
const unRegisterEventListeners = () => {
    disposers$1.forEach(fn => fn());
    disposers$1 = [];
};
const startMarkerSync = async () => {
    await fetchDeviceLastSyncAt();
    pushMarkerSyncEvent("start syncing" /* Amity.MarkerSyncEvent.START_SYNCING */);
    isConsistentMode = true;
    isSyncRunning = true;
    registerEventListeners();
    return unRegisterEventListeners;
};
/**
 ```js
 * import { startUnreadSync } from '@amityco/ts-sdk'
 * startUnreadSync()
 * ```
 *
 * start syncing to keep feed markers, channel markers and user makers cache
 * update to the server.
 *
 * @category Marker API
 */
const startUnreadSync = async () => {
    await fetchDeviceLastSyncAt();
    pushMarkerSyncEvent("start syncing" /* Amity.MarkerSyncEvent.START_SYNCING */);
    enableUnreadCount();
    isConsistentMode = false;
    isSyncRunning = true;
    registerEventListeners();
};
/**
 ```js
 * import { stopUnreadSync } from '@amityco/ts-sdk'
 * stopUnreadSync()
 * ```
 *
 * stop unread syncing
 *
 * @category Marker API
 */
const stopUnreadSync = () => {
    isSyncRunning = false;
    setMarkerSyncEvents([]);
    unRegisterEventListeners();
};
setIntervalTask(async () => {
    if (!isSyncRunning)
        return;
    await markerSyncTrigger();
}, SYNC_TRIGGER_INTERVAL_TIME);
const getMarkerSyncConsistentMode = () => isConsistentMode;

/* eslint-disable no-param-reassign */
/*
 * declared earlier to accomodate case when logging in with a different user
 * than the one already connected, in which case the existing subscriptions need
 * to be cleared
 */
let subscriptions = [];
async function runMqtt() {
    await modifyMqttConnection();
}
/* begin_public_function
  id: client.login
*/
/**
 * ```js
 * import { login } from '@amityco/ts-sdk/client/api'
 * const success = await login({
 *   userId: 'XYZ123456789',
 * })
 * ```
 *
 * Connects an {@link Amity.Client} instance to ASC servers
 *
 * @param params the connect parameters
 * @param params.userId the user ID for the current session
 * @param params.displayName the user's displayName for the current session
 * @param params.deviceId Manual override of the user's device id (for device management)
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @returns a success boolean if connected
 *
 * @category Client API
 * @async
 */
const login = async (params, sessionHandler, config) => {
    var _a;
    const client = getActiveClient();
    let unsubWatcher;
    client.log('client/api/connectClient', Object.assign({ apiKey: client.apiKey, sessionState: client.sessionState }, params));
    // if connecting to a different userId than the one that is connected currently
    if (client.userId && client.userId !== params.userId) {
        await logout();
        // Remove subscription to ban and delete
        subscriptions.forEach(fn => fn());
        subscriptions = [];
    }
    // default values
    const defaultDeviceId = await getDeviceId();
    try {
        const { users } = await setClientToken({
            params: Object.assign(Object.assign({}, params), { displayName: params === null || params === void 0 ? void 0 : params.displayName, deviceId: (params === null || params === void 0 ? void 0 : params.deviceId) || defaultDeviceId }),
            options: {
                setAccessTokenCookie: true,
            },
        });
        const user = users.find(u => u.userId === params.userId);
        if (user == null) {
            throw new ASCError(`${params.userId} has not been founded`, 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
        }
        if (user.isDeleted) {
            terminateClient("userDeleted" /* Amity.TokenTerminationReason.USER_DELETED */);
            return false;
        }
        if (user.isGlobalBanned) {
            terminateClient("globalBan" /* Amity.TokenTerminationReason.GLOBAL_BAN */);
            return false;
        }
        // FIXME: events are duplicated if connectClient is called few times without disconnectClient
        // wire websocket events to our event emitter
        proxyWebsocketEvents(client.ws, client.emitter);
        (_a = client.ws) === null || _a === void 0 ? void 0 : _a.open();
        client.userId = user.userId;
        client.sessionHandler = sessionHandler;
        /*
         * Cannot push to subscriptions as watcher needs to continue working even if
         * token expires
         */
        unsubWatcher = client.accessTokenExpiryWatcher(sessionHandler);
        setActiveUser(user);
    }
    catch (error) {
        /*
         * if getting token failed session state reverts to initial state when app
         * is first launched
         */
        SessionWatcher$1.getInstance().setSessionState("notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */);
        // pass error down tree so the calling function handle it
        throw error;
    }
    if ((config === null || config === void 0 ? void 0 : config.disableRTE) !== true) {
        runMqtt();
    }
    await initializeMessagePreviewSetting();
    if (subscriptions.length === 0) {
        subscriptions.push(
        // GLOBAL_BAN
        onClientBanned((_) => {
            terminateClient("globalBan" /* Amity.TokenTerminationReason.GLOBAL_BAN */);
            subscriptions.forEach(fn => fn());
            unsubWatcher();
        }), onTokenTerminated(_ => {
            terminateClient();
            subscriptions.forEach(fn => fn());
            unsubWatcher();
        }), onUserDeleted$2((user) => {
            if (user.userId === client.userId) {
                terminateClient("userDeleted" /* Amity.TokenTerminationReason.USER_DELETED */);
                subscriptions.forEach(fn => fn());
                unsubWatcher();
            }
        }), onTokenExpired(state => {
            SessionWatcher$1.getInstance().setSessionState(state);
            logout();
            subscriptions.forEach(fn => fn());
        }), 
        // NOTE: This is a temporary solution to handle the channel marker when the user is forced to leave
        // the channel because currently backend can't handle this, so every time a user is banned from
        // a channel or the channel is deleted the channel's unread count will not be reset to zero
        onChannelDeleted(removeChannelMarkerCache), onChannelMemberBanned(removeChannelMarkerCache), markReadEngineOnLoginHandler(), analyticsEngineOnLoginHandler(), objectResolverEngineOnLoginHandler());
        if (client.useLegacyUnreadCount) {
            subscriptions.push(readReceiptSyncEngineOnLoginHandler());
        }
        else
            subscriptions.push(legacyReadReceiptSyncEngineOnLoginHandler());
        const markerSyncUnsubscriber = await startMarkerSync();
        subscriptions.push(markerSyncUnsubscriber);
    }
    return true;
};
/* end_public_function */

/* begin_public_function
  id: client.renew_access_token
*/
/*
 * Renewal defintion accepted by SessionHandler interface
 *
 * Tech Spec:
 * https://ekoapp.atlassian.net/wiki/spaces/UP/pages/2082537485/ASC+Core+-+Session+Management+3.0#Session-Handler
 *
 * @category private
 */
const renewal = () => {
    let tokenRenewed = false;
    let renewTimeoutId;
    const client = getActiveClient();
    client.log('initiating access token renewal');
    /*
     * Renews a token if it is hasn't been renewed before. Also marks token as
     * renewed once done
     * Per instance of Renewal, only one renewal is allowed
     */
    const renewToken = async (authToken) => {
        const { userId, displayName } = getActiveUser();
        const deviceId = await getDeviceId();
        const params = { userId, displayName, authToken, deviceId };
        if (client.sessionState === "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */ && client.sessionHandler) {
            await login(params, client.sessionHandler);
        }
        else {
            // about to expire
            await setClientToken({
                params,
                options: {
                    setAccessTokenCookie: true,
                },
            });
        }
        tokenRenewed = true;
        if (renewTimeoutId)
            clearTimeout(renewTimeoutId);
    };
    return {
        renew: () => {
            if (tokenRenewed) {
                console.log("'renew' method can be called only once per renewal instance");
                return;
            }
            renewToken();
        },
        renewWithAuthToken: (authToken) => {
            if (tokenRenewed) {
                console.log("'renewWithAuthToken' method can be called only once per renewal instance");
                return;
            }
            renewToken(authToken);
        },
        unableToRetrieveAuthToken: () => {
            renewTimeoutId = setTimeout(() => {
                var _a;
                (_a = client.sessionHandler) === null || _a === void 0 ? void 0 : _a.sessionWillRenewAccessToken(renewal());
            }, ACCESS_TOKEN_WATCHER_INTERVAL);
        },
    };
};
/* end_public_function */

const ABOUT_TO_EXPIRE_THRESHOLD = 80 / 100;
const COMPENSATED_DELAY = 5 * MINUTE;
/*
 * a helper function to check if the token has expires
 *
 * @param token to be checked
 * @returns boolean indicating if token expires
 *
 * @category private
 */
const isExpired = (expiresAt) => Date.now() > Date.parse(expiresAt) - COMPENSATED_DELAY;
/*
 * a helper function to check if the token is about to expire
 *
 * @param token to be checked
 * @returns boolean indicating if token is aboutToExpire
 *
 * @category private
 */
const isAboutToExpire = (params) => {
    const { expiresAt, issuedAt } = params;
    const expires = Date.parse(expiresAt);
    const issued = Date.parse(issuedAt);
    const now = Date.now();
    const duration = expires - issued - COMPENSATED_DELAY;
    const aboutToExpireAt = issued + duration * ABOUT_TO_EXPIRE_THRESHOLD;
    return now > aboutToExpireAt && now < expires;
};
/*
 * Monitors time to expire of token and updates session state to aboutToExpire
 *
 * @returns intervalId to be cleared after trigger
 *
 * @category private
 */
const accessTokenExpiryWatcher = (sessionHandler) => {
    const interval = setInterval(() => {
        const client = getActiveClient();
        if (!client.token)
            return;
        const { issuedAt, expiresAt } = client.token;
        if (isExpired(expiresAt)) {
            /*
             * the event handler will take care of updating session state
             * Note, this will also clear the interval id, so this event will only be
             * fired once
             */
            fireEvent('tokenExpired', "tokenExpired" /* Amity.SessionStates.TOKEN_EXPIRED */);
            /*
             * https://ekoapp.atlassian.net/wiki/spaces/UP/pages/2082537485/ASC+Core+-+Session+Management+3.0#Automatically-initiate-renewal-flow
             *
             * Why sechduled task?
             * Since fireEvent is scheduled, it will be called
             * after sessionHandler leading to an invalid state change from
             * establishing to tokenExpired
             */
            scheduleTask(() => sessionHandler.sessionWillRenewAccessToken(renewal()));
            return;
        }
        if (isAboutToExpire({ expiresAt, issuedAt })) {
            sessionHandler.sessionWillRenewAccessToken(renewal());
        }
    }, ACCESS_TOKEN_WATCHER_INTERVAL);
    return () => clearInterval(interval);
};

const DEFAULT_DEBUG_SESSION = 'amity';
/**
 * ```js
 * import { createClient } from '@amityco/ts-sdk'
 * const client = createClient(apiKey, 'https://asc.server/', 'myClient')
 * ```
 *
 * Creates a new {@link Amity.Client} instance
 *
 * @param apiKey for the {@link Amity.Client} instance
 * @param apiRegion endpoint to connect to
 * @param apiEndpoint custom endpoint in case you don't want to use a preset endpoint
 * @param param.debugSession session's identifier for the client's logger instance
 * @returns A {@link Amity.Client} instance
 *
 * @category Client API
 * */
const createClient = (apiKey, apiRegion = API_REGIONS.SG, { debugSession = DEFAULT_DEBUG_SESSION, apiEndpoint, prefixDeviceIdKey, rteEnabled = true, } = {}) => {
    var _a, _b, _c;
    const log = createLogger(debugSession);
    log('client/api/createClient', {
        apiKey: apiKey.replace(/.{5}$/g, 'xxxxx'),
        apiRegion,
    });
    const httpEndpoint = (_a = apiEndpoint === null || apiEndpoint === void 0 ? void 0 : apiEndpoint.http) !== null && _a !== void 0 ? _a : computeUrl('http', apiRegion);
    const uploadEndpoint = (_b = apiEndpoint === null || apiEndpoint === void 0 ? void 0 : apiEndpoint.upload) !== null && _b !== void 0 ? _b : computeUrl('upload', apiRegion);
    const mqttEndpoint = (_c = apiEndpoint === null || apiEndpoint === void 0 ? void 0 : apiEndpoint.mqtt) !== null && _c !== void 0 ? _c : computeUrl('mqtt', apiRegion);
    const http = createHttpTransport(httpEndpoint);
    const upload = createHttpTransport(uploadEndpoint);
    let ws;
    let mqtt;
    if (rteEnabled) {
        ws = createWebsocketTransport(httpEndpoint);
        mqtt = createMqttTransport(mqttEndpoint);
    }
    const emitter = createEventEmitter();
    /*
     * Since v6 cache is enabled by default
     */
    const cache = { data: {} };
    const sessionState = "notLoggedIn" /* Amity.SessionStates.NOT_LOGGED_IN */;
    const sessionHandler = undefined;
    const isUnreadCountEnabled = false;
    // Legacy unread count is true by default
    const useLegacyUnreadCount = true;
    const client = {
        version: `${VERSION}`,
        apiKey,
        /*
         * SDK Components
         */
        log,
        cache,
        /*
         * Network components
         */
        http,
        ws,
        mqtt,
        upload,
        emitter,
        /*
         * Session Components
         */
        sessionState,
        accessTokenExpiryWatcher,
        sessionHandler,
        hasPermission: hasPermission$1,
        validateUrls,
        validateTexts,
        getFeedSettings,
        getSocialSettings,
        getMessagePreviewSetting,
        use: () => setActiveClient(client),
        isUnreadCountEnabled,
        useLegacyUnreadCount,
        getMarkerSyncConsistentMode,
        /**
         * Prefix for the deviceId key in the local storage or async storage.
         * This is allow user to have multiple SDK client and Mqtt client within the same app.
         */
        prefixDeviceIdKey,
    };
    try {
        const activeClient = getActiveClient();
        if (activeClient.apiKey === apiKey)
            return activeClient;
        setActiveClient(client);
    }
    catch (_d) {
        setActiveClient(client);
    }
    return client;
};

/* begin_public_function
  id: client.secureLogout
*/
/**
 * ```js
 * import { Client } from '@amityco/ts-sdk'
 * const success = await Client.secureLogout()
 * ```
 *
 * Revoke access token for current user and disconnects an {@link Amity.Client} instance from ASC servers
 *
 * @returns a success boolean if disconnected
 *
 * @category Client API
 * @async
 */
const secureLogout = async () => {
    const client = getActiveClient();
    const { data: { success }, } = await client.http.delete('/api/v4/sessions');
    if (!success) {
        throw new Error('Failed to logout');
    }
    const result = await logout();
    return result;
};
/* end_public_function */

/**
 * ```js
 * import { isConnected } from '@amityco/ts-sdk'
 * const connected = isConnected()
 * ```
 *
 * Checks if a {@link Amity.Client} instance is connected to ASC servers
 *
 * @returns a success boolean if connected
 *
 * @category Client API
 */
const isConnected = () => {
    var _a, _b;
    const client = getActiveClient();
    client.log('client/api/isConnected', client);
    // if client is connected to ws, it means client is connected. If ws is undefined, it means ws is not used.
    const isWsConnected = (client.ws && client.ws.connected) || !!client.ws;
    return !!(client.userId &&
        ((_b = String((_a = client.http.defaults.headers.common) === null || _a === void 0 ? void 0 : _a.Authorization)) === null || _b === void 0 ? void 0 : _b.length) &&
        isWsConnected);
};

var _GlobalFileAccessType_fileAccessType;
class GlobalFileAccessType {
    constructor() {
        _GlobalFileAccessType_fileAccessType.set(this, exports.FileAccessTypeEnum.PUBLIC);
    }
    setFileAccessType(fileAccessType) {
        __classPrivateFieldSet(this, _GlobalFileAccessType_fileAccessType, fileAccessType, "f");
    }
    getFileAccessType() {
        return __classPrivateFieldGet(this, _GlobalFileAccessType_fileAccessType, "f");
    }
}
_GlobalFileAccessType_fileAccessType = new WeakMap();
let instance;
var GlobalFileAccessType$1 = {
    getInstance: () => {
        if (!instance) {
            instance = new GlobalFileAccessType();
        }
        return instance;
    },
};

function setUploadedFileAccessType(accessType) {
    GlobalFileAccessType$1.getInstance().setFileAccessType(accessType);
}

/**
 * ```js
 * import { fetchLinkPreview } from '@amityco/ts-sdk'
 * const { title, description, imageUrl } = fetchLinkPreview('https://www.example.com/')
 * ```
 *
 *
 * @param url the url to fetch link preview
 * @returns A {@link Amity.LinkPreview} instance
 *
 * @category Client API
 * */
const fetchLinkPreview = async (url) => {
    const client = getActiveClient();
    let fetchUrl = url;
    if (!/^https?:\/\//i.test(url)) {
        fetchUrl = `https://${url}`;
    }
    const { data } = await client.http.get(`/api/v1/link-preview?url=${encodeURIComponent(fetchUrl)}`);
    return data;
};

/**
 * ```js
 * import { onChannelMarkerFetched } from '@amityco/ts-sdk'
 * const dispose = onChannelMarkerFetched(channelMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.ChannelMarker} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category ChannelMarker Events
 */
const onChannelMarkerFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        payload.userEntityMarkers.forEach(marker => {
            callback(marker);
        });
    };
    return createEventSubscriber(client, 'channelMarker/onChannelMarkerFetched', 'local.channelMarker.fetched', filter);
};

/**
 * ```js
 * import { onSubChannelMarkerFetched } from '@amityco/ts-sdk'
 * const dispose = onSubChannelMarkerFetched(subChannelMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.SubChannelMarker} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category SubChannelMarker Events
 */
const onSubChannelMarkerFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        payload.userFeedMarkers.forEach(callback);
    };
    return createEventSubscriber(client, 'subChannelMarker/onSubChannelMarkerFetched', 'local.subChannelMarker.fetched', filter);
};

/**
 * ```js
 * import { onSubChannelMarkerUpdated } from '@amityco/ts-sdk'
 * const dispose = onSubChannelMarkerUpdated(subChannelMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.SubChannelMarker} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category SubChannelMarker Events
 */
const onSubChannelMarkerUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.userFeedMarkers);
    };
    return createEventSubscriber(client, 'subChannelMarker/onSubChannelMarkerUpdated', 'local.subChannelMarker.updated', filter);
};

/**
 * ```js
 * import { onFeedMarkerFetched } from '@amityco/ts-sdk'
 * const dispose = onFeedMarkerFetched(feedMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.FeedMarker} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category FeedMarker Events
 */
const onFeedMarkerFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.feedMarkers[0]);
    };
    return createEventSubscriber(client, 'feedMarker/onFeedMarkerFetched', 'local.feedMarker.fetched', filter);
};

/**
 * ```js
 * import { onUserMarkerFetched } from '@amityco/ts-sdk'
 * const dispose = onUserMarkerFetched(userMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.UserMarker} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category UserMarker Events
 */
const onUserMarkerFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.userMarkers);
    };
    return createEventSubscriber(client, 'userMarker/onUserMarkerFetched', 'local.userMarker.fetched', filter);
};
const onUserMarkerFetchedLegacy = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.userMarkers[0]);
    };
    return createEventSubscriber(client, 'userMarker/onUserMarkerFetched', 'local.userMarker.fetched', filter);
};

/**
 * ```js
 * import { onMessageMarkerFetched } from '@amityco/ts-sdk'
 * const dispose = onMessageMarkerFetched(messageMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.MessageMarker} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category MessageMarker Events
 */
const onMessageMarkerFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.contentMarkers[0]);
    };
    return createEventSubscriber(client, 'messageMarker/onMessageMarkerFetched', 'local.messageMarker.fetched', filter);
};

/**
 * ```js
 * import { onMessageMarked } from '@amityco/ts-sdk'
 * const dispose = onMessageMarked(markedMessage => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} has been mark read/delivered
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Marker Events
 */
const onMessageMarked = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a, _b, _c;
        ingestInCache(payload);
        const cacheCollection = queryCache(['message', 'collection']);
        const { contentMarkers, feedMarkers } = payload;
        if (cacheCollection && (cacheCollection === null || cacheCollection === void 0 ? void 0 : cacheCollection.length) > 0 && (feedMarkers === null || feedMarkers === void 0 ? void 0 : feedMarkers.length) > 0) {
            /**
             * in case of read the message collection,
             * use feedId of the feedMarkers to check if it equal to subChannelId.
             */
            const currentMessageCollection = cacheCollection.filter(currentMessage => {
                var _a, _b;
                return ((_b = (_a = currentMessage.data) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.subChannelId) === feedMarkers[0].feedId;
            });
            if (currentMessageCollection.length > 0 && (contentMarkers === null || contentMarkers === void 0 ? void 0 : contentMarkers.length) > 0) {
                const currentMessages = (_c = (_b = (_a = currentMessageCollection[0].data) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.map(messageId => pullFromCache(['message', 'get', messageId])).map(({ data }) => data).filter(Boolean)) !== null && _c !== void 0 ? _c : [];
                currentMessages.forEach(message => {
                    var _a, _b;
                    const cacheKeyMessageMarker = [
                        'messageMarker',
                        'get',
                        getResolver('messageMarker')({
                            creatorId: message.creatorPrivateId,
                            feedId: message.subChannelId,
                            contentId: message.messageId,
                        }),
                    ];
                    const messageMarker = (_a = pullFromCache(cacheKeyMessageMarker)) === null || _a === void 0 ? void 0 : _a.data;
                    if (!messageMarker)
                        return;
                    const isSameSubChannelId = contentMarkers[0].feedId === messageMarker.feedId;
                    const isReadCountLatest = contentMarkers[0].readCount > messageMarker.readCount;
                    const isDeliveredCountLatest = ((_b = contentMarkers[0]) === null || _b === void 0 ? void 0 : _b.deliveredCount) > messageMarker.deliveredCount;
                    if (isSameSubChannelId) {
                        const newCacheData = Object.assign(Object.assign({}, messageMarker), { readCount: isReadCountLatest ? contentMarkers[0].readCount : messageMarker.readCount, deliveredCount: isDeliveredCountLatest
                                ? contentMarkers[0].deliveredCount
                                : messageMarker.deliveredCount });
                        pushToCache(cacheKeyMessageMarker, newCacheData);
                    }
                });
            }
        }
        callback(payload.contentMarkers[0]);
    };
    return createEventSubscriber(client, 'messageMarker/onMessageMarked', 'marker.marked-message', filter);
};

function isObject(value) {
    return typeof value === 'object' && value !== null;
}
/**
 *  convert all object getter property to static value
 */
const convertGetterPropsToStatic = (obj) => {
    if (!isObject(obj)) {
        return obj;
    }
    const entries = Object.entries(obj).map(([key, value]) => {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (typeof (descriptor === null || descriptor === void 0 ? void 0 : descriptor.get) === 'function') {
            return [key, descriptor.get.call(obj)];
        }
        return [key, value];
    });
    return Object.fromEntries(entries);
};
const removeFunctionProperties = (obj) => {
    if (!isObject(obj)) {
        return obj;
    }
    const entries = Object.entries(obj).map(([key, value]) => {
        if (typeof value === 'function') {
            return [key, undefined];
        }
        return [key, value];
    });
    return Object.fromEntries(entries);
};

/**
 *
 * ```js
 * import { getUserUnread } from '@amityco/ts-sdk';
 *
 * const unsubscribe = getUserUnread(response => {
 *   userUnread = response.data;
 * });
 * ```
 *
 * Observe current user's unread including unreadCount and hasMentioned from {@link Amity.UserMarker}
 *
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the events
 *
 * @category Message Live Object
 */
const getUserUnread = (callback) => {
    const { _id: userId } = getActiveUser();
    if (!userId)
        throw new ASCError('The _id has not been defined in ActiveUser', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log('For using Live Object feature you need to enable Cache!');
    }
    const timestamp = Date.now();
    log(`liveUserUnread(tmpid: ${timestamp}) > listen`);
    const disposers = [];
    let isUnsyncedModel = false; // for messages
    let model;
    const dispatcher = (data) => {
        const { data: userUnread } = data;
        const callbackModel = userUnread
            ? {
                unreadCount: userUnread.unreadCount,
                isMentioned: userUnread.isMentioned,
            }
            : undefined;
        model = callbackModel ? convertGetterPropsToStatic(callbackModel) : callbackModel;
        callback({
            data: callbackModel
                ? Object.assign(Object.assign({}, callbackModel), { isMentioned: callbackModel.isMentioned }) : callbackModel,
            loading: data.loading,
            error: data.error,
        });
    };
    const realtimeRouter = (userMarkers) => {
        var _a;
        const filterUserMarkers = userMarkers.filter(userMarker => userId === userMarker.userId);
        const latestUserMarker = filterUserMarkers.reduce((currentMaxUserMarker, userMarker) => {
            if (currentMaxUserMarker == null ||
                new Date(userMarker.lastSyncAt).getTime() >
                    new Date(currentMaxUserMarker.lastSyncAt).getTime()) {
                return userMarker;
            }
            return currentMaxUserMarker;
        }, null);
        const eventModel = {
            unreadCount: (_a = latestUserMarker === null || latestUserMarker === void 0 ? void 0 : latestUserMarker.unreadCount) !== null && _a !== void 0 ? _a : 0,
            isMentioned: filterUserMarkers.some(userMarker => !!userMarker.isMentioned),
        };
        if (isEqual(model, eventModel))
            return;
        dispatcher({
            loading: false,
            data: eventModel,
        });
    };
    function isAmityUserMarkerData(data) {
        /**
         * The `data` return from runQuery is Amity.UserMarker | undefined.
         * It's not located inside data field
         */
        if (data == null)
            return false;
        return data != null;
    }
    const onFetch = () => {
        const query = createQuery(getUserMarker);
        runQuery(query, ({ error, data, loading, origin, cachedAt }) => {
            if (!isAmityUserMarkerData(data)) {
                dispatcher({ loading, data: undefined, origin, error });
                return;
            }
            if (cachedAt === UNSYNCED_OBJECT_CACHED_AT_VALUE) {
                dispatcher({
                    data,
                    origin,
                    loading: false,
                    error: new ASCApiError(UNSYNCED_OBJECT_CACHED_AT_MESSAGE, 800800 /* Amity.ClientError.DISALOOW_UNSYNCED_OBJECT */, "error" /* Amity.ErrorLevel.ERROR */),
                });
                isUnsyncedModel = true;
                disposers.forEach(fn => fn());
            }
            else if (!isUnsyncedModel) {
                dispatcher({ loading, data, origin, error });
            }
            if (error) {
                disposers.forEach(fn => fn());
            }
        });
    };
    disposers.push(onUserMarkerFetched(userMarkers => realtimeRouter(userMarkers)));
    onFetch();
    return () => {
        disposers.forEach(fn => fn());
    };
};

var index$m = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getActiveClient: getActiveClient,
  getActiveUser: getActiveUser,
  setActiveUser: setActiveUser,
  createClient: createClient,
  login: login,
  logout: logout,
  secureLogout: secureLogout,
  isConnected: isConnected,
  getFeedSettings: getFeedSettings,
  renewal: renewal,
  markerSync: markerSync,
  enableUnreadCount: enableUnreadCount,
  setUploadedFileAccessType: setUploadedFileAccessType,
  fetchLinkPreview: fetchLinkPreview,
  onConnectionError: onConnectionError,
  onClientDisconnected: onClientDisconnected,
  onClientBanned: onClientBanned,
  onSessionStateChange: onSessionStateChange,
  onNetworkActivities: onNetworkActivities,
  getUserUnread: getUserUnread,
  getMarkerSyncEvents: getMarkerSyncEvents,
  setMarkerSyncEvents: setMarkerSyncEvents,
  pushMarkerSyncEvent: pushMarkerSyncEvent,
  markerSyncTrigger: markerSyncTrigger,
  startMarkerSync: startMarkerSync,
  startUnreadSync: startUnreadSync,
  stopUnreadSync: stopUnreadSync,
  getMarkerSyncConsistentMode: getMarkerSyncConsistentMode
});

function prepareFollowersPayload(response) {
    const { users, follows } = response, rest = __rest(response, ["users", "follows"]);
    return Object.assign(Object.assign({}, rest), { follows, users: users.map(convertRawUserToInternalUser) });
}
function prepareFollowingsPayload(response) {
    const { users, follows } = response, rest = __rest(response, ["users", "follows"]);
    return Object.assign(Object.assign({}, rest), { follows, users: users.map(convertRawUserToInternalUser) });
}
function prepareFollowStatusPayload(response) {
    const { follows } = response, rest = __rest(response, ["follows"]);
    return Object.assign(Object.assign({}, rest), { follows });
}

/* begin_public_function
  id: user.relationship.block
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const blockedUser = await UserRepository.blockUser('userId')
 * ```
 *
 * Blocks a {@link Amity.InternalUser}
 *
 * @param userId The ID of the {@link Amity.InternalUser} to block
 * @returns the blocked {@link Amity.InternalUser} object
 *
 * @category Post API
 * @async
 */
const blockUser = async (userId) => {
    const client = getActiveClient();
    client.log('user/blockUser', userId);
    const { data } = await client.http.post(`/api/v4/me/user-blocks/${userId}`);
    const cachedAt = client.cache && Date.now();
    const { follows, followCounts } = data;
    const followStatus = { follows };
    if (client.cache) {
        ingestInCache(followStatus, { cachedAt });
        upsertInCache(['followInfo', 'get', userId], followCounts[0], { cachedAt });
    }
    const payload = prepareFollowStatusPayload(followStatus);
    fireEvent('local.follow.unfollowed', payload);
    return data;
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.unblock
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const unblockedUser = await UserRepository.blockUser('userId')
 * ```
 *
 * Blocks a {@link Amity.InternalUser}
 *
 * @param userId The ID of the {@link Amity.InternalUser} to unblock
 * @returns the unblocked {@link Amity.InternalUser} object
 *
 * @category Post API
 * @async
 */
const unBlockUser = async (userId) => {
    const client = getActiveClient();
    client.log('user/unBlockUser', userId);
    const { data } = await client.http.delete(`/api/v4/me/user-blocks/${userId}`);
    const cachedAt = client.cache && Date.now();
    const { follows, followCounts } = data;
    const followStatus = { follows };
    if (client.cache) {
        ingestInCache(followStatus, { cachedAt });
        upsertInCache(['followInfo', 'get', userId], followCounts[0], { cachedAt });
    }
    const payload = prepareFollowStatusPayload(followStatus);
    fireEvent('local.follow.created', payload);
    return data;
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.follow
*/
/**
 * ```js
 * import { follow } from '@amityco/ts-sdk'
 * const status = await follow('foobar')
 * ```
 *
 * Follow the user
 *
 * @param userId the ID of the {@link Amity.InternalUser}
 * @returns the status {@link Amity.FollowStatus}
 *
 * @category Follow API
 * @async
 */
const follow = async (userId) => {
    const client = getActiveClient();
    client.log('follow/follow', userId);
    const { data } = await client.http.post(`/api/v4/me/following/${userId}`);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
    }
    const payload = prepareFollowStatusPayload(data);
    if (data.follows[0].status === 'accepted') {
        fireEvent('local.follow.created', payload);
    }
    else {
        fireEvent('local.follow.requested', payload);
    }
    return {
        data: data.follows[0],
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.unfollow
*/
/**
 * ```js
 * import { unfollow } from '@amityco/ts-sdk'
 * await unfollow('foobar')
 * ```
 *
 * Cancel the follow request or unfollow the user
 *
 * @param userId the ID of the {@link Amity.InternalUser}
 * @returns A success boolean if the user {@link Amity.InternalUser} was unfollowed
 *
 * @category Follow API
 * @async
 */
const unfollow = async (userId) => {
    const client = getActiveClient();
    client.log('follow/unfollow', userId);
    const { data } = await client.http.delete(`/api/v4/me/following/${userId}`);
    if (client.cache) {
        ingestInCache(data);
    }
    const payload = prepareFollowStatusPayload(data);
    fireEvent('local.follow.unfollowed', payload);
    return true;
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.accept_follow
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * await UserRepository.Relationship.acceptMyFollower('foobar')
 * ```
 *
 * Accept the follow request
 *
 * @param userId the ID of the {@link Amity.InternalUser} follower
 * @returns A success boolean if the follow request was accepted
 *
 * @category Follow API
 * @async
 */
const acceptMyFollower = async (userId) => {
    const client = getActiveClient();
    client.log('follow/acceptMyFollower', userId);
    const { data } = await client.http.post(`/api/v4/me/followers/${userId}`);
    if (client.cache) {
        ingestInCache(data);
    }
    const payload = prepareFollowStatusPayload(data);
    fireEvent('local.follow.accepted', payload);
    return true;
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.decline_follow
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * await UserRepository.Relationship.declineMyFollower('foobar')
 * ```
 *
 * Decline the follow request or delete the follower
 *
 * @param userId the ID of the {@link Amity.InternalUser} follower
 * @returns A success boolean if the follow request was decline
 *
 * @category Follow API
 * @async
 */
const declineMyFollower = async (userId) => {
    const client = getActiveClient();
    client.log('follow/declineMyFollower', userId);
    const { data } = await client.http.delete(`/api/v4/me/followers/${userId}`);
    if (client.cache) {
        ingestInCache(data);
    }
    const payload = prepareFollowStatusPayload(data);
    fireEvent('local.follow.requestDeclined', payload);
    return true;
};
/* end_public_function */

const createFollowEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (data) => {
        const payload = prepareFollowersPayload(data);
        if (!client.cache) {
            callback(payload.follows[0]);
        }
        else {
            ingestInCache(payload);
            callback(payload.follows[0]);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};
const createLocalFollowEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (data) => {
        const payload = prepareFollowStatusPayload(data);
        if (!client.cache) {
            callback(payload.follows[0]);
        }
        else {
            ingestInCache(payload);
            callback(payload.follows[0]);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onUserFollowed } from '@amityco/ts-sdk'
 * const dispose = onUserFollowed(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user follows another users and confirmation is not required
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onUserFollowed = (callback) => createFollowEventSubscriber('follow.created', callback);

/**
 * ```js
 * import { onUserUnfollowed } from '@amityco/ts-sdk'
 * const dispose = onUserFollowed(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user unfollows
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onUserUnfollowed = (callback) => createFollowEventSubscriber('follow.unfollowed', callback);

/**
 * ```js
 * import { onFollowerDeleted } from '@amityco/ts-sdk'
 * const dispose = onFollowerDeleted(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a follower has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowerDeleted = (callback) => createFollowEventSubscriber('follow.followerDeleted', callback);

/**
 * ```js
 * import { onFollowerRequested } from '@amityco/ts-sdk'
 * const dispose = onFollowerRequested(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user follows another users and confirmation is required
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowerRequested = (callback) => createFollowEventSubscriber('follow.requested', callback);

/**
 * ```js
 * import { onFollowRequestCanceled } from '@amityco/ts-sdk'
 * const dispose = onFollowRequestCanceled(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a follow request has been canceled
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowRequestCanceled = (callback) => createFollowEventSubscriber('follow.requestCanceled', callback);

/**
 * ```js
 * import { onFollowRequestAccepted } from '@amityco/ts-sdk'
 * const dispose = onFollowRequestAccepted(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a follow request has been accepted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowRequestAccepted = (callback) => createFollowEventSubscriber('follow.accepted', callback);

/**
 * ```js
 * import { onFollowRequestDeclined } from '@amityco/ts-sdk'
 * const dispose = onFollowRequestDeclined(status => {
 *   // ...
 * })
 * ```
 *
 * Fired when a follow request has been declined
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowRequestDeclined = (callback) => createFollowEventSubscriber('follow.requestDeclined', callback);

/**
 * ```js
 * import { getFollowInfo } from '@amityco/ts-sdk'
 * const { data: followInfo } = await getFollowInfo('foobar')
 * ```
 *
 * Fetches the number of followers, followings, pending requests and the follow status for current user
 *
 * @param userId the ID of the {@link Amity.InternalUser}
 * @returns the associated {@link Amity.FollowInfo} object
 *
 * @category Follow API
 * @async
 */
const getFollowInfo$1 = async (userId) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('follow/getFollowInfo', userId);
    const { data } = await client.http.get(client.userId === userId ? `/api/v4/me/followInfo` : `/api/v5/users/${userId}/followInfo`);
    const cachedAt = client.cache && Date.now();
    const followInfo = 'follows' in data
        ? Object.assign(Object.assign({}, data.followCounts[0]), { status: (_b = (_a = data.follows) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.status }) : data.followCounts[0];
    if (client.cache) {
        pushToCache(['followInfo', 'get', userId], followInfo, {
            cachedAt,
        });
    }
    return {
        data: followInfo,
        cachedAt,
    };
};
/**
 * ```js
 * import { getFollowInfo } from '@amityco/ts-sdk'
 * const { data: followInfo } = getFollowInfo.locally('foobar')
 * ```
 *
 * Fetches the number of followers, followings, pending requests and the follow status for current user from cache
 *
 * @param userId the ID of the {@link Amity.InternalUser}
 * @returns the associated {@link Amity.FollowInfo} object
 *
 * @category Follow API
 */
getFollowInfo$1.locally = (userId) => {
    const client = getActiveClient();
    client.log('follow/getFollowInfo.locally', userId);
    if (!client.cache) {
        return;
    }
    const cached = pullFromCache(['followInfo', 'get', userId]);
    if (!cached) {
        return;
    }
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/**
 * ```js
 * import { onFollowInfoUpdated } from '@amityco/ts-sdk'
 * const dispose = onFollowInfoUpdated(followInfo => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.FollowInfo} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Follow Events
 */
const onFollowInfoUpdated = (callback) => {
    const handler = async (payload) => {
        const [{ data: followInfoFrom }, { data: followInfoTo }] = await Promise.all([
            getFollowInfo$1(payload.from),
            getFollowInfo$1(payload.to),
        ]);
        callback(followInfoFrom);
        callback(followInfoTo);
    };
    const disposers = [
        createFollowEventSubscriber('follow.created', handler),
        createFollowEventSubscriber('follow.requested', handler),
        createFollowEventSubscriber('follow.accepted', handler),
        createFollowEventSubscriber('follow.unfollowed', handler),
        createFollowEventSubscriber('follow.requestCanceled', handler),
        createFollowEventSubscriber('follow.requestDeclined', handler),
        createFollowEventSubscriber('follow.followerDeleted', handler),
        createLocalFollowEventSubscriber('local.follow.created', handler),
        createLocalFollowEventSubscriber('local.follow.requested', handler),
        createLocalFollowEventSubscriber('local.follow.accepted', handler),
        createLocalFollowEventSubscriber('local.follow.unfollowed', handler),
        createLocalFollowEventSubscriber('local.follow.requestDeclined', handler),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const onLocalUserFollowed = (callback) => createLocalFollowEventSubscriber('local.follow.created', callback);

const onLocalUserUnfollowed = (callback) => createLocalFollowEventSubscriber('local.follow.unfollowed', callback);

const onLocalFollowerRequested = (callback) => createLocalFollowEventSubscriber('local.follow.requested', callback);

const onLocalFollowRequestAccepted = (callback) => createLocalFollowEventSubscriber('local.follow.accepted', callback);

const onLocalFollowRequestDeclined = (callback) => createLocalFollowEventSubscriber('local.follow.requestDeclined', callback);

class PaginationController {
    constructor(queryParams) {
        const { http } = getActiveClient();
        this.queryParams = queryParams;
        this.http = http;
    }
    loadFirstPage() {
        return this.onFetch("first" /* Amity.LiveCollectionPageDirection.FIRST */);
    }
    loadNextPage() {
        return this.onFetch("next" /* Amity.LiveCollectionPageDirection.NEXT */);
    }
    loadPreviousPage() {
        return this.onFetch("prev" /* Amity.LiveCollectionPageDirection.PREV */);
    }
    async onFetch(direction = "first" /* Amity.LiveCollectionPageDirection.FIRST */) {
        var _a, _b, _c, _d;
        if (direction === 'prev' && !this.previousToken)
            return;
        if (direction === 'next' && !this.nextToken)
            return;
        let token;
        if (direction === 'prev')
            token = this.previousToken;
        if (direction === 'next')
            token = this.nextToken;
        const queryResponse = await this.getRequest(this.queryParams, token);
        if (direction === 'first') {
            this.nextToken = (_a = queryResponse.paging) === null || _a === void 0 ? void 0 : _a.next;
            this.previousToken = (_b = queryResponse.paging) === null || _b === void 0 ? void 0 : _b.previous;
        }
        if (direction === 'prev')
            this.previousToken = (_c = queryResponse.paging) === null || _c === void 0 ? void 0 : _c.previous;
        if (direction === 'next')
            this.nextToken = (_d = queryResponse.paging) === null || _d === void 0 ? void 0 : _d.next;
        return queryResponse;
    }
    getNextToken() {
        return this.nextToken;
    }
    getPrevToken() {
        return this.previousToken;
    }
}

class FollowerPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, userId } = queryParams, params = __rest(queryParams, ["limit", "userId"]);
        const options = token ? { token } : { limit };
        const client = getActiveClient();
        const path = client.userId === userId ? `/api/v4/me/followers` : `/api/v4/users/${userId}/followers`;
        const { data: queryResponse } = await this.http.get(path, {
            params: Object.assign(Object.assign({}, params), { options, isDeleted: false }),
        });
        return queryResponse;
    }
}

class QueryStreamController {
    constructor(query, cacheKey) {
        this.query = query;
        this.cacheKey = cacheKey;
    }
}

var EnumFollowActions;
(function (EnumFollowActions) {
    EnumFollowActions["OnRequested"] = "onRequested";
    EnumFollowActions["OnAccepted"] = "onAccepted";
    EnumFollowActions["OnDeclined"] = "onDeclined";
    EnumFollowActions["OnCanceled"] = "onCanceled";
    EnumFollowActions["OnFollowed"] = "onFollowed";
    EnumFollowActions["OnUnfollowed"] = "onUnfollowed";
    EnumFollowActions["OnDeleted"] = "onDeleted";
    EnumFollowActions["OnUserDeleted"] = "onUserDeleted";
})(EnumFollowActions || (EnumFollowActions = {}));

class FollowerQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.follows.map(getResolver('follow')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const follows = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...follows, ...response.follows.map(getResolver('follow'))])] }));
        }
    }
    reactor(action) {
        return (followStatus) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (this.query.userId !== followStatus.to || !collection)
                return;
            switch (action) {
                case EnumFollowActions.OnDeclined:
                case EnumFollowActions.OnCanceled:
                case EnumFollowActions.OnUnfollowed:
                case EnumFollowActions.OnDeleted:
                    collection.data = collection.data.filter(p => p !== getResolver('follow')(followStatus));
                    break;
                case EnumFollowActions.OnRequested:
                case EnumFollowActions.OnAccepted:
                case EnumFollowActions.OnFollowed:
                    collection.data = [...new Set([getResolver('follow')(followStatus), ...collection.data])];
                    break;
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class PaginationNoPageController {
    constructor(queryParams) {
        const { http } = getActiveClient();
        this.queryParams = queryParams;
        this.http = http;
    }
    async onFetch() {
        const queryResponse = await this.getRequest(this.queryParams);
        return queryResponse;
    }
}

class LiveCollectionController {
    constructor(paginationController, queryStreamId, cacheKey, callback) {
        this.paginationController = paginationController;
        this.queryStreamId = queryStreamId;
        this.cacheKey = cacheKey;
        this.callback = callback;
    }
    async refresh() {
        try {
            let result;
            if (this.paginationController instanceof PaginationNoPageController) {
                result = await this.paginationController.onFetch();
            }
            else {
                result = await this.paginationController.loadFirstPage();
            }
            if (!result)
                return;
            await this.persistModel(result);
            this.persistQueryStream({
                response: result,
                direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */,
                refresh: true,
            });
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false });
        }
        catch (e) {
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false, error: e });
        }
    }
    loadPage({ initial = false, direction = "next" /* Amity.LiveCollectionPageDirection.NEXT */, }) {
        this.setup();
        this.notifyChange({ origin: "local" /* Amity.LiveDataOrigin.LOCAL */, loading: true });
        if (initial) {
            this.refresh();
        }
        else if (direction === "prev" /* Amity.LiveCollectionPageDirection.PREV */) {
            this.loadPrevPage();
        }
        else if (direction === "next" /* Amity.LiveCollectionPageDirection.NEXT */) {
            this.loadNextPage();
        }
    }
    async loadNextPage() {
        try {
            if (this.paginationController instanceof PaginationNoPageController)
                return;
            const result = await this.paginationController.loadNextPage();
            if (!result)
                return;
            await this.persistModel(result);
            this.persistQueryStream({
                response: result,
                direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */,
            });
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false });
        }
        catch (e) {
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false, error: e });
        }
    }
    async loadPrevPage() {
        try {
            if (this.paginationController instanceof PaginationNoPageController)
                return;
            const result = await this.paginationController.loadPreviousPage();
            if (!result)
                return;
            await this.persistModel(result);
            this.persistQueryStream({
                response: result,
                direction: "prev" /* Amity.LiveCollectionPageDirection.PREV */,
            });
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false });
        }
        catch (e) {
            this.notifyChange({ origin: "server" /* Amity.LiveDataOrigin.SERVER */, loading: false, error: e });
        }
    }
    shouldNotify(data) {
        const newData = data.map(convertGetterPropsToStatic).map(removeFunctionProperties);
        if (isEqual(this.snapshot, newData))
            return false;
        this.snapshot = newData;
        return true;
    }
    getCacheKey() {
        return this.cacheKey;
    }
}

const onFollowerUserDeleted = ({ userId }) => (callback) => {
    const client = getActiveClient();
    const filter = (data) => {
        const userPayload = prepareUserPayload(data);
        ingestInCache(userPayload);
        const cacheData = pullFromCache([
            'follow',
            'get',
            getResolver('follow')({
                from: userPayload.users[0].userId,
                to: userId,
            }),
        ]);
        if (!cacheData)
            return;
        callback(cacheData === null || cacheData === void 0 ? void 0 : cacheData.data);
    };
    return createEventSubscriber(client, 'user.deleted', 'user.deleted', filter);
};

class FollowerLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](Object.assign(Object.assign({}, query), { type: 'follower' }));
        const cacheKey = ['follow', 'collection', queryStreamId];
        const paginationController = new FollowerPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new FollowerQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareFollowersPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onUserFollowed, action: EnumFollowActions.OnFollowed },
            { fn: onUserUnfollowed, action: EnumFollowActions.OnUnfollowed },
            { fn: onFollowRequestAccepted, action: EnumFollowActions.OnAccepted },
            { fn: onFollowRequestDeclined, action: EnumFollowActions.OnDeclined },
            { fn: onFollowRequestCanceled, action: EnumFollowActions.OnCanceled },
            { fn: onFollowerDeleted, action: EnumFollowActions.OnDeleted },
            { fn: onLocalFollowRequestAccepted, action: EnumFollowActions.OnAccepted },
            { fn: onLocalFollowRequestDeclined, action: EnumFollowActions.OnDeclined },
            { fn: onLocalUserFollowed, action: EnumFollowActions.OnFollowed },
            { fn: onLocalUserUnfollowed, action: EnumFollowActions.OnUnfollowed },
            {
                fn: onFollowerUserDeleted({ userId: this.query.userId }),
                action: EnumFollowActions.OnUserDeleted,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['follow', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let followers = data;
        if (this.query.status && this.query.status !== "all" /* Amity.FollowStatusTypeEnum.All */) {
            followers = followers.filter(follower => follower.status === this.query.status);
        }
        followers = followers.filter(follower => {
            var _a;
            const fromUser = (_a = pullFromCache(['user', 'get', follower.from])) === null || _a === void 0 ? void 0 : _a.data;
            return (fromUser === null || fromUser === void 0 ? void 0 : fromUser.isDeleted) == null || (fromUser === null || fromUser === void 0 ? void 0 : fromUser.isDeleted) === false;
        });
        return followers;
    }
}

/* begin_public_function
  id: user.relationship.query_my_followers, user.relationship.query_followers
*/
/**
 * ```js
 * import { getFollowers } from '@amityco/ts-sdk'
 *
 * let followers = []
 * const unsub = getFollowers({
 *   userId: Amity.InternalUser['userId'];
 * }, response => merge(followers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.FollowStatus} followers for a given userId
 *
 * @param userId the user
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Followers Live Collection
 */
const getFollowers = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getFollowers(tmpid: ${timestamp}) > listen`);
    const followerLiveCollection = new FollowerLiveCollectionController(params, callback);
    const disposers = followerLiveCollection.startSubscription();
    const cacheKey = followerLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getFollowers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

class FollowingPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, userId } = queryParams, params = __rest(queryParams, ["limit", "userId"]);
        const options = token ? { token } : { limit };
        const client = getActiveClient();
        const path = client.userId === userId ? `/api/v4/me/following` : `/api/v4/users/${userId}/following`;
        const { data: queryResponse } = await this.http.get(path, {
            params: Object.assign(Object.assign({}, params), { options, isDeleted: false }),
        });
        return queryResponse;
    }
}

class FollowingQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.follows.map(getResolver('follow')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const follows = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...follows, ...response.follows.map(getResolver('follow'))])] }));
        }
    }
    reactor(action) {
        return (followStatus) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (this.query.userId !== followStatus.from || !collection)
                return;
            switch (action) {
                case EnumFollowActions.OnDeclined:
                case EnumFollowActions.OnCanceled:
                case EnumFollowActions.OnUnfollowed:
                case EnumFollowActions.OnDeleted:
                    collection.data = collection.data.filter(p => p !== getResolver('follow')(followStatus));
                    break;
                case EnumFollowActions.OnRequested:
                case EnumFollowActions.OnAccepted:
                case EnumFollowActions.OnFollowed:
                    collection.data = [...new Set([getResolver('follow')(followStatus), ...collection.data])];
                    break;
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

const onFollowingUserDeleted = ({ userId }) => (callback) => {
    const client = getActiveClient();
    const filter = (data) => {
        const userPayload = prepareUserPayload(data);
        ingestInCache(userPayload);
        const cacheData = pullFromCache([
            'follow',
            'get',
            getResolver('follow')({
                from: userId,
                to: userPayload.users[0].userId,
            }),
        ]);
        if (!cacheData)
            return;
        callback(cacheData === null || cacheData === void 0 ? void 0 : cacheData.data);
    };
    return createEventSubscriber(client, 'user.deleted', 'user.deleted', filter);
};

class FollowingLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](Object.assign(Object.assign({}, query), { type: 'following' }));
        const cacheKey = ['follow', 'collection', queryStreamId];
        const paginationController = new FollowingPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new FollowingQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareFollowingsPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onFollowerRequested, action: EnumFollowActions.OnRequested },
            { fn: onFollowRequestAccepted, action: EnumFollowActions.OnAccepted },
            { fn: onFollowRequestDeclined, action: EnumFollowActions.OnDeclined },
            { fn: onFollowRequestCanceled, action: EnumFollowActions.OnCanceled },
            { fn: onUserFollowed, action: EnumFollowActions.OnFollowed },
            { fn: onUserUnfollowed, action: EnumFollowActions.OnUnfollowed },
            { fn: onFollowerDeleted, action: EnumFollowActions.OnDeleted },
            { fn: onLocalFollowerRequested, action: EnumFollowActions.OnRequested },
            { fn: onLocalFollowRequestAccepted, action: EnumFollowActions.OnAccepted },
            { fn: onLocalFollowRequestDeclined, action: EnumFollowActions.OnDeclined },
            { fn: onLocalUserFollowed, action: EnumFollowActions.OnFollowed },
            { fn: onLocalUserUnfollowed, action: EnumFollowActions.OnUnfollowed },
            {
                fn: onFollowingUserDeleted({ userId: this.query.userId }),
                action: EnumFollowActions.OnUserDeleted,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['follow', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let followings = data;
        if (this.query.status && this.query.status !== "all" /* Amity.FollowStatusTypeEnum.All */) {
            followings = followings.filter(following => following.status === this.query.status);
        }
        followings = followings.filter(following => {
            var _a;
            const toUser = (_a = pullFromCache(['user', 'get', following.to])) === null || _a === void 0 ? void 0 : _a.data;
            return (toUser === null || toUser === void 0 ? void 0 : toUser.isDeleted) == null || (toUser === null || toUser === void 0 ? void 0 : toUser.isDeleted) === false;
        });
        return followings;
    }
}

/* begin_public_function
  id: user.relationship.query_my_followings, user.relationship.query_followings
*/
/**
 * ```js
 * import { getFollowings } from '@amityco/ts-sdk'
 *
 * let followings = []
 * const unsub = getFollowings({
 *   userId: Amity.InternalUser['userId'];
 * }, response => merge(followings, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.FollowStatus} followings for a given userId
 *
 * @param userId the user
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Followings Live Collection
 */
const getFollowings = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log('For using Live Collection feature you need to enable Cache!');
    }
    const timestamp = Date.now();
    log(`getFollowings(tmpid: ${timestamp}) > listen`);
    const followingLiveCollection = new FollowingLiveCollectionController(params, callback);
    const disposers = followingLiveCollection.startSubscription();
    const cacheKey = followingLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getFollowings(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/**
 * @deprecated This function will to be deprecated soon.
 */
const liveObject = (id, callback, key, fetcher, eventHandlers, options) => {
    const { forceDispatch, callbackDataSelector, callbackFilter } = Object.assign({ forceDispatch: false, callbackDataSelector: (data) => data }, options);
    const { cache } = getActiveClient();
    if (!cache) {
        console.log(LIVE_OBJECT_ENABLE_CACHE_MESSAGE);
    }
    let model;
    let isUnsyncedModel = false; // for messages
    const disposers = [];
    const dispatcher = (data) => {
        const { data: newModel } = data, rest = __rest(data, ["data"]);
        if (!callbackFilter || callbackFilter(newModel, model)) {
            callback(Object.assign({ data: callbackDataSelector(newModel) }, rest));
        }
        // resolve all getter on data model to a static value to avoid comparison problems
        model = convertGetterPropsToStatic(newModel);
    };
    const realtimeRouter = (eventModel, forceDispatch = false) => {
        if (id !== eventModel[key]) {
            return;
        }
        if (model) {
            if (!forceDispatch && isEqual(model, eventModel)) {
                return;
            }
        }
        dispatcher({ loading: false, data: eventModel, origin: 'event' });
    };
    const onFetch = () => {
        // TODO: Ihis `@ts-ignore` is bring back to fix the build and it needs to be removed later
        // @ts-ignore
        const query = createQuery(fetcher, id, true);
        runQuery(query, ({ error, data, loading, origin, cachedAt }) => {
            if (cachedAt === UNSYNCED_OBJECT_CACHED_AT_VALUE) {
                dispatcher({
                    // @ts-ignore
                    data,
                    origin,
                    loading: false,
                    error: new ASCApiError(UNSYNCED_OBJECT_CACHED_AT_MESSAGE, 800800 /* Amity.ClientError.DISALOOW_UNSYNCED_OBJECT */, "error" /* Amity.ErrorLevel.ERROR */),
                });
                isUnsyncedModel = true;
                disposers.forEach(fn => fn());
            }
            else if (!isUnsyncedModel) {
                // @ts-ignore
                dispatcher({ loading, data, origin, error });
            }
            if (error) {
                disposers.forEach(fn => fn());
            }
        });
    };
    disposers.push(...eventHandlers.map(fn => fn(eventModel => realtimeRouter(eventModel, forceDispatch))));
    onFetch();
    return () => {
        disposers.forEach(fn => fn());
    };
};

/* begin_public_function
  id: user.relationship.get_follow_info
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk';
 *
 * let followInfo;
 *
 * const unsubscribe = UserRepository.Relationship.getFollowInfo(userId, response => {
 *   followInfo = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.FollowCount} object
 *
 * @param userId the ID of the current user
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing
 *
 * @category FollowInfo Live Object
 */
const getFollowInfo = (userId, callback) => {
    return liveObject(userId, callback, 'userId', getFollowInfo$1, [onFollowInfoUpdated], {
        forceDispatch: true,
    });
};
/* end_public_function */

/* begin_public_function
  id: user.relationship.get_my_follow_info
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk';
 *
 * let myFollowInfo;
 *
 * const unsubscribe = UserRepository.Relationship.getMyFollowInfo(response => {
 *   myFollowInfo = response.data;
 * });
 * ```
 *
 * Observe all mutation on the current users {@link Amity.FollowCount} object
 *
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing
 *
 * @category FollowInfo Live Object
 */
const getMyFollowInfo = (callback) => {
    const { userId } = getActiveUser();
    return liveObject(userId, callback, 'userId', getFollowInfo$1, [onFollowInfoUpdated], {
        /*
         * Required as Amity.FollowInfo does not extend Amity.Timestamps
         */
        forceDispatch: true,
    });
};
/* end_public_function */

var index$l = /*#__PURE__*/Object.freeze({
  __proto__: null,
  blockUser: blockUser,
  unBlockUser: unBlockUser,
  follow: follow,
  unfollow: unfollow,
  acceptMyFollower: acceptMyFollower,
  declineMyFollower: declineMyFollower,
  onUserFollowed: onUserFollowed,
  onUserUnfollowed: onUserUnfollowed,
  onFollowerDeleted: onFollowerDeleted,
  onFollowerRequested: onFollowerRequested,
  onFollowRequestCanceled: onFollowRequestCanceled,
  onFollowRequestAccepted: onFollowRequestAccepted,
  onFollowRequestDeclined: onFollowRequestDeclined,
  onFollowInfoUpdated: onFollowInfoUpdated,
  onLocalUserFollowed: onLocalUserFollowed,
  onLocalUserUnfollowed: onLocalUserUnfollowed,
  onLocalFollowerRequested: onLocalFollowerRequested,
  onLocalFollowRequestAccepted: onLocalFollowRequestAccepted,
  onLocalFollowRequestDeclined: onLocalFollowRequestDeclined,
  getFollowers: getFollowers,
  getFollowings: getFollowings,
  getFollowInfo: getFollowInfo,
  getMyFollowInfo: getMyFollowInfo
});

/* begin_public_function
  id: user.get_by_ids
*/
/**
 * ```js
 * import { getUsers } from '@amityco/ts-sdk'
 * const { data: users } = await getUsers(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.User} objects
 *
 * @param userIds the IDs of the {@link Amity.User} to fetch
 * @returns the associated collection of {@link Amity.User} objects
 *
 * @category User API
 * @async
 */
const getUserByIds = async (userIds) => {
    const client = getActiveClient();
    client.log('user/getUsers', userIds);
    const encodedUserIds = userIds.map(userId => encodeURIComponent(userId));
    // API-FIX: endpoint should not be /list, parameters should be querystring.
    const { data } = await client.http.get(`/api/v3/users/list`, {
        params: { userIds: encodedUserIds },
    });
    const payload = prepareUserPayload(data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(payload, { cachedAt });
    fireEvent('user.fetched', data);
    return {
        data: payload.users.map(user => LinkedObject.user(user)),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getUsers } from '@amityco/ts-sdk'
 * const { data: users } = getUsers.locally!(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.User} objects from cache
 *
 * @param userIds the IDs of the {@link Amity.User} to fetch
 * @returns the associated collection of {@link Amity.User} objects
 *
 * @category User API
 */
getUserByIds.locally = (userIds) => {
    var _a;
    const client = getActiveClient();
    client.log('user/getUsers.locally', userIds);
    if (!client.cache)
        return;
    const cached = userIds
        .map(userId => pullFromCache(['user', 'get', userId]))
        .filter(Boolean);
    const users = cached.map(({ data }) => LinkedObject.user(data));
    const oldest = (_a = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _a === void 0 ? void 0 : _a[0];
    if ((cached === null || cached === void 0 ? void 0 : cached.length) < userIds.length)
        return;
    return {
        data: users,
        cachedAt: oldest.cachedAt,
    };
};

/* begin_public_function
  id: client.update_user
*/
/**
 * ```js
 * import { updateUser } from '@amityco/ts-sdk'
 * const updated = await updateUser(userId, { displayName: 'foobar' })
 * ```
 *
 * Updates an {@link Amity.User}
 *
 * @param userId The ID of the {@link Amity.User} to update
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.User} object
 *
 * @category User API
 * @async
 */
const updateUser = async (userId, patch) => {
    const client = getActiveClient();
    client.log('user/updateUser', userId, patch);
    const { data } = await client.http.put(`/api/v3/users/`, Object.assign(Object.assign({ userId }, patch), { createNewUserWhenNotFound: false }));
    const payload = prepareUserPayload(data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(payload, { cachedAt });
    fireEvent('user.updated', data);
    return {
        data: payload.users.find(user => user.userId === userId),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: user.flag
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const flagged = await UserRepository.flagUser('userId')
 * ```
 *
 * @param userId The ID of the user to add a be flagged
 * @returns the created report result
 *
 * @category User API
 * @async
 * */
const flagUser = async (userId) => {
    const client = getActiveClient();
    client.log('user/flagUser', userId);
    const { data } = await client.http.post(`api/v4/me/flags/${encodeURIComponent(userId)}`);
    const payload = prepareUserPayload(data);
    if (client.cache) {
        ingestInCache(payload);
    }
    fireEvent('user.flagged', data);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: user.unflag
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const unflagged = await UserRepository.unflagUser('post', postId)
 * ```
 *
 * @param userId The ID of the user to unflag
 * @returns the deleted report result
 *
 * @category User API
 * @async
 * */
const unflagUser = async (userId) => {
    const client = getActiveClient();
    client.log('user/unflag', userId);
    const { data } = await client.http.delete(`/api/v4/me/flags/${encodeURIComponent(userId)}`);
    const payload = prepareUserPayload(data);
    if (client.cache) {
        ingestInCache(payload);
    }
    fireEvent('user.unflagged', data);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: user.check_flag_by_me
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const isFlagged = await UserRepository.isUserFlaggedByMe(postId)
 * ```
 *
 * @param userId The ID of the thing to check a report to.
 * @returns `true` if the report is created by me, `false` if doesn't.
 *
 * @category Report API
 * @async
 * */
const isUserFlaggedByMe = async (userId) => {
    const client = getActiveClient();
    client.log('user/isUserFlaggedByMe', userId);
    const { data: { isFlagByMe }, } = await client.http.get(`/api/v3/users/${userId}/isFlagByMe`);
    return isFlagByMe;
};
/* end_public_function */

/**
 * ```js
 * import { onUserUpdated } from '@amityco/ts-sdk'
 * const dispose = onUserUpdated(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalUser} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserUpdated = (callback) => createUserEventSubscriber('user.updated', callback);

/**
 * ```js
 * import { onUserFlagged } from '@amityco/ts-sdk'
 * const dispose = onUserFlagged(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalUser} has been flagged
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserFlagged = (callback) => createUserEventSubscriber('user.flagged', callback);

/**
 * ```js
 * import { onUserUnflagged } from '@amityco/ts-sdk'
 * const dispose = onUserUnflagged(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when a flag has been removed from a {@link Amity.InternalUser}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserUnflagged = (callback) => createUserEventSubscriber('user.unflagged', callback);

/**
 * ```js
 * import { onUserFlagCleared } from '@amityco/ts-sdk'
 * const dispose = onUserFlagCleared(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when flags have been cleared for a {@link Amity.InternalUser}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserFlagCleared = (callback) => createUserEventSubscriber('user.flagCleared', callback);

/**
 * ```js
 * import { onUserFetched } from '@amityco/ts-sdk'
 * const dispose = onUserFetched(user => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalUser} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category User Events
 */
const onUserFetched = (callback) => createUserEventSubscriber('user.fetched', callback);

/**
 * ```js
 * import { getUser } from '~/user/api'
 * const { data: user } = await getUser('foobar')
 * ```
 *
 * Fetches a {@link Amity.User} object
 *
 * @param userId the ID of the {@link Amity.User} to fetch
 * @returns the associated {@link Amity.User} object
 *
 * @category Private
 * @async
 */
const getUser$1 = async (userId) => {
    const client = getActiveClient();
    client.log('user/getUser', userId);
    isInTombstone('user', userId);
    try {
        const { data } = await client.http.get(`/api/v3/users/${encodeURIComponent(userId)}`);
        const cachedAt = client.cache && Date.now();
        const payload = prepareUserPayload(data);
        if (client.cache)
            ingestInCache(payload, { cachedAt });
        fireEvent('user.fetched', data);
        return {
            data: payload.users.find(user => user.userId === userId),
            cachedAt,
        };
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('user', userId);
        }
        throw error;
    }
};
/**
 * ```js
 * import { getUser } from '@amityco/ts-sdk'
 * const { data: user } = getUser.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.User} object from cache
 *
 * @param userId the ID of the {@link Amity.User} to fetch
 * @returns the associated {@link Amity.User} object
 *
 * @category User API
 */
getUser$1.locally = (userId) => {
    const client = getActiveClient();
    client.log('user/getUser.locally', userId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['user', 'get', userId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/* begin_public_function
  id: user.get
*/
/**
 * ```js
 * import { liveUser } from '@amityco/ts-sdk';
 *
 * let user;
 *
 * const unsubscribe = liveUser(userId, response => {
 *   user = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.User}
 *
 * @param userId the ID of the user to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the user
 *
 * @category Message Live Object
 */
const getUser = (userId, callback) => {
    const reactor = (response) => {
        return callback(Object.assign(Object.assign({}, response), { data: response.data ? LinkedObject.user(response.data) : response.data }));
    };
    return liveObject(userId, reactor, 'userId', getUser$1, [
        onUserFetched,
        onUserUpdated,
        onUserDeleted$2,
        onUserFlagged,
        onUserUnflagged,
        onUserFlagCleared,
    ]);
};
/* end_public_function */

class UserPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/users`, {
            params: Object.assign(Object.assign({}, params), { options, isDeleted: false }),
        });
        return queryResponse;
    }
}

class UserQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.users.map(getResolver('user')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const users = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...users, ...response.users.map(getResolver('user'))])] }));
        }
    }
    reactor(action) {
        return (user) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            /*
             * Simply update a collection and let responder decide what to do with data
             */
            collection.data = [...new Set([user.userId, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumUserActions;
(function (EnumUserActions) {
    EnumUserActions["OnUserDeleted"] = "onUserDeleted";
    EnumUserActions["OnUserUpdated"] = "onUserUpdated";
    EnumUserActions["OnUserFlagged"] = "onUserFlagged";
    EnumUserActions["OnUserUnflagged"] = "onUserUnflagged";
    EnumUserActions["OnUserFlagCleared"] = "onUserFlagCleared";
})(EnumUserActions || (EnumUserActions = {}));

class UserLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['user', 'collection', queryStreamId];
        const paginationController = new UserPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new UserQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareUserPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onUserDeleted$2, action: EnumUserActions.OnUserDeleted },
            { fn: onUserUpdated, action: EnumUserActions.OnUserUpdated },
            { fn: onUserFlagged, action: EnumUserActions.OnUserFlagged },
            { fn: onUserUnflagged, action: EnumUserActions.OnUserUnflagged },
            { fn: onUserFlagCleared, action: EnumUserActions.OnUserFlagCleared },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['user', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)
            .map(LinkedObject.user)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let users = data;
        const sortFn = (() => {
            switch (this.query.sortBy) {
                case 'firstCreated':
                    return sortByFirstCreated;
                case 'lastCreated':
                    return sortByLastCreated;
                default:
                    return sortByLastCreated;
            }
        })();
        users = users.sort(sortFn);
        if (this.query.filter === 'flagged') {
            users = users.filter(user => !!user.hashFlag);
        }
        users = users.filter(user => user.isDeleted == null || user.isDeleted === false);
        return users;
    }
}

/* begin_public_function
  id: user.query
*/
/**
 * ```js
 * import { liveUsers } from '@amityco/ts-sdk'
 *
 * let users = []
 * const unsub = liveUsers({}, response => merge(users, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.User}s
 *
 * @param params for querying users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the users
 *
 * @category Category Live Collection
 */
const getUsers = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        // eslint-disable-next-line no-console
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`liveUsers(tmpid: ${timestamp}) > listen`);
    const usersLiveCollection = new UserLiveCollectionController(params, callback);
    const disposers = usersLiveCollection.startSubscription();
    const cacheKey = usersLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`liveUsers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

class BlockedUserPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get('/api/v4/me/user-blocks', {
            params: Object.assign(Object.assign({}, params), { options, isDeleted: false }),
        });
        return queryResponse;
    }
}

class BlockedUserQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.users.map(getResolver('user')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const users = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...users, ...response.users.map(getResolver('user'))])] }));
        }
    }
    reactor(action) {
        return (targetUser) => {
            var _a;
            if (action === EnumFollowActions.OnFollowed) {
                const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                const updatedCollection = collection === null || collection === void 0 ? void 0 : collection.data.filter(id => id !== targetUser.userId);
                pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: updatedCollection }));
            }
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

function prepareBlockedUserPayload(response) {
    const { users, follows } = response, rest = __rest(response, ["users", "follows"]);
    return Object.assign(Object.assign({}, rest), { follows: follows.map(follow => {
            const followUser = users.find(user => user.userId === follow.from);
            return Object.assign(Object.assign({}, follow), { user: convertRawUserToInternalUser(followUser) });
        }), users: users.map(convertRawUserToInternalUser) });
}

const convertEventPayload = (eventHandler, sourceModelProp, destinationDomain) => (callback) => eventHandler(sourceModel => {
    var _a;
    if (!sourceModel) {
        return sourceModel;
    }
    const cacheKey = [destinationDomain, 'get', `${sourceModel[sourceModelProp]}`];
    const model = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
    if (!model)
        return;
    return callback(model);
});

class BlockedUserLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['blockedUsers', 'collection', queryStreamId];
        const paginationController = new BlockedUserPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new BlockedUserQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareBlockedUserPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            {
                fn: onUserDeleted$2,
                action: EnumUserActions.OnUserDeleted,
            },
            // In the case of unblocking a user, we need to subscribe to the follow events
            {
                fn: convertEventPayload(onLocalUserFollowed, 'to', 'user'),
                action: EnumFollowActions.OnFollowed,
            },
            {
                fn: convertEventPayload(onUserFollowed, 'to', 'user'),
                action: EnumFollowActions.OnFollowed,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['user', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)
            .map(LinkedObject.user)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    // eslint-disable-next-line class-methods-use-this
    applyFilter(data) {
        let users = data;
        users = users.filter(user => user.isDeleted == null || user.isDeleted === false);
        return users;
    }
}

/* begin_public_function
  id: user.get_blocked_users
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 * const unblockedUser = await UserRepository.blockUser('userId')
 * ```
 *
 * Blocks a {@link Amity.InternalUser}
 *
 * @param params The params to get blocked {@link Amity.InternalUser}s
 * @param callback to recieve updates on unblocked {@link Amity.InternalUser}s
 * @returns {@link Amity.Unsubscriber} to unsubscribe from collection
 *
 * @category Post API
 * @async
 */
const getBlockedUsers = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getBlockedUsers(tmpid: ${timestamp}) > listen`);
    const blockedUserLiveCollection = new BlockedUserLiveCollectionController(params, callback);
    const disposers = blockedUserLiveCollection.startSubscription();
    const cacheKey = blockedUserLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getBlockedUsers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
        dropFromCache(cacheKey);
    };
};
/* end_public_function */

class SearchUserPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, displayName } = queryParams, params = __rest(queryParams, ["limit", "displayName"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/users`, {
            params: Object.assign(Object.assign({}, params), { keyword: displayName, options, isDeleted: false }),
        });
        return queryResponse;
    }
}

class SearchUserQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.users.map(getResolver('user')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const users = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...users, ...response.users.map(getResolver('user'))])] }));
        }
    }
    reactor(action) {
        return (user) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            /*
             * Simply update a collection and let responder decide what to do with data
             */
            collection.data = [...new Set([user.userId, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class SearchUserLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        var _a;
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['user', 'collection', queryStreamId];
        const paginationController = new SearchUserPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = Object.assign(Object.assign({}, query), { filter: (_a = query.filter) !== null && _a !== void 0 ? _a : 'all' });
        this.queryStreamController = new SearchUserQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareUserPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onUserDeleted$2, action: EnumUserActions.OnUserDeleted },
            { fn: onUserUpdated, action: EnumUserActions.OnUserUpdated },
            { fn: onUserFlagged, action: EnumUserActions.OnUserFlagged },
            { fn: onUserUnflagged, action: EnumUserActions.OnUserUnflagged },
            { fn: onUserFlagCleared, action: EnumUserActions.OnUserFlagCleared },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['user', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)
            .map(LinkedObject.user)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let users = data;
        if (this.query.filter === 'flagged') {
            users = users.filter(user => !!user.hashFlag);
        }
        users = users.filter(user => user.isDeleted == null || user.isDeleted === false);
        return users;
    }
}

/* begin_public_function
  id: user.search
*/
/**
 * ```js
 * import { UserRepository } from '@amityco/ts-sdk'
 *
 * let users = []
 * const unsub = UserRepository.searchUserByDisplayName({}, response => merge(users, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.InternalUser}s
 *
 * @param params for searching users
 * @param callback the function to call when new data are available
 * @param config the configuration for the live collection
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the users
 *
 * @category Category Live Collection
 */
const searchUserByDisplayName = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        // eslint-disable-next-line no-console
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`liveSearchUsers(tmpid: ${timestamp}) > listen`);
    const searchUsersLiveCollection = new SearchUserLiveCollectionController(params, callback);
    const disposers = searchUsersLiveCollection.startSubscription();
    const cacheKey = searchUsersLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`liveSearchUsers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

const queryReachUser = async ({ viewId, viewedType, limit, token, }) => {
    const client = getActiveClient();
    const params = {};
    if (token) {
        // If it's not a first query, we can use token to get next user list from previous query.
        params.token = token;
    }
    else {
        // First query.
        params.limit = limit;
    }
    const view = viewedType === 'post' ? 'posts' : 'stories';
    const url = `/api/v1/analytics/views/${view}/${viewId}/users`;
    const response = await client.http.get(url, {
        params,
    });
    ingestInCache(response.data);
    return response.data;
};

const getReachedUsers = (params, callback) => {
    // Pre-defined function to avoid undefined function call
    let onFetch = (initial = false) => undefined;
    const { log, cache } = getActiveClient();
    const cacheKey = [
        'viewedUsers',
        'collection',
        { viewId: params.viewId, viewedType: params.viewedType },
    ];
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getReachUsers(tmpid: ${timestamp}) > listen`);
    const { limit: queryLimit, viewId, viewedType } = params;
    const responder = (snapshot) => {
        var _a, _b;
        let users = [];
        if (snapshot === null || snapshot === void 0 ? void 0 : snapshot.data) {
            users =
                snapshot.data
                    .map((userId) => pullFromCache(['user', 'get', userId]))
                    .filter(Boolean)
                    .map(data => data === null || data === void 0 ? void 0 : data.data) || [];
        }
        callback({
            onNextPage: onFetch,
            data: users,
            hasNextPage: !!((_b = (_a = snapshot.params) === null || _a === void 0 ? void 0 : _a.page) === null || _b === void 0 ? void 0 : _b.next),
            loading: snapshot.loading || false,
        });
    };
    onFetch = (initial = false) => {
        var _a, _b, _c;
        const collection = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        const users = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
        if (!initial && users.length > 0 && !(collection === null || collection === void 0 ? void 0 : collection.params.page))
            return;
        const query = createQuery(queryReachUser, {
            viewId,
            viewedType,
            limit: queryLimit || 10,
            token: !initial ? (_c = collection === null || collection === void 0 ? void 0 : collection.params.page) === null || _c === void 0 ? void 0 : _c.next : undefined,
        });
        runQuery(query, result => {
            var _a, _b, _c, _d, _e;
            let userIds = (_c = (_b = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : [];
            if ((_d = result.data) === null || _d === void 0 ? void 0 : _d.users) {
                userIds = [
                    ...new Set([...userIds, ...result.data.users.map(({ userId }) => userId)]),
                ];
            }
            const saveToCache = {
                loading: result.loading,
                params: { page: (_e = result.data) === null || _e === void 0 ? void 0 : _e.paging },
                data: userIds || [],
            };
            pushToCache(cacheKey, saveToCache);
            responder(saveToCache);
        }, queryOptions(COLLECTION_DEFAULT_CACHING_POLICY, CACHE_SHORTEN_LIFESPAN));
    };
    onFetch(true);
    return () => {
        log(`getReachUsers(tmpid: ${timestamp}) > dispose`);
        dropFromCache(cacheKey);
    };
};

var AmityUserSearchMatchType;
(function (AmityUserSearchMatchType) {
    AmityUserSearchMatchType["DEFAULT"] = "default";
    AmityUserSearchMatchType["PARTIAL"] = "partial";
})(AmityUserSearchMatchType || (AmityUserSearchMatchType = {}));

var index$k = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Relationship: index$l,
  getUserByIds: getUserByIds,
  updateUser: updateUser,
  flagUser: flagUser,
  unflagUser: unflagUser,
  isUserFlaggedByMe: isUserFlaggedByMe,
  onUserUpdated: onUserUpdated,
  onUserDeleted: onUserDeleted$2,
  onUserFlagged: onUserFlagged,
  onUserUnflagged: onUserUnflagged,
  onUserFlagCleared: onUserFlagCleared,
  getUser: getUser,
  getUsers: getUsers,
  getBlockedUsers: getBlockedUsers,
  searchUserByDisplayName: searchUserByDisplayName,
  getReachedUsers: getReachedUsers,
  get AmityUserSearchMatchType () { return AmityUserSearchMatchType; }
});

/* begin_public_function
  id: file.get
*/
/**
 * ```js
 * import { getFile } from '@amityco/ts-sdk'
 * const file = await getFile('foo')
 * ```
 *
 * Fetches a {@link Amity.File} object
 *
 * @param fileId the ID of the {@link Amity.File} to fetch
 * @returns the associated {@link Amity.File} object
 *
 * @category File API
 * @async
 */
const getFile = async (fileId) => {
    const client = getActiveClient();
    client.log('file/getFile', fileId);
    const { data } = await client.http.get(`/api/v3/files/${fileId}`);
    // API-FIX: backend bad serializer issue. it should be:
    // const { files } = data
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ files: [data] }, { cachedAt });
    return {
        data,
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getFile } from '@amityco/ts-sdk'
 * const file = getFile.locally('foo')
 * ```
 *
 * Fetches a {@link Amity.File} object from cache
 *
 * @param fileId the ID of the {@link Amity.File} to fetch
 * @returns the associated {@link Amity.File} object
 *
 * @category File API
 */
getFile.locally = (fileId) => {
    const client = getActiveClient();
    client.log('file/getFile.locally', fileId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['file', 'get', fileId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/* begin_public_function
  id: file.upload.file
*/
/**
 * ```js
 * import { FileRepository } from '@amityco/ts-sdk'
 * const created = await FileRepository.uploadFile(formData)
 * ```
 *
 * Creates an {@link Amity.File}
 *
 * @param formData The data necessary to create a new {@link Amity.File}
 * @param onProgress The callback to track the upload progress
 * @returns The newly created {@link Amity.File}
 *
 * @category File API
 * @async
 */
const uploadFile = async (formData, onProgress) => {
    const client = getActiveClient();
    client.log('file/uploadFile', formData);
    const files = formData.getAll('files');
    if (!files.length)
        throw new Error('The formData object must have a `files` key.');
    const accessType = GlobalFileAccessType$1.getInstance().getFileAccessType();
    formData.append('accessType', accessType);
    formData.append('preferredFilename', files[0].name);
    const headers = 'getHeaders' in formData
        ? formData.getHeaders()
        : { 'content-type': 'multipart/form-data' };
    const { data } = await client.upload.post('/api/v4/files', formData, {
        headers,
        onUploadProgress({ loaded, total = 100 }) {
            onProgress && onProgress(Math.round((loaded * 100) / total));
        },
    });
    // API-FIX: payload should be serialized properly
    // const { files } = data
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ files: data }, { cachedAt });
    return {
        data,
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: file.delete
*/
/**
 * ```js
 * import { deleteFile } from '@amityco/ts-sdk'
 * const success = await deleteFile('foo')
 * ```
 *
 * Deletes a {@link Amity.File}
 *
 * @param fileId The {@link Amity.File} ID to delete
 * @return A success boolean if the {@link Amity.File} was deleted
 *
 * @category File API
 * @async
 */
const deleteFile = async (fileId) => {
    const client = getActiveClient();
    client.log('file/deleteFile', fileId);
    // API-FIX: payload is different than swagger docs!!
    await client.http.delete(`/api/v3/files/${fileId}`);
    dropFromCache(['file', 'get', fileId], true);
    return { success: true };
};
/* end_public_function */

/**
 * Allow to query a file url with a selected size
 *
 * @param fileUrl the file Url to decorate
 * @param size one of the selected sizes
 * @returns the computed url for the selected size
 */
const fileUrlWithSize = (fileUrl, size) => {
    return `${fileUrl}?size=${size}`;
};

/* begin_public_function
  id: file.upload.video, file.upload.audio
*/
/**
 * ```js
 * import { FileRepository } from '@amityco/ts-sdk'
 * const created = await FileRepository.uploadVideo(formData)
 * ```
 *
 * Creates an {@link Amity.File<'video'>}
 *
 * @param formData The data necessary to create a new {@link Amity.File<'video'>}
 * @param feedType The {@link Amity.File<'video'>} feed type
 * @param onProgress The callback to track the upload progress
 * @returns The newly uploaded {@link Amity.File<'video'>}
 *
 * @category File API
 * @async
 */
const uploadVideo = async (formData, feedType, onProgress) => {
    const client = getActiveClient();
    client.log('file/uploadVideo', formData);
    const files = formData.getAll('files');
    if (!files.length)
        throw new Error('The formData object must have a `files` key.');
    const accessType = GlobalFileAccessType$1.getInstance().getFileAccessType();
    formData.append('accessType', accessType);
    formData.append('preferredFilename', files[0].name);
    if (feedType) {
        formData.append('feedType', feedType);
    }
    const headers = 'getHeaders' in formData
        ? formData.getHeaders()
        : { 'content-type': 'multipart/form-data' };
    const { data } = await client.upload.post('/api/v4/videos', formData, {
        headers,
        onUploadProgress({ loaded, total = 100 }) {
            onProgress && onProgress(Math.round((loaded * 100) / total));
        },
    });
    // API-FIX: payload should be serialized properly
    // const { files } = data
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ files: data }, { cachedAt });
    return {
        data,
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: file.upload.image
*/
/**
 * ```js
 * import { FileRepository } from '@amityco/ts-sdk'
 * const created = await FileRepository.uploadImage(formData)
 * ```
 *
 * Creates an {@link Amity.File<'image'>}
 *
 * @param formData The data necessary to create a new {@link Amity.File<'image'>}
 * @param onProgress The callback to track the upload progress
 * @returns The newly created {@link Amity.File<'image'>}
 *
 * @category File API
 * @async
 */
const uploadImage = async (formData, onProgress) => {
    const client = getActiveClient();
    client.log('file/uploadImage', formData);
    const files = formData.getAll('files');
    if (!files.length)
        throw new Error('The formData object must have a `files` key.');
    const accessType = GlobalFileAccessType$1.getInstance().getFileAccessType();
    formData.append('accessType', accessType);
    formData.append('preferredFilename', files[0].name);
    const headers = 'getHeaders' in formData
        ? formData.getHeaders()
        : { 'content-type': 'multipart/form-data' };
    const { data } = await client.upload.post('/api/v4/images', formData, {
        headers,
        onUploadProgress({ loaded, total = 100 }) {
            onProgress && onProgress(Math.round((loaded * 100) / total));
        },
    });
    // API-FIX: payload should be serialized properly
    // const { files } = data
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ files: data }, { cachedAt });
    return {
        data,
        cachedAt,
    };
};
/* end_public_function */

var index$j = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getFile: getFile,
  uploadFile: uploadFile,
  deleteFile: deleteFile,
  fileUrlWithSize: fileUrlWithSize,
  uploadVideo: uploadVideo,
  uploadImage: uploadImage
});

/**
 * ```js
 * import { queryRoles } from '@amityco/ts-sdk'
 * const roles = await queryRoles()
 * ```
 *
 * Queries a paginable list of {@link Amity.Role} objects
 * Search is performed by displayName such as `.startsWith(search)`
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Role} objects
 *
 * @category Role API
 * @async
 */
const queryRoles = async (query) => {
    const client = getActiveClient();
    client.log('role/queryRoles', query);
    const _a = query !== null && query !== void 0 ? query : {}, { limit = 10, queryToken, displayName, sortBy } = _a, params = __rest(_a, ["limit", "queryToken", "displayName", "sortBy"]);
    const options = (() => {
        if (queryToken)
            return { token: queryToken };
        if (limit)
            return { limit };
        return undefined;
    })();
    // API-FIX: parameters should be querystring.
    const { data } = await client.http.get(`/api/v3/roles`, {
        params: Object.assign(Object.assign({}, params), { keyword: displayName, sortBy,
            options }),
    });
    const { paging } = data, payload = __rest(data, ["paging"]);
    const { roles } = payload;
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(payload, { cachedAt });
    const nextPage = toPage(paging.next);
    const prevPage = toPage(paging.previous);
    return { data: roles, cachedAt, prevPage, nextPage, paging };
};
/**
 * ```js
 * import { queryRoles } from '@amityco/ts-sdk'
 * const roles = queryRoles.locally({ keyword: 'foo' })
 * ```
 *
 * Queries a paginable list of {@link Amity.Role} objects from cache
 * Search is performed by displayName such as `.startsWith(search)`
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Role} objects
 *
 * @category Role API
 */
queryRoles.locally = (query) => {
    const client = getActiveClient();
    client.log('role/queryRoles.locally', query);
    // TODO
};

/**
 * ```js
 * import { getRole } from '@amityco/ts-sdk'
 * const role = await getRole('foobar')
 * ```
 *
 * Fetches a {@link Amity.Role} object
 *
 * @param roleId the ID of the {@link Amity.Role} to fetch
 * @returns the associated {@link Amity.Role} object
 *
 * @category Role API
 * @async
 */
const getRole = async (roleId) => {
    const client = getActiveClient();
    client.log('role/getRole', roleId);
    const { data } = await client.http.get(`/api/v3/roles/${roleId}`);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache({ roles: data }, { cachedAt });
    return {
        data: data.find(role => role.roleId === roleId),
        cachedAt,
    };
};
/**
 * ```js
 * import { getRole } from '@amityco/ts-sdk'
 * const role = getRole.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Role} object from cache
 *
 * @param roleId the ID of the {@link Amity.Role} to fetch
 * @returns the associated {@link Amity.Role} object
 *
 * @category Role API
 */
getRole.locally = (roleId) => {
    const client = getActiveClient();
    client.log('role/getRole.locally', roleId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['role', 'get', roleId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/** @hidden */
const dispatchReactable = (referenceType, model) => {
    if (referenceType === 'message')
        // @ts-ignore: refactor later
        fireEvent('local.message.updated', { messages: [model] });
    else if (referenceType === 'post')
        // @ts-ignore: refactor later
        fireEvent('post.updated', { posts: [model] });
    else if (referenceType === 'comment')
        // @ts-ignore: refactor later
        fireEvent('comment.updated', { comments: [model] });
    else if (referenceType === 'story')
        // Need to provide all data same StoryPayload from BE
        fireEvent('story.updated', {
            categories: [],
            comments: [],
            communities: [],
            communityUsers: [],
            files: [],
            users: [],
            stories: [model],
        });
};

/**
 * ```js
 * import { getMessage } from '@amityco/ts-sdk'
 * const message = await getMessage('foobar')
 * ```
 *
 * Fetches a {@link Amity.InternalMessage} object
 *
 * @param messageId the ID of the {@link Amity.Message} to fetch
 * @returns the associated {@link Amity.Message} object
 *
 * @category Message API
 * @async
 */
const getMessage$1 = async (messageId, isLive = false) => {
    const client = getActiveClient();
    client.log('message/getMessage', messageId);
    isInTombstone('message', messageId);
    let data;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const { data: payload } = await client.http.get(`/api/v5/messages/${encodeURIComponent(messageId)}`);
        data = await prepareMessagePayload(payload);
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('message', messageId);
        }
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { messages } = data;
    fireEvent('local.message.fetched', { messages });
    return {
        data: messages.find(message => message.messageId === messageId),
        cachedAt,
    };
};
/**
 * ```js
 * import { getMessage } from '@amityco/ts-sdk'
 * const message = getMessage.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Message} object
 *
 * @param messageId the ID of the {@link Amity.Message} to fetch
 * @returns the associated {@link Amity.Message} object
 *
 * @category Message API
 */
getMessage$1.locally = (messageId) => {
    const client = getActiveClient();
    client.log('message/getMessage.locally', messageId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['message', 'get', messageId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/**
 * ```js
 * import { getPost } from '@amityco/ts-sdk'
 * const { data: post } = await getPost('foobar')
 * ```
 *
 * Fetches a {@link Amity.Post} object
 *
 * @param postId the ID of the {@link Amity.Post} to fetch
 * @returns the associated {@link Amity.Post} object
 *
 * @category Post API
 * @async
 */
const getPost$2 = async (postId) => {
    const client = getActiveClient();
    client.log('post/getPost', postId);
    isInTombstone('post', postId);
    let payload;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/posts/${encodeURIComponent(postId)}`);
        payload = response.data;
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('post', postId);
        }
        throw error;
    }
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { posts } = data;
    const result = posts.find(post => post.postId === postId);
    return {
        data: LinkedObject.post(result),
        cachedAt,
    };
};
/**
 * ```js
 * import { getPost } from '@amityco/ts-sdk'
 * const { data: post } = getPost.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Post} object from cache
 *
 * @param postId the ID of the {@link Amity.Post} to fetch
 * @returns the associated {@link Amity.Post} object
 *
 * @category Post API
 */
getPost$2.locally = (postId) => {
    const client = getActiveClient();
    client.log('post/getPost.locally', postId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['post', 'get', postId]);
    if (!cached)
        return;
    return {
        data: LinkedObject.post(cached.data),
        cachedAt: cached.cachedAt,
    };
};

/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const comment = await CommentRepository.getComment('foobar')
 * ```
 *
 * Fetches a {@link Amity.Comment} object
 *
 * @param commentId the ID of the {@link Amity.Comment} to fetch
 * @returns the associated {@link Amity.Comment} object
 *
 * @category Comment API
 * @async
 */
const getComment$2 = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/getComment', commentId);
    isInTombstone('comment', commentId);
    let data;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/comments/${encodeURIComponent(commentId)}`);
        data = response.data;
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('comment', commentId);
        }
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { comments } = data;
    return {
        data: LinkedObject.comment(comments.find(comment => comment.commentId === commentId)),
        cachedAt,
    };
};
/**
 * ```js
 * import { getComment } from '@amityco/ts-sdk'
 * const comment = getComment.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Comment} object
 *
 * @param commentId the ID of the {@link Amity.Comment} to fetch
 * @returns the associated {@link Amity.Comment} object
 *
 * @category Comment API
 */
getComment$2.locally = (commentId) => {
    const client = getActiveClient();
    client.log('comment/getComment.locally', commentId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['comment', 'get', commentId]);
    if (!cached)
        return;
    return {
        data: LinkedObject.comment(cached.data),
        cachedAt: cached.cachedAt,
    };
};

/*
 * verifies membership status
 */
function isMember(membership) {
    return membership !== 'none';
}
/*
 * checks if currently logged in user is part of the community
 */
function isCurrentUserPartOfCommunity(c, m) {
    const { userId } = getActiveUser();
    return c.communityId === m.communityId && m.userId === userId;
}
/*
 * For mqtt events server will not send user specific data as it's broadcasted
 * to multiple users and it also does not include communityUser
 *
 * Client SDK needs to check for the existing isJoined field in cache data before calculating.
 * Althought this can be calculated, it's not scalable.
 */
function updateMembershipStatus(communities, communityUsers) {
    return communities.map(c => {
        const cachedCommunity = pullFromCache(['community', 'get', c.communityId]);
        if ((cachedCommunity === null || cachedCommunity === void 0 ? void 0 : cachedCommunity.data) && (cachedCommunity === null || cachedCommunity === void 0 ? void 0 : cachedCommunity.data.hasOwnProperty('isJoined'))) {
            return Object.assign(Object.assign({}, cachedCommunity.data), c);
        }
        const isJoined = communityUsers.some(m => isCurrentUserPartOfCommunity(c, m) && isMember(m.communityMembership));
        return Object.assign(Object.assign({}, c), { isJoined });
    });
}

const getMyReactionsInCache = (payload, eventPrefix) => {
    var _a, _b;
    let id;
    let domain;
    if (eventPrefix === 'post') {
        domain = 'post';
        id = payload.posts[0].postId;
    }
    else if (eventPrefix === 'comment') {
        domain = 'comment';
        id = payload.comments[0].commentId;
    }
    else if (eventPrefix === 'story') {
        domain = 'story';
        id = payload.stories[0].referenceId;
    }
    else {
        throw new Error(`Unknown event type`);
    }
    const cached = (_b = (_a = pullFromCache([domain, 'get', id])) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.myReactions;
    return cached || [];
};
const rebuildPayload = (payload, payloadKey, myReactions) => {
    const [model] = payload[payloadKey];
    return Object.assign(Object.assign({}, payload), { [payloadKey]: [Object.assign(Object.assign({}, model), { myReactions })] });
};
const remappingMyReaction = (event, userId, reactionName, myReactions = []) => {
    const eventSuffix = event.split('.')[1]; // 'addReaction' | 'removeReaction' | 'reactionAdded' | 'reactionRemoved'
    let newMyReactions = myReactions;
    if (getActiveClient().userId === userId) {
        if (['addReaction', 'reactionAdded'].includes(eventSuffix)) {
            if (!newMyReactions.includes(reactionName)) {
                newMyReactions.push(reactionName);
            }
        }
        else if (['removeReaction', 'reactionRemoved'].includes(eventSuffix)) {
            newMyReactions = newMyReactions.filter(reaction => reaction !== reactionName);
        }
        else {
            throw new Error(`Unknown event type: ${eventSuffix}`);
        }
    }
    return newMyReactions;
};
/** @hidden */
const prepareReactionPayloadFromEvent = (event, payload) => {
    const eventPrefix = event.split('.')[0]; // 'post' | 'comment'
    const myReactions = getMyReactionsInCache(payload, eventPrefix);
    const newMyReaction = remappingMyReaction(event, payload.reactor.userId, payload.reactor.reactionName, myReactions);
    return rebuildPayload(payload, `${eventPrefix}s`, newMyReaction);
};
const prepareStoryReactionPayloadFormEvent = (event, payload) => {
    var _a, _b;
    const eventPrefix = event.split('.')[0]; // 'post' | 'comment' | 'story'
    let myReactions = getMyReactionsInCache(payload, eventPrefix);
    if ((payload === null || payload === void 0 ? void 0 : payload.reactions) && payload.reactions.length > 0) {
        myReactions = remappingMyReaction(event, (_a = payload.reactions[0]) === null || _a === void 0 ? void 0 : _a.userId, (_b = payload.reactions[0]) === null || _b === void 0 ? void 0 : _b.reactionName, myReactions);
    }
    // Rebuild the payload with the new myReactions
    const newPayload = rebuildPayload(payload, 'stories', myReactions);
    if (!(payload === null || payload === void 0 ? void 0 : payload.communities) || !(payload === null || payload === void 0 ? void 0 : payload.communityUsers))
        return newPayload;
    const communities = updateMembershipStatus(payload.communities, payload.communityUsers);
    return Object.assign(Object.assign({}, newPayload), { communities });
};
const prepareCommentFromFlaggedEvent = (payload) => {
    const myReactions = getMyReactionsInCache(payload, 'comment');
    return rebuildPayload(payload, 'comments', myReactions);
};

/* begin_public_function
  id: reaction.add
*/
/**
 * ```js
 * import { addReaction } from '@amityco/ts-sdk'
 * const success = await addReaction('post', postId, 'like')
 * ```
 *
 * Creates an {@link Amity.Reaction}
 *
 * @param referenceType The type of thing to add a {@link Amity.Reaction} to, such as a post or a comment.
 * @param referenceId The ID of the thing to add a new {@link Amity.Reaction} to.
 * @param reactionName Reaction name, such as a `like` or `love`.
 * @returns The added result.
 *
 * @category Reaction API
 * @async
 * */
const addReaction = async (referenceType, referenceId, reactionName) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('reaction/createReaction', {
        referenceId,
        referenceType,
        reactionName,
    });
    if (!['post', 'comment', 'story', 'message'].includes(referenceType))
        throw new ASCApiError('The reference type is not valid. It should be one of post, comment, story, or message', 400000 /* Amity.ServerError.BAD_REQUEST */, "error" /* Amity.ErrorLevel.ERROR */);
    const { data } = await client.http.post('/api/v2/reactions', {
        referenceId,
        referenceType,
        reactionName,
        referenceVersion: referenceType === 'message' ? 5 : undefined,
    });
    if (client.cache) {
        const model = pullFromCache([
            referenceType,
            'get',
            referenceId,
        ]);
        if (!model)
            return true;
        const updatedModel = Object.assign(Object.assign({}, model.data), { reactionsCount: model.data.reactionsCount + 1, myReactions: [...((_a = model.data.myReactions) !== null && _a !== void 0 ? _a : []), reactionName], reactions: Object.assign(Object.assign({}, model.data.reactions), { [reactionName]: ((_b = model.data.reactions[reactionName]) !== null && _b !== void 0 ? _b : 0) + 1 }) });
        if (referenceType === 'comment') {
            fireEvent('local.comment.addReaction', {
                comment: updatedModel,
                reactor: {
                    userId: client.userId,
                    reactionName,
                    reactionId: data.addedId,
                },
            });
            return true;
        }
        if (referenceType === 'post') {
            fireEvent('local.post.addReaction', {
                post: updatedModel,
                reactor: {
                    userId: client.userId,
                    reactionName,
                    reactionId: data.addedId,
                },
            });
            return true;
        }
        if (referenceType === 'story') {
            fireEvent('local.story.reactionAdded', {
                story: updatedModel,
                reactor: {
                    userId: client.userId,
                    reactionName,
                    reactionId: data.addedId,
                },
            });
            return true;
        }
    }
    return true;
};
/* end_public_function */
/**
 * ```js
 * import { addReaction } from '@amityco/ts-sdk'
 * const success = addReaction.optimistically('post', postId, 'like')
 * ```
 *
 * Creates an {@link Amity.Reaction} optimistically
 *
 * @param referenceType The type of thing to add a {@link Amity.Reaction} to, such as a post or a comment.
 * @param referenceId The ID of the thing to add a new {@link Amity.Reaction} to.
 * @param reactionName Reaction name, such as a `like` or `love`.
 * @returns The added result.
 *
 * @category Reaction API
 * */
addReaction.optimistically = (referenceType, referenceId, reactionName) => {
    var _a, _b, _c, _d, _e;
    const client = getActiveClient();
    client.log('reaction/createReaction.optimistically', {
        referenceId,
        referenceType,
        reactionName,
    });
    if (!client.cache)
        return;
    const model = pullFromCache([
        referenceType,
        'get',
        referenceId,
    ]);
    if (!(model === null || model === void 0 ? void 0 : model.data) || ((_a = model.data.myReactions) === null || _a === void 0 ? void 0 : _a.includes(reactionName)))
        return;
    const reaction = Object.assign(Object.assign({}, model.data), { reactionsCount: model.data.reactionsCount + 1, myReactions: [...((_b = model.data.myReactions) !== null && _b !== void 0 ? _b : []), reactionName], reactions: Object.assign(Object.assign({}, model.data.reactions), { [reactionName]: ((_c = model.data.reactions[reactionName]) !== null && _c !== void 0 ? _c : 0) + 1 }) });
    upsertInCache([referenceType, 'get', referenceId], reaction, {
        cachedAt: UNSYNCED_OBJECT_CACHED_AT_VALUE,
    });
    dispatchReactable(referenceType, reaction);
    return (_e = (_d = reaction === null || reaction === void 0 ? void 0 : reaction.myReactions) === null || _d === void 0 ? void 0 : _d.includes(reactionName)) !== null && _e !== void 0 ? _e : false;
};

/* begin_public_function
  id: reaction.remove
*/
/**
 * ```js
 * import { deleteReaction } from '@amityco/ts-sdk'
 * const success = await deleteReaction('post', 'foobar', 'like')
 * ```
 *
 * Removes a {@link Amity.Reaction} from a {@link Amity.Reactable} object
 *
 * @param referenceType The type of thing to add a {@link Amity.Reaction} to, such as a post or a comment.
 * @param referenceId The ID of the thing to add a new {@link Amity.Reaction} to.
 * @param reactionName Reaction name, such as a `like` or `love`.
 * @returns The removed result.
 *
 * @category Reaction API
 * @async
 * */
const removeReaction = async (referenceType, referenceId, reactionName) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('reaction/removeReaction', {
        referenceId,
        referenceType,
        reactionName,
    });
    if (!['post', 'comment', 'story', 'message'].includes(referenceType))
        throw new ASCApiError('The reference type is not valid. It should be one of post, comment, story, or message', 400000 /* Amity.ServerError.BAD_REQUEST */, "error" /* Amity.ErrorLevel.ERROR */);
    const { data } = await client.http.delete(`/api/v2/reactions`, {
        data: {
            referenceId,
            referenceType,
            reactionName,
            referenceVersion: referenceType === 'message' ? 5 : undefined,
        },
    });
    if (client.cache) {
        const model = pullFromCache([
            referenceType,
            'get',
            referenceId,
        ]);
        if (!model)
            return true;
        const updatedModel = Object.assign(Object.assign({}, model.data), { reactionsCount: Math.max(0, model.data.reactionsCount - 1), myReactions: ((_a = model.data.myReactions) !== null && _a !== void 0 ? _a : []).filter(item => item !== reactionName), reactions: Object.assign(Object.assign({}, model.data.reactions), { [reactionName]: Math.max(0, ((_b = model.data.reactions[reactionName]) !== null && _b !== void 0 ? _b : 0) - 1) }) });
        if (referenceType === 'comment') {
            fireEvent('local.comment.removeReaction', {
                comment: updatedModel,
                reactor: {
                    reactionId: data.removedId,
                    reactionName,
                    userId: client.userId,
                },
            });
            return true;
        }
        if (referenceType === 'post') {
            fireEvent('local.post.removeReaction', {
                post: updatedModel,
                reactor: {
                    reactionId: data.removedId,
                    reactionName,
                    userId: client.userId,
                },
            });
            return true;
        }
        if (referenceType === 'story') {
            fireEvent('local.story.reactionAdded', {
                story: updatedModel,
                reactor: {
                    userId: client.userId,
                    reactionName,
                    reactionId: data.removedId,
                },
            });
            return true;
        }
    }
    return true;
};
/* end_public_function */
/**
 * ```js
 * import { removeReaction } from '@amityco/ts-sdk'
 * const success = removeReaction.optimistically('post', postId, 'like')
 * ```
 *
 * Removes a {@link Amity.Reaction} from a {@link Amity.Reactable} object optimistically
 *
 * @param referenceType The type of thing to add a {@link Amity.Reaction} to, such as a post or a comment.
 * @param referenceId The ID of the thing to add a new {@link Amity.Reaction} to.
 * @param reactionName Reaction name, such as a `like` or `love`.
 * @returns The added result.
 *
 * @category Reaction API
 * */
removeReaction.optimistically = (referenceType, referenceId, reactionName) => {
    var _a, _b, _c, _d;
    const client = getActiveClient();
    client.log('reaction/removeReaction.optimistically', {
        referenceId,
        referenceType,
        reactionName,
    });
    if (!client.cache)
        return;
    const model = pullFromCache([
        referenceType,
        'get',
        referenceId,
    ]);
    if (!(model === null || model === void 0 ? void 0 : model.data) || !((_a = model.data.myReactions) === null || _a === void 0 ? void 0 : _a.includes(reactionName)))
        return;
    const reaction = Object.assign(Object.assign({}, model.data), { reactionsCount: Math.max(0, model.data.reactionsCount - 1), myReactions: ((_b = model.data.myReactions) !== null && _b !== void 0 ? _b : []).filter(item => item !== reactionName), reactions: Object.assign(Object.assign({}, model.data.reactions), { [reactionName]: Math.max(0, ((_c = model.data.reactions[reactionName]) !== null && _c !== void 0 ? _c : 0) - 1) }) });
    upsertInCache([referenceType, 'get', referenceId], reaction, {
        cachedAt: UNSYNCED_OBJECT_CACHED_AT_VALUE,
    });
    dispatchReactable(referenceType, reaction);
    return !((_d = reaction === null || reaction === void 0 ? void 0 : reaction.myReactions) === null || _d === void 0 ? void 0 : _d.includes(reactionName));
};

const getMatchPostSetting = (value) => {
    var _a;
    return (_a = Object.keys(CommunityPostSettingMaps).find(key => value.needApprovalOnPostCreation ===
        CommunityPostSettingMaps[key].needApprovalOnPostCreation &&
        value.onlyAdminCanPost === CommunityPostSettingMaps[key].onlyAdminCanPost)) !== null && _a !== void 0 ? _a : DefaultCommunityPostSetting;
};
function addPostSetting({ communities }) {
    return communities.map((_a) => {
        var { needApprovalOnPostCreation, onlyAdminCanPost } = _a, restCommunityPayload = __rest(_a, ["needApprovalOnPostCreation", "onlyAdminCanPost"]);
        return (Object.assign({ postSetting: getMatchPostSetting({
                needApprovalOnPostCreation,
                onlyAdminCanPost,
            }) }, restCommunityPayload));
    });
}
const prepareCommunityPayload = (rawPayload) => {
    const communitiesWithPostSetting = addPostSetting({ communities: rawPayload.communities });
    // map users with community
    const mappedCommunityUsers = rawPayload.communityUsers.map(communityUser => {
        const user = rawPayload.users.find(user => user.userId === communityUser.userId);
        return Object.assign(Object.assign({}, communityUser), { user });
    });
    const communityWithMembershipStatus = updateMembershipStatus(communitiesWithPostSetting, mappedCommunityUsers);
    return Object.assign(Object.assign({}, rawPayload), { communities: communityWithMembershipStatus, communityUsers: mappedCommunityUsers });
};
const prepareCommunityMembershipPayload = (rawPayload) => {
    const communitiesWithPostSetting = addPostSetting({ communities: rawPayload.communities });
    // map users with community
    const mappedCommunityUsers = rawPayload.communityUsers.map(communityUser => {
        const user = rawPayload.users.find(user => user.userId === communityUser.userId);
        return Object.assign(Object.assign({}, communityUser), { user });
    });
    const communityWithMembershipStatus = updateMembershipStatus(communitiesWithPostSetting, mappedCommunityUsers);
    return Object.assign(Object.assign({}, rawPayload), { communities: communityWithMembershipStatus, communityUsers: mappedCommunityUsers });
};
const prepareCommunityRequest = (params) => {
    const { postSetting = undefined, storySetting } = params, restParam = __rest(params, ["postSetting", "storySetting"]);
    return Object.assign(Object.assign(Object.assign({}, restParam), (postSetting ? CommunityPostSettingMaps[postSetting] : undefined)), { 
        // Convert story setting to the actual value. (Allow by default)
        allowCommentInStory: typeof (storySetting === null || storySetting === void 0 ? void 0 : storySetting.enableComment) === 'boolean' ? storySetting.enableComment : true });
};
const prepareSemanticSearchCommunityPayload = (_a) => {
    var communityPayload = __rest(_a, ["searchResult"]);
    const processedCommunityPayload = prepareCommunityPayload(communityPayload);
    return Object.assign({}, processedCommunityPayload);
};

const preparePostPayload = (payload) => {
    const { posts: postsData } = payload, postPayload = __rest(payload, ["posts"]);
    // Unpack community payload by mapping payload field to postSetting value.
    const communitiesWithPostSetting = addPostSetting({ communities: postPayload.communities });
    // map users with community
    const mappedCommunityUsers = postPayload.communityUsers.map(communityUser => {
        const user = postPayload.users.find(user => user.userId === communityUser.userId);
        return Object.assign(Object.assign({}, communityUser), { user });
    });
    const communityWithMembershipStatus = updateMembershipStatus(communitiesWithPostSetting, mappedCommunityUsers);
    // feed type
    const posts = postsData.map(post => {
        var _a;
        const feedType = (_a = postPayload.feeds.find(feed => feed.feedId === post.feedId)) === null || _a === void 0 ? void 0 : _a.feedType;
        return Object.assign(Object.assign({}, post), { feedType });
    });
    return Object.assign(Object.assign({}, postPayload), { posts, communities: communityWithMembershipStatus, communityUsers: mappedCommunityUsers });
};
const prepareSemanticSearchPostPayload = (_a) => {
    var { searchResult, polls } = _a, postPayload = __rest(_a, ["searchResult", "polls"]);
    const processedPostPayload = preparePostPayload(postPayload);
    return Object.assign(Object.assign({}, processedPostPayload), { polls });
};

const createPostEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a;
        if (!client.cache) {
            callback(payload.posts[0]);
        }
        else {
            const data = preparePostPayload(payload);
            const { communities } = data;
            // NOTE: The event data should be merge with existing cache rather than replace it
            ingestInCache(data, undefined, false);
            if ((communities === null || communities === void 0 ? void 0 : communities[0]) && !['post.updated'].includes(event)) {
                fireEvent('community.updated', {
                    communities,
                    categories: [],
                    communityUsers: data.communityUsers,
                    feeds: [],
                    files: [],
                    users: [],
                });
            }
            if (event === 'post.deleted') {
                const { postId, postedUserId } = payload.posts[0];
                try {
                    isInTombstone('post', postId);
                }
                catch (e) {
                    // Already in tombstone, skip to update client
                    return;
                }
                // If this post NOT BELONG to current user, let **put it to tombstone in all cases**
                // For the case incoming post belong to current user, If from **different device will treat it as SOFT DELETE**
                // But for same device if it is soft delete it just need to handle as update cache
                // But if it is hard delete, it will pushed into tombstone before fire an event to BE. it means it will stay in tombstone already
                // and will got skip to notify in a previous code block
                if (postedUserId !== client.userId) {
                    dropFromCache(['post', 'get', postId]);
                }
                return callback(payload.posts[0]);
            }
            const post = pullFromCache(['post', 'get', payload.posts[0].postId]);
            if (['post.created', 'post.approved', 'post.declined'].includes(event)) {
                let queries = (_a = queryCache(['post', 'query'])) === null || _a === void 0 ? void 0 : _a.filter(({ key }) => { var _a; return ((_a = key[2]) === null || _a === void 0 ? void 0 : _a.targetId) === post.data.targetId; });
                if (event === 'post.declined') {
                    // @ts-ignore
                    queries = queries === null || queries === void 0 ? void 0 : queries.filter(({ key }) => { var _a; return ((_a = key[2]) === null || _a === void 0 ? void 0 : _a.feedType) === 'reviewing'; });
                }
                queries === null || queries === void 0 ? void 0 : queries.map(({ key, data }) => upsertInCache(key, data, { cachedAt: -1 }));
            }
            callback(post.data);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};
const createLocalPostEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (!client.cache) {
            callback(payload.posts[0]);
        }
        else {
            const data = preparePostPayload(payload);
            const { communities } = data;
            ingestInCache(data);
            if ((communities === null || communities === void 0 ? void 0 : communities[0]) && !['local.post.updated'].includes(event)) {
                fireEvent('community.updated', {
                    communities,
                    categories: [],
                    communityUsers: data.communityUsers,
                    feeds: [],
                    files: [],
                    users: [],
                });
            }
            const post = pullFromCache(['post', 'get', payload.posts[0].postId]);
            callback(post.data);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onPostCreated } from '@amityco/ts-sdk'
 * const dispose = onPostCreated(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostCreated = (callback) => createPostEventSubscriber('post.created', callback);

/**
 * ```js
 * import { onPostUpdated } from '@amityco/ts-sdk'
 * const dispose = onPostUpdated(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostUpdated = (callback) => createPostEventSubscriber('post.updated', callback);

/**
 * ```js
 * import { onPostDeleted } from '@amityco/ts-sdk'
 * const dispose = onPostDeleted(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostDeleted = (callback) => createPostEventSubscriber('post.deleted', callback);

/**
 * ```js
 * import { onPostApproved } from '@amityco/ts-sdk'
 * const dispose = onPostApproved(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostApproved = (callback) => createPostEventSubscriber('post.approved', callback);

/**
 * ```js
 * import { onPostDeclined } from '@amityco/ts-sdk'
 * const dispose = onPostDeclined(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostDeclined = (callback) => createPostEventSubscriber('post.declined', callback);

/**
 * ```js
 * import { onPostFlagged } from '@amityco/ts-sdk'
 * const dispose = onPostFlagged(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been flagged
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostFlagged = (callback) => createPostEventSubscriber('post.flagged', callback);

/**
 * ```js
 * import { onPostUnflagged } from '@amityco/ts-sdk'
 * const dispose = onPostUnflagged(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a flag has been removed from a {@link Amity.InternalPost}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostUnflagged = (callback) => createPostEventSubscriber('post.unflagged', callback);

/**
 * ```js
 * import { onPostReactionAdded } from '@amityco/ts-sdk'
 * const dispose = onPostReactionAdded(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (!client.cache) {
            callback(payload.posts[0]);
        }
        else {
            const processed = prepareReactionPayloadFromEvent('post.addReaction', payload);
            const postPayload = __rest(processed, ["reactor"]);
            ingestInCache(postPayload);
            const post = pullFromCache(['post', 'get', payload.posts[0].postId]);
            callback(post.data);
        }
    };
    return createEventSubscriber(client, 'post.addReaction', 'post.addReaction', filter);
};

/**
 * ```js
 * import { onPostReactionRemoved } from '@amityco/ts-sdk'
 * const dispose = onPostReactionRemoved(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a reaction has been removed from a {@link Amity.InternalPost}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (!client.cache) {
            callback(payload.posts[0]);
        }
        else {
            const processed = prepareReactionPayloadFromEvent('post.removeReaction', payload);
            const postPayload = __rest(processed, ["reactor"]);
            ingestInCache(postPayload);
            const post = pullFromCache(['post', 'get', payload.posts[0].postId]);
            callback(post.data);
        }
    };
    return createEventSubscriber(client, 'post.removeReaction', 'post.removeReaction', filter);
};

const createCommentEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a;
        if (!client.cache) {
            // TODO: here we are missing specific properties here!
            callback(LinkedObject.comment(payload.comments[0]));
        }
        else {
            const processed = ['comment.flagged', 'comment.unflagged'].includes(event)
                ? prepareCommentFromFlaggedEvent(payload)
                : payload;
            // NOTE: The event data should be merge with existing cache rather than replace it
            ingestInCache(processed, undefined, false);
            const { comments } = processed;
            if (comments.length > 0) {
                const comment = pullFromCache([
                    'comment',
                    'get',
                    comments[0].commentId,
                ]);
                if (['comment.created'].includes(event)) {
                    // NOTE: skip adding comment to parent comment children if it's the same user since we use the local event to update instead.
                    if (event === 'comment.created' && comment.data.userId === client.userId)
                        return;
                    if (comments[0].parentId) {
                        const parentComment = pullFromCache([
                            'comment',
                            'get',
                            comments[0].parentId,
                        ]);
                        if (parentComment === null || parentComment === void 0 ? void 0 : parentComment.data) {
                            // Skip to update parent childComment if current comment already exists
                            if (!parentComment.data.children.includes(comments[0].commentId)) {
                                pushToCache(['comment', 'get', comments[0].parentId], Object.assign(Object.assign({}, parentComment.data), { childrenNumber: parentComment.data.childrenNumber + 1, children: [...new Set([...parentComment.data.children, comments[0].commentId])] }));
                            }
                        }
                    }
                }
                if (['comment.deleted'].includes(event)) {
                    // NOTE: skip deleting comment to parent comment children if it's the same user since we use the local event to update instead.
                    if (event === 'comment.deleted' && comment.data.userId === client.userId)
                        return;
                    if (comments[0].parentId) {
                        const parentComment = pullFromCache([
                            'comment',
                            'get',
                            comments[0].parentId,
                        ]);
                        if (parentComment === null || parentComment === void 0 ? void 0 : parentComment.data) {
                            // Remove deleted comment in parent childComment if still exists
                            if (parentComment.data.children.includes(comments[0].commentId)) {
                                const newParentComment = Object.assign(Object.assign({}, parentComment.data), { childrenNumber: parentComment.data.childrenNumber - 1, children: [
                                        ...new Set([
                                            ...parentComment.data.children.filter(id => id !== comments[0].commentId),
                                        ]),
                                    ] });
                                pushToCache(['comment', 'get', comments[0].parentId], newParentComment);
                            }
                        }
                    }
                    const queries = (_a = queryCache(['comment', 'query'])) === null || _a === void 0 ? void 0 : _a.filter(({ key }) => { var _a; return ((_a = key[2]) === null || _a === void 0 ? void 0 : _a.referenceId) === comment.data.referenceId; });
                    queries === null || queries === void 0 ? void 0 : queries.map(({ key, data }) => upsertInCache(key, data, { cachedAt: -1 }));
                }
                callback(LinkedObject.comment(comment.data));
            }
        }
    };
    return createEventSubscriber(client, event, event, filter);
};
const createLocalCommentEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a, _b;
        if (!client.cache) {
            // TODO: here we are missing specific properties here!
            callback(LinkedObject.comment(payload.comments[0]));
        }
        else {
            const processed = payload;
            ingestInCache(processed);
            const { comments } = processed;
            if (comments.length > 0) {
                const comment = pullFromCache([
                    'comment',
                    'get',
                    comments[0].commentId,
                ]);
                if (['local.comment.created'].includes(event)) {
                    if (comments[0].parentId) {
                        const parentComment = pullFromCache([
                            'comment',
                            'get',
                            comments[0].parentId,
                        ]);
                        if (parentComment === null || parentComment === void 0 ? void 0 : parentComment.data) {
                            // Skip to update parent childComment if current comment already exists
                            if (!parentComment.data.children.includes(comments[0].commentId)) {
                                const newParentComment = Object.assign(Object.assign({}, parentComment.data), { childrenNumber: parentComment.data.childrenNumber + 1, children: [...new Set([...parentComment.data.children, comments[0].commentId])] });
                                pushToCache(['comment', 'get', comments[0].parentId], newParentComment);
                                setTimeout(() => {
                                    // NOTE: This is workaround solution for emitting event not work properly.
                                    fireEvent('comment.updated', {
                                        comments: [newParentComment],
                                        commentChildren: [],
                                        files: [],
                                        users: [],
                                        communityUsers: [],
                                    });
                                }, 200);
                            }
                        }
                    }
                    const queries = (_a = queryCache(['comment', 'query'])) === null || _a === void 0 ? void 0 : _a.filter(({ key }) => { var _a; return ((_a = key[2]) === null || _a === void 0 ? void 0 : _a.referenceId) === comment.data.referenceId; });
                    queries === null || queries === void 0 ? void 0 : queries.map(({ key, data }) => upsertInCache(key, data, { cachedAt: -1 }));
                }
                if (['local.comment.deleted'].includes(event)) {
                    if (comments[0].parentId) {
                        const parentComment = pullFromCache([
                            'comment',
                            'get',
                            comments[0].parentId,
                        ]);
                        if (parentComment === null || parentComment === void 0 ? void 0 : parentComment.data) {
                            // Remove deleted comment in parent childComment if still exists
                            if (parentComment.data.children.includes(comments[0].commentId)) {
                                const newParentComment = Object.assign(Object.assign({}, parentComment.data), { childrenNumber: parentComment.data.childrenNumber - 1, children: [
                                        ...new Set([
                                            ...parentComment.data.children.filter(id => id !== comments[0].commentId),
                                        ]),
                                    ] });
                                pushToCache(['comment', 'get', comments[0].parentId], newParentComment);
                                setTimeout(() => {
                                    // NOTE: This is workaround solution for emitting event not work properly.
                                    fireEvent('comment.updated', {
                                        comments: [newParentComment],
                                        commentChildren: [],
                                        files: [],
                                        users: [],
                                        communityUsers: [],
                                    });
                                }, 200);
                            }
                        }
                    }
                    const queries = (_b = queryCache(['comment', 'query'])) === null || _b === void 0 ? void 0 : _b.filter(({ key }) => { var _a; return ((_a = key[2]) === null || _a === void 0 ? void 0 : _a.referenceId) === comment.data.referenceId; });
                    queries === null || queries === void 0 ? void 0 : queries.map(({ key, data }) => upsertInCache(key, data, { cachedAt: -1 }));
                }
                callback(LinkedObject.comment(comment.data));
            }
        }
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onCommentCreated } from '@amityco/ts-sdk'
 * const dispose = onCommentCreated(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentCreated = (callback) => createCommentEventSubscriber('comment.created', callback);

/**
 * ```js
 * import { onCommentUpdated } from '@amityco/ts-sdk'
 * const dispose = onCommentUpdated(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentUpdated = (callback) => createCommentEventSubscriber('comment.updated', callback);

/**
 * ```js
 * import { onCommentDeleted } from '@amityco/ts-sdk'
 * const dispose = onCommentDeleted(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentDeleted = (callback) => createCommentEventSubscriber('comment.deleted', callback);

/**
 * ```js
 * import { onCommentFlagged } from '@amityco/ts-sdk'
 * const dispose = onCommentFlagged(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been flagged
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentFlagged = (callback) => createCommentEventSubscriber('comment.flagged', callback);

/**
 * ```js
 * import { onCommentUnflagged } from '@amityco/ts-sdk'
 * const dispose = onCommentUnflagged(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a flag has been removed from a {@link Amity.InternalComment}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentUnflagged = (callback) => createCommentEventSubscriber('comment.unflagged', callback);

/**
 * ```js
 * import { onCommentReactionAdded } from '@amityco/ts-sdk'
 * const dispose = onCommentReactionAdded(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (!client.cache) {
            callback(LinkedObject.comment(payload.comments[0]));
        }
        else {
            const processed = prepareReactionPayloadFromEvent('comment.addReaction', payload);
            const commentPayload = __rest(processed, ["reactor"]);
            ingestInCache(commentPayload);
            const comment = pullFromCache([
                'comment',
                'get',
                payload.comments[0].commentId,
            ]);
            callback(LinkedObject.comment(comment.data));
        }
    };
    return createEventSubscriber(client, 'comment.addReaction', 'comment.addReaction', filter);
};

/**
 * ```js
 * import { onCommentReactionRemoved } from '@amityco/ts-sdk'
 * const dispose = onCommentReactionRemoved(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a reaction has been removed from a {@link Amity.InternalComment}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (!client.cache) {
            callback(LinkedObject.comment(payload.comments[0]));
        }
        else {
            const processed = prepareReactionPayloadFromEvent('comment.removeReaction', payload);
            const commentPayload = __rest(processed, ["reactor"]);
            ingestInCache(commentPayload);
            const comment = pullFromCache([
                'comment',
                'get',
                payload.comments[0].commentId,
            ]);
            callback(LinkedObject.comment(comment.data));
        }
    };
    return createEventSubscriber(client, 'comment.removeReaction', 'comment.removeReaction', filter);
};

/**
 * ```js
 * import { onReactionAdded } from '@amityco/ts-sdk'
 * const dispose = onReactionAdded('post', postId, post => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Reaction} has been added
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 * */
const onReactionAdded = (referenceType, referenceId, callback) => {
    const callbackWrapper = (model) => {
        if (getResolver(referenceType)(model) === referenceId) {
            callback(model);
        }
    };
    /*
     * Important: Want to point out that reference type will never be 'message'
     * for onReactionAdded
     */
    if (referenceType === 'message') {
        const client = getActiveClient();
        const filter = async (rawPayload) => {
            var _a;
            const payload = await prepareMessagePayload(rawPayload);
            const cached = pullFromCache([
                'message',
                'get',
                payload.messages[0].messageId,
            ]);
            const isReactionEvent = ((_a = cached === null || cached === void 0 ? void 0 : cached.data) === null || _a === void 0 ? void 0 : _a.reactionsCount) !== payload.messages[0].reactionsCount;
            ingestInCache(payload);
            if (isReactionEvent) {
                callbackWrapper(payload.messages[0]);
            }
        };
        return createEventSubscriber(client, 'reaction/onReactionAdded', 'message.updated', filter);
    }
    if (referenceType === 'post') {
        return onPostReactionAdded(callbackWrapper);
    }
    return onCommentReactionAdded(callbackWrapper);
};

/**
 * ```js
 * import { onReactionRemoved } from '@amityco/ts-sdk'
 * const dispose = onReactionRemoved('post', postId, post => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Reaction} has been removed
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 * */
const onReactionRemoved = (referenceType, referenceId, callback) => {
    const callbackWrapper = (model) => {
        if (getResolver(referenceType)(model) === referenceId) {
            callback(model);
        }
    };
    if (referenceType === 'message') {
        const client = getActiveClient();
        const filter = async (rawPayload) => {
            var _a;
            const payload = await prepareMessagePayload(rawPayload);
            const cached = pullFromCache([
                'message',
                'get',
                payload.messages[0].messageId,
            ]);
            const isReactionEvent = ((_a = cached === null || cached === void 0 ? void 0 : cached.data) === null || _a === void 0 ? void 0 : _a.reactionsCount) !== payload.messages[0].reactionsCount;
            ingestInCache(payload);
            if (isReactionEvent) {
                callbackWrapper(payload.messages[0]);
            }
        };
        return createEventSubscriber(client, 'reaction/onReactionRemoved', 'message.updated', filter);
    }
    if (referenceType === 'post') {
        return onPostReactionRemoved(callbackWrapper);
    }
    return onCommentReactionRemoved(callbackWrapper);
};

/**
 * ```js
 * import { onReactorAdded } from '@amityco/ts-sdk'
 * const dispose = onReactorAdded('post', postId, reactor => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.InternalReactor} has been added
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Events
 * */
const onReactorAdded = (referenceType, referenceId, callback) => {
    const client = getActiveClient();
    const callbackWrapper = (referenceType_, referenceId_, reaction) => {
        if (referenceType_ === referenceType && referenceId_ === referenceId) {
            callback(reaction);
        }
    };
    if (referenceType === 'message') {
        const filter = async (rawPayload) => {
            const payload = await prepareMessagePayload(rawPayload);
            if (!payload.reactions[0])
                return;
            ingestInCache(payload);
            ingestInCache({ reactors: payload.reactions });
            callbackWrapper('message', payload.messages[0].messageId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'reaction/onReactorAdded', 'message.reactionAdded', filter);
    }
    if (referenceType === 'post') {
        const filter = (payload) => {
            const { reactor } = payload, rest = __rest(payload, ["reactor"]);
            ingestInCache(rest);
            ingestInCache({ reactions: [reactor] });
            callbackWrapper('post', payload.posts[0].postId, reactor);
        };
        return createEventSubscriber(client, 'post.addReaction', 'post.addReaction', filter);
    }
    if (referenceType === 'story') {
        const filter = (payload) => {
            const { reactions } = payload, rest = __rest(payload, ["reactions"]);
            ingestInCache(rest);
            ingestInCache({ reactors: reactions });
            if (payload.stories.length === 0 || payload.reactions.length === 0)
                return;
            callbackWrapper('story', payload.stories[0].storyId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'story.reactionAdded', 'story.reactionAdded', filter);
    }
    const filter = (payload) => {
        const { reactor } = payload, rest = __rest(payload, ["reactor"]);
        ingestInCache(rest);
        ingestInCache({ reactions: [reactor] });
        callbackWrapper('comment', payload.comments[0].commentId, reactor);
    };
    return createEventSubscriber(client, 'comment.addReaction', 'comment.addReaction', filter);
};

/**
 * ```js
 * import { onReactorRemoved } from '@amityco/ts-sdk'
 * const dispose = onReactorRemoved('post', postId, reactor => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.InternalReactor} has been removed
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Events
 * */
const onReactorRemoved = (referenceType, referenceId, callback) => {
    const client = getActiveClient();
    const callbackWrapper = (referenceType_, referenceId_, reaction) => {
        if (referenceType_ === referenceType && referenceId_ === referenceId) {
            callback(reaction);
        }
    };
    if (referenceType === 'message') {
        const filter = async (rawPayload) => {
            const payload = await prepareMessagePayload(rawPayload);
            if (!payload.reactions[0])
                return;
            ingestInCache(payload);
            callbackWrapper('message', payload.messages[0].messageId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'reaction/onReactorRemoved', 'message.reactionRemoved', filter);
    }
    if (referenceType === 'post') {
        const filter = (payload) => {
            const { reactor } = payload, rest = __rest(payload, ["reactor"]);
            ingestInCache(rest);
            // FIXME: correct reactions type in model
            // @ts-ignore
            ingestInCache({ reactions: [reactor] });
            callbackWrapper('post', payload.posts[0].postId, reactor);
        };
        return createEventSubscriber(client, 'post.removeReaction', 'post.removeReaction', filter);
    }
    if (referenceType === 'story') {
        const filter = (payload) => {
            const { reactions } = payload, rest = __rest(payload, ["reactions"]);
            ingestInCache(rest);
            ingestInCache({ reactors: reactions });
            if (payload.stories.length === 0 || payload.reactions.length === 0)
                return;
            callbackWrapper('story', payload.stories[0].storyId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'story.reactionRemoved', 'story.reactionRemoved', filter);
    }
    const filter = (payload) => {
        const { reactor } = payload, rest = __rest(payload, ["reactor"]);
        ingestInCache(rest);
        // FIXME: correct reactions type in model
        // @ts-ignore
        ingestInCache({ reactions: [reactor] });
        callbackWrapper('comment', payload.comments[0].commentId, reactor);
    };
    return createEventSubscriber(client, 'comment.removeReaction', 'comment.removeReaction', filter);
};

const REFERENCE_API_V5 = 5;

class ReactionPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const client = getActiveClient();
        client.log('reaction/queryReactions', queryParams);
        const path = '/api/v3/reactions';
        if (!['post', 'comment', 'story', 'message'].includes(params.referenceType))
            throw new ASCApiError('The reference type is not valid. It should be one of post, comment, story, or message', 400000 /* Amity.ServerError.BAD_REQUEST */, "error" /* Amity.ErrorLevel.ERROR */);
        const { data: queryResponse } = await this.http.get(path, {
            params: Object.assign(Object.assign({}, params), { referenceVersion: REFERENCE_API_V5, // Need to put this param to make it can query reaction for message in sub-channel
                options }),
        });
        return queryResponse;
    }
}

class ReactionQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        var _a;
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            const { reactions } = processedPayload, restPayload = __rest(processedPayload, ["reactions"]);
            ingestInCache(Object.assign(Object.assign({}, restPayload), { reactions, reactors: (_a = reactions[0]) === null || _a === void 0 ? void 0 : _a.reactors }), { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b, _c, _d;
        const reactors = (_b = (_a = response.reactions[0]) === null || _a === void 0 ? void 0 : _a.reactors) !== null && _b !== void 0 ? _b : [];
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: reactors.map(getResolver('reactor')),
            });
        }
        else {
            const collection = (_c = pullFromCache(this.cacheKey)) === null || _c === void 0 ? void 0 : _c.data;
            const reactions = (_d = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _d !== void 0 ? _d : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...reactions, ...reactors.map(getResolver('reactor'))])] }));
        }
    }
    reactor(action) {
        return (reaction) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (action === "onAdded" /* Amity.ReactionActionTypeEnum.OnAdded */) {
                collection.data = [...new Set([reaction.reactionId, ...collection.data])];
            }
            else if (action === "onRemoved" /* Amity.ReactionActionTypeEnum.OnRemoved */) {
                collection.data = collection.data.filter(p => p !== reaction.reactionId);
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

/**
 * ```js
 * import { onReactorRemovedLocal } from '@amityco/ts-sdk'
 * const dispose = onReactorRemoved('post', postId, reactor => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.InternalReactor} has been removed
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Events
 * */
const onReactorRemovedLocal = (referenceType, referenceId, callback) => {
    const client = getActiveClient();
    const callbackWrapper = (referenceType_, referenceId_, reaction) => {
        if (referenceType_ === referenceType && referenceId_ === referenceId) {
            callback(reaction);
        }
    };
    if (referenceType === 'message') {
        const filter = async (rawPayload) => {
            const payload = await prepareMessagePayload(rawPayload);
            if (!payload.reactions[0])
                return;
            ingestInCache(payload);
            callbackWrapper('message', payload.messages[0].messageId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'reaction/onReactorRemoved', 'message.reactionRemoved', filter);
    }
    if (referenceType === 'post') {
        const filter = (payload) => {
            callbackWrapper('post', payload.post.postId, payload.reactor);
        };
        return createEventSubscriber(client, 'local.post.removeReaction', 'local.post.removeReaction', filter);
    }
    if (referenceType === 'story') {
        const filter = (payload) => {
            const { reactions } = payload, rest = __rest(payload, ["reactions"]);
            ingestInCache(rest);
            ingestInCache({ reactors: reactions });
            if (payload.stories.length === 0 || payload.reactions.length === 0)
                return;
            callbackWrapper('story', payload.stories[0].storyId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'story.reactionRemoved', 'story.reactionRemoved', filter);
    }
    const filter = (payload) => {
        callbackWrapper('comment', payload.comment.commentId, payload.reactor);
    };
    return createEventSubscriber(client, 'local.comment.removeReaction', 'local.comment.removeReaction', filter);
};

/**
 * ```js
 * import { onReactorAddedLocal } from '@amityco/ts-sdk'
 * const dispose = onReactorAdded('post', postId, reactor => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.InternalReactor} has been added
 *
 * @param {@link Amity.ReactableType} referenceType
 * @param {string} referenceId
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Events
 * */
const onReactorAddedLocal = (referenceType, referenceId, callback) => {
    const client = getActiveClient();
    const callbackWrapper = (referenceType_, referenceId_, reaction) => {
        if (referenceType_ === referenceType && referenceId_ === referenceId) {
            callback(reaction);
        }
    };
    if (referenceType === 'message') {
        const filter = async (rawPayload) => {
            const payload = await prepareMessagePayload(rawPayload);
            if (!payload.reactions[0])
                return;
            ingestInCache(payload);
            ingestInCache({ reactors: payload.reactions });
            callbackWrapper('message', payload.messages[0].messageId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'reaction/onReactorAdded', 'message.reactionAdded', filter);
    }
    if (referenceType === 'post') {
        const filter = (payload) => {
            callbackWrapper('post', payload.post.postId, payload.reactor);
        };
        return createEventSubscriber(client, 'local.post.addReaction', 'local.post.addReaction', filter);
    }
    if (referenceType === 'story') {
        const filter = (payload) => {
            const { reactions } = payload, rest = __rest(payload, ["reactions"]);
            ingestInCache(rest);
            ingestInCache({ reactors: reactions });
            if (payload.stories.length === 0 || payload.reactions.length === 0)
                return;
            callbackWrapper('story', payload.stories[0].storyId, payload.reactions[0]);
        };
        return createEventSubscriber(client, 'story.reactionAdded', 'story.reactionAdded', filter);
    }
    const filter = (payload) => {
        callbackWrapper('comment', payload.comment.commentId, payload.reactor);
    };
    return createEventSubscriber(client, 'local.comment.addReaction', 'local.comment.addReaction', filter);
};

class ReactionLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['reaction', 'collection', queryStreamId];
        const paginationController = new ReactionPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new ReactionQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), payload => payload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            {
                fn: callback => onReactorAdded(this.query.referenceType, this.query.referenceId, callback),
                action: "onAdded" /* Amity.ReactionActionTypeEnum.OnAdded */,
            },
            {
                fn: callback => onReactorRemoved(this.query.referenceType, this.query.referenceId, callback),
                action: "onRemoved" /* Amity.ReactionActionTypeEnum.OnRemoved */,
            },
            {
                fn: callback => onReactorRemovedLocal(this.query.referenceType, this.query.referenceId, callback),
                action: "onRemoved" /* Amity.ReactionActionTypeEnum.OnRemoved */,
            },
            {
                fn: callback => onReactorAddedLocal(this.query.referenceType, this.query.referenceId, callback),
                action: "onRemoved" /* Amity.ReactionActionTypeEnum.OnRemoved */,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = (_b = collection.data
            .map(reactorId => pullFromCache(['reactor', 'get', reactorId]))
            .filter(Boolean)
            .map(({ data }) => LinkedObject.reactor(data))) !== null && _b !== void 0 ? _b : [];
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
}

/* eslint-disable no-use-before-define */
/* begin_public_function
  id: reaction.query
*/
/**
 * ```js
 * import { getReactions } from '@amityco/ts-sdk'
 *
 * let reactions = []
 * const unsub = liveReactions({
 *   referenceId: Amity.Reaction['referenceId'],
 *   referenceType: Amity.Reaction['referenceType'],
 * }, response => merge(reactions, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.InternalReactor} for a given target object
 *
 * @param params for querying reactions
 * @param callback the function to call when new data are available
 * @param config the live collection configuration
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Reactions Live Collection
 */
const getReactions = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log('For using Live Collection feature you need to enable Cache!');
    }
    const timestamp = Date.now();
    log(`getReactions(tmpid: ${timestamp}) > listen`);
    const reactionLiveCollection = new ReactionLiveCollectionController(params, callback);
    const disposers = reactionLiveCollection.startSubscription();
    const cacheKey = reactionLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getReactions(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

var index$i = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addReaction: addReaction,
  removeReaction: removeReaction,
  onReactionAdded: onReactionAdded,
  onReactionRemoved: onReactionRemoved,
  onReactorAdded: onReactorAdded,
  onReactorRemoved: onReactorRemoved,
  getReactions: getReactions
});

function prepareCommentPayload(commentPayload) {
    const { comments } = commentPayload;
    return Object.assign(Object.assign({}, commentPayload), { comments: comments.map(comment => {
            if (comment.hasOwnProperty('myReactions'))
                return comment;
            // Sometimes `myReactions` field will not come with BE response because that field is empty
            // We need to put it with an empty array manually to make it show up in client side
            return Object.assign({ myReactions: [] }, comment);
        }) });
}

const createMessageReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.post(`/api/v5/messages/${encodeURIComponent(referenceId)}/flags`);
    if (client.cache) {
        const messagePayload = await prepareMessagePayload(payload);
        ingestInCache(messagePayload);
    }
    fireEvent(`message.flagged`, payload);
    return !!payload;
};
const createPostReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.post(`/api/v3/posts/${encodeURIComponent(referenceId)}/flag`);
    if (client.cache) {
        const postPayload = await preparePostPayload(payload);
        ingestInCache(postPayload);
    }
    fireEvent(`post.flagged`, payload);
    return !!payload;
};
const createUserReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.post(`/api/v4/me/flags/${encodeURIComponent(referenceId)}`);
    if (client.cache) {
        const userPayload = await prepareUserPayload(payload);
        ingestInCache(userPayload);
    }
    fireEvent(`user.flagged`, payload);
    return !!payload;
};
const createCommentReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.post(`/api/v3/comments/${encodeURIComponent(referenceId)}/flag`);
    if (client.cache) {
        const commentPayload = await prepareCommentPayload(payload);
        ingestInCache(commentPayload);
    }
    fireEvent(`comment.flagged`, payload);
    return !!payload;
};
/**
 * ```js
 * import { createReport } from '@amityco/ts-sdk'
 * const flagged = await createReport('post', postId)
 * ```
 *
 * @param referenceType The type of thing to add a report to, such as a post or a comment.
 * @param referenceId The ID of the thing to add a new report to.
 * @returns the created report result
 *
 * @category Report API
 * @async
 * */
const createReport = async (referenceType, referenceId) => {
    const client = getActiveClient();
    client.log('report/createReport', { referenceType, referenceId });
    if (referenceType === 'user') {
        return createUserReport({ client, referenceId });
    }
    if (referenceType === 'message') {
        return createMessageReport({ client, referenceId });
    }
    if (referenceType === 'post') {
        return createPostReport({ client, referenceId });
    }
    if (referenceType === 'comment') {
        return createCommentReport({ client, referenceId });
    }
    return false;
};

const deleteMessageReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.delete(`/api/v5/messages/${encodeURIComponent(referenceId)}/flags`);
    if (client.cache) {
        const messagePayload = await prepareMessagePayload(payload);
        ingestInCache(messagePayload);
    }
    fireEvent(`message.unflagged`, payload);
    return !!payload;
};
const deletePostReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.delete(`/api/v3/posts/${encodeURIComponent(referenceId)}/unflag`);
    if (client.cache) {
        const postPayload = await preparePostPayload(payload);
        ingestInCache(postPayload);
    }
    fireEvent(`post.unflagged`, payload);
    return !!payload;
};
const deleteUserReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.delete(`/api/v4/me/flags/${encodeURIComponent(referenceId)}`);
    if (client.cache) {
        const userPayload = await prepareUserPayload(payload);
        ingestInCache(userPayload);
    }
    fireEvent(`user.unflagged`, payload);
    return !!payload;
};
const deleteCommentReport = async ({ client, referenceId, }) => {
    const { data: payload } = await client.http.delete(`/api/v3/comments/${encodeURIComponent(referenceId)}/unflag`);
    if (client.cache) {
        const commentPayload = await prepareCommentPayload(payload);
        ingestInCache(commentPayload);
    }
    fireEvent(`comment.unflagged`, payload);
    return !!payload;
};
/**
 * ```js
 * import { deleteReport } from '@amityco/ts-sdk'
 * const unflagged = await deleteReport('post', postId)
 * ```
 *
 * @param referenceType The type of thing to delete a report to, such as a post or a comment.
 * @param referenceId The ID of the thing to delete a report to.
 * @returns the deleted report result
 *
 * @category Report API
 * @async
 * */
const deleteReport = async (referenceType, referenceId) => {
    const client = getActiveClient();
    client.log('report/deleteReport', { referenceType, referenceId });
    if (referenceType === 'user') {
        return deleteUserReport({ client, referenceId });
    }
    if (referenceType === 'message') {
        return deleteMessageReport({ client, referenceId });
    }
    if (referenceType === 'post') {
        return deletePostReport({ client, referenceId });
    }
    if (referenceType === 'comment') {
        return deleteCommentReport({ client, referenceId });
    }
    return false;
};

const getMessageReport = async ({ client, referenceId, }) => {
    var _a;
    const { data } = await client.http.get(`/api/v5/messages/${encodeURIComponent(referenceId)}/flags`);
    const { result, isFlagByMe } = data !== null && data !== void 0 ? data : {};
    return (_a = result !== null && result !== void 0 ? result : isFlagByMe) !== null && _a !== void 0 ? _a : false;
};
const getPostReport = async ({ client, referenceId, }) => {
    var _a;
    const { data } = await client.http.get(`/api/v3/posts/${referenceId}/isflagbyme`);
    const { result, isFlagByMe } = data !== null && data !== void 0 ? data : {};
    return (_a = result !== null && result !== void 0 ? result : isFlagByMe) !== null && _a !== void 0 ? _a : false;
};
const getUserReport = async ({ client, referenceId, }) => {
    var _a;
    const { data } = await client.http.get(`/api/v3/users/${referenceId}/isflagbyme`);
    const { result, isFlagByMe } = data !== null && data !== void 0 ? data : {};
    return (_a = result !== null && result !== void 0 ? result : isFlagByMe) !== null && _a !== void 0 ? _a : false;
};
const getCommentReport = async ({ client, referenceId, }) => {
    var _a;
    const { data } = await client.http.get(`/api/v3/comments/${referenceId}/isflagbyme`);
    const { result, isFlagByMe } = data !== null && data !== void 0 ? data : {};
    return (_a = result !== null && result !== void 0 ? result : isFlagByMe) !== null && _a !== void 0 ? _a : false;
};
/**
 * ```js
 * import { isReportedByMe } from '@amityco/ts-sdk'
 * const isReported = await isReportedByMe('post', postId)
 * ```
 *
 * @param referenceType The type of thing to check a report to, such as a post or a comment.
 * @param referenceId The ID of the thing to check a report to.
 * @returns `true` if the report is created by me, `false` if doesn't.
 *
 * @category Report API
 * @async
 * */
const isReportedByMe = async (referenceType, referenceId) => {
    const client = getActiveClient();
    client.log('report/isReportedByMe', { referenceType, referenceId });
    if (referenceType === 'user') {
        return getUserReport({ client, referenceId });
    }
    if (referenceType === 'message') {
        return getMessageReport({ client, referenceId });
    }
    if (referenceType === 'post') {
        return getPostReport({ client, referenceId });
    }
    if (referenceType === 'comment') {
        return getCommentReport({ client, referenceId });
    }
    return false;
};

/* begin_public_function
  id: channel.create
*/
/**
 * ```js
 * import { createChannel } from '@amityco/ts-sdk'
 * const created = await createChannel({ displayName: 'foobar' })
 * ```
 *
 * Creates an {@link Amity.Channel}
 *
 * @param bundle The data necessary to create a new {@link Amity.Channel}
 * @returns The newly created {@link Amity.Channel}
 *
 * @category Channel API
 * @async
 */
const createChannel = async (bundle) => {
    const client = getActiveClient();
    client.log('user/createChannel', bundle);
    let payload;
    if ((bundle === null || bundle === void 0 ? void 0 : bundle.type) === 'conversation') {
        payload = await client.http.post('/api/v3/channels/conversation', Object.assign(Object.assign({}, bundle), { isDistinct: true }));
    }
    else {
        const { isPublic } = bundle, restParams = __rest(bundle, ["isPublic"]);
        payload = await client.http.post('/api/v3/channels', Object.assign(Object.assign({}, restParams), { isPublic: (bundle === null || bundle === void 0 ? void 0 : bundle.type) === 'community' ? isPublic : undefined }));
    }
    const data = await prepareChannelPayload(payload.data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { channels } = data;
    return {
        data: constructChannelDynamicValue(channels[0]),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: channel.update
*/
/**
 * ```js
 * import { updateChannel } from '@amityco/ts-sdk'
 * const updated = await updateChannel(channelId, { displayName: 'foobar' })
 * ```
 *
 * Updates an {@link Amity.Channel}
 *
 * @param channelId The ID of the {@link Amity.Channel} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Channel} object
 *
 * @category Channel API
 * @async
 */
const updateChannel = async (channelId, patch) => {
    const client = getActiveClient();
    client.log('channel/updateChannel', channelId, patch);
    const { data: payload } = await client.http.put(`/api/v3/channels/${encodeURIComponent(channelId)}`, patch);
    const data = await prepareChannelPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { channels } = data;
    return {
        data: constructChannelDynamicValue(channels.find(channel => channel.channelId === channelId)),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { getChannel } from '@amityco/ts-sdk'
 * const channel = await getChannel('foobar')
 * ```
 *
 * Fetches a {@link Amity.Channel} object
 *
 * @param channelId the ID of the {@link Amity.Channel} to fetch
 * @returns the associated {@link Amity.Channel} object
 *
 * @category Channel API
 * @async
 */
const getChannel$1 = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/getChannel', channelId);
    isInTombstone('channel', channelId);
    let data;
    try {
        const { data: payload } = await client.http.get(`/api/v3/channels/${encodeURIComponent(channelId)}`);
        data = await prepareChannelPayload(payload);
        if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
            prepareUnreadCountInfo(payload);
        }
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            // NOTE: use channelPublicId as tombstone cache key since we cannot get the channelPrivateId that come along with channel data from server
            pushToTombstone('channel', channelId);
        }
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { channels } = data;
    return {
        data: channels.find(channel => channel.channelId === channelId),
        cachedAt,
    };
};
/**
 * ```js
 * import { getChannel } from '@amityco/ts-sdk'
 * const channel = getChannel.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Channel} object from cache
 *
 * @param channelId the ID of the {@link Amity.Channel} to fetch
 * @returns the associated {@link Amity.Channel} object
 *
 * @category Channel API
 */
getChannel$1.locally = (channelId) => {
    var _a;
    const client = getActiveClient();
    client.log('channel/getChannel.locally', channelId);
    if (!client.cache)
        return;
    // use queryCache to get all channel caches and filter by channelPublicId since we use channelPrivateId as cache key
    const cached = (_a = queryCache(['channel', 'get'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
        return data.channelPublicId === channelId;
    });
    if (!cached || (cached === null || cached === void 0 ? void 0 : cached.length) === 0)
        return;
    return {
        data: cached[0].data,
        cachedAt: cached[0].cachedAt,
    };
};

/**
 * ```js
 * import { deleteChannel } from '@amityco/ts-sdk'
 * const success = await deleteChannel('foobar')
 * ```
 *
 * Deletes a {@link Amity.Channel}
 *
 * @param channelId The {@link Amity.Channel} ID to delete
 * @return A success boolean if the {@link Amity.Channel} was deleted
 *
 * @category Channel API
 * @async
 */
const deleteChannel = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/deleteChannel', channelId);
    await client.http.delete(`/api/v3/channels/${encodeURIComponent(channelId)}`);
    const deleted = await getChannel$1(channelId);
    // no need for event, fired by server
    return constructChannelDynamicValue(deleted.data);
};

/* begin_public_function
  id: channel.join
*/
/**
 * ```js
 * import { joinChannel } from '@amityco/ts-sdk'
 * const isJoined = await joinChannel('foobar')
 * ```
 *
 * Joins a {@link Amity.Channel} object
 *
 * @param channelId the {@link Amity.Channel} to join
 * @returns A success boolean if the {@link Amity.Channel} was joined
 *
 * @category Channel API
 * @async
 */
const joinChannel = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/joinChannel', channelId);
    const { data: payload } = await client.http.post(`/api/v3/channels/${encodeURIComponent(channelId)}/join`);
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && channelUser.membership === 'member');
};
/* end_public_function */

/* begin_public_function
  id: channel.leave
*/
/**
 * ```js
 * import { leaveChannel } from '@amityco/ts-sdk'
 * const isLeft = await leaveChannel('foobar')
 * ```
 *
 * Leave a {@link Amity.Channel} object
 *
 * @param channelId the {@link Amity.Channel} to leave
 * @returns A success boolean if the {@link Amity.Channel} was left
 *
 * @category Channel API
 * @async
 */
const leaveChannel = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/leaveChannel', channelId);
    const { data: payload } = await client.http.delete(`/api/v3/channels/${encodeURIComponent(channelId)}/leave`);
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && channelUser.membership !== 'member');
};
/* end_public_function */

/* begin_public_function
  id: channel.mute
*/
const MUTE_FOREVER$1 = -1;
/**
 * ```js
 * import { ChannelRepository } from '@amityco/ts-sdk'
 * const isMuted = await ChannelRepository.muteChannel('channel-id', 100)
 * ```
 *
 * Mutes a {@link Amity.Channel} object
 *
 * @param channelId the {@link Amity.Channel} to mute
 * @param mutePeriod the duration to be muted
 * @returns A success boolean if the {@link Amity.Channel} was muted
 *
 * @category Channel API
 * @async
 */
const muteChannel = async (channelId, mutePeriod = MUTE_FOREVER$1) => {
    const client = getActiveClient();
    client.log('channel/muteChannel', channelId);
    if (mutePeriod !== MUTE_FOREVER$1 && mutePeriod < 0)
        throw new ASCError(`Mute Period can only be positive numbers or ${MUTE_FOREVER$1}(mute forever)`, 800110 /* Amity.ClientError.INVALID_PARAMETERS */, "error" /* Amity.ErrorLevel.ERROR */);
    const { data } = await client.http.put(`/api/v2/channel/${encodeURIComponent(channelId)}/mute`, { mutePeriod });
    const { success } = data;
    return success;
};
/* end_public_function */

/* begin_public_function
  id: channel.unmute
*/
const CHANNEL_UNMUTE_PERIOD = 0;
/**
 * ```js
 * import { ChannelRepository } from '@amityco/ts-sdk'
 * const isMuted = await ChannelRepository.unmute('foobar')
 * ```
 *
 * Mutes a {@link Amity.Channel} object
 *
 * @param channelId the {@link Amity.Channel} to mute
 * @returns A success boolean if the {@link Amity.Channel} was muted
 *
 * @category Channel API
 * @async
 */
const unmuteChannel = async (channelId) => {
    const client = getActiveClient();
    client.log('channel/unmuteChannel', channelId);
    const { data } = await client.http.put(`/api/v2/channel/${encodeURIComponent(channelId)}/mute`, 
    /*
     * Setting mute period as 0 is the same as unmuting the channel
     */
    { mutePeriod: CHANNEL_UNMUTE_PERIOD });
    const { success } = data;
    return success;
};
/* end_public_function */

/**
 * ```js
 * import { onMessageUpdated } from '@amityco/ts-sdk'
 * const dispose = onMessageUpdated(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageUpdated = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    const disposers = [
        createEventSubscriber(client, 'onMessageUpdated', 'message.updated', filter),
        createEventSubscriber(client, 'onMessageUpdated', 'local.message.updated', payload => callback(payload.messages[0])),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

/**
 * ```js
 * import { onMessageDeleted } from '@amityco/ts-sdk'
 * const dispose = onMessageDeleted(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} was deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageDeleted = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    const disposers = [
        createEventSubscriber(client, 'message/onMessageDeleted', 'message.deleted', filter),
        createEventSubscriber(client, 'message/onMessageDeleted', 'local.message.deleted', payload => callback(payload.messages[0])),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

/**
 * ```js
 * import { onSubChannelUpdated } from '@amityco/ts-sdk'
 * const dispose = onSubChannelUpdated(subChannel => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.SubChannel} have been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Channel Events
 */
const onSubChannelUpdated = (callback) => {
    const client = getActiveClient();
    const subChannelChangeHandler = async (rawPayload) => {
        const payload = await prepareSubChannelPayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messageFeeds[0]);
    };
    const disposers = [
        createEventSubscriber(client, 'onSubChannelUpdated', 'message-feed.updated', subChannelChangeHandler),
        createEventSubscriber(client, 'onSubChannelUpdated', 'local.message-feed.updated', payload => callback(payload.messageFeeds[0])),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

function updateChannelCache(channel, params) {
    pushToCache(['channel', 'get', channel.channelId], 
    // eslint-disable-next-line prefer-object-spread
    shallowClone(channel, params));
}

/**
 * ```js
 * import { onChannelMarkerUpdated } from '@amityco/ts-sdk'
 * const dispose = onChannelMarkerUpdated(channelMarker => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.ChannelMarker} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category ChannelMarker Events
 */
const onChannelMarkerUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload.userEntityMarkers[0]);
    };
    return createEventSubscriber(client, 'channelMarker/onChannelMarkerUpdated', 'local.channelMarker.updated', filter);
};

/* begin_public_function
  id: subchannel.create
*/
/**
 * ```js
 * import { createSubChannel } from '@amityco/ts-sdk'
 * const created = await createSubChannel({ channelId: 'foobar', name: 'foobar' })
 * ```
 *
 * Creates an {@link Amity.SubChannel}
 *
 * @param bundle The data necessary to create a new {@link Amity.SubChannel}
 * @returns The newly created {@link Amity.SubChannel}
 *
 * @category Channel API
 * @async
 */
const createSubChannel = async (bundle) => {
    const client = getActiveClient();
    client.log('user/createSubChannel', bundle);
    const response = await client.http.post('/api/v5/message-feeds', {
        channelId: bundle.channelId,
        name: bundle.displayName,
    });
    const data = await prepareSubChannelPayload(response.data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('message-feed.created', response.data);
    return {
        data: data.messageFeeds[0],
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: subchannel.update
*/
/**
 * ```js
 * import { updateSubChannel } from '@amityco/ts-sdk'
 * const updated = await updateSubChannel(subChannelId, { name: 'foobar' })
 * ```
 *
 * Updates an {@link Amity.SubChannel}
 *
 * @param subChannelId The ID of the {@link Amity.SubChannel} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.SubChannel} object
 *
 * @category Channel API
 * @async
 */
const updateSubChannel = async (subChannelId, patch) => {
    const client = getActiveClient();
    client.log('channel/updateSubChannel', subChannelId, patch);
    const response = await client.http.put(`/api/v5/message-feeds/${encodeURIComponent(subChannelId)}`, { name: patch.displayName });
    const data = await prepareSubChannelPayload(response.data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('message-feed.updated', response.data);
    return {
        data: data.messageFeeds[0],
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { deleteSubChannel } from '~/subChannelRepository/api/deleteSubChannel'
 * const success = await deleteSubChannel('foobar')
 * ```
 *
 * Deletes a {@link Amity.SubChannel}
 *
 * @param subChannelId The {@link Amity.SubChannel} ID to delete
 * @return A the {@link Amity.SubChannel} was deleted
 *
 * @private
 * @async
 */
const deleteSubChannel = async (subChannelId, permanent = false) => {
    const client = getActiveClient();
    const subChannel = await getSubChannel$1(subChannelId);
    await client.http.delete(`/api/v5/message-feeds/${encodeURIComponent(subChannelId)}`, { params: { permanent } });
    const deleted = Object.assign(Object.assign({}, subChannel.data), { isDeleted: true, updatedAt: getFutureDate(subChannel.data.updatedAt) });
    if (permanent) {
        setTimeout(() => {
            pushToTombstone('subChannel', subChannelId);
        }, 0);
    }
    else {
        upsertInCache(['subChannel', 'get', subChannelId], deleted);
    }
    fireEvent('local.message-feed.deleted', { messageFeeds: [deleted] });
    return deleted;
};

/* begin_public_function
  id: subchannel.hard_delete
*/
/**
 * ```js
 * import { SubChannelRepository } from '@amityco/ts-sdk'
 * const success = await SubChannelRepository.hardDeleteSubChannel('foobar')
 * ```
 *
 * Deletes a {@link Amity.SubChannel}
 *
 * @param subChannelId The {@link Amity.SubChannel} ID to hard delete
 * @return The {@link Amity.SubChannel} was hard deleted
 *
 * @category Channel API
 * @async
 */
const hardDeleteSubChannel = async (subChannelId) => {
    const client = getActiveClient();
    client.log('channel/hardDeleteSubChannel', subChannelId);
    const hardDeleted = await deleteSubChannel(subChannelId, true);
    return hardDeleted;
};
/* end_public_function */

/* begin_public_function
  id: subchannel.soft_delete
*/
/**
 * ```js
 * import { SubChannelRepository } from '@amityco/ts-sdk'
 * const success = await SubChannelRepository.softDeleteSubChannel('foobar')
 * ```
 *
 * Deletes a {@link Amity.SubChannel}
 *
 * @param subChannelId The {@link Amity.SubChannel} ID to soft delete
 * @return A success boolean if the {@link Amity.SubChannel} was soft deleted
 *
 * @category Channel API
 * @async
 */
const softDeleteSubChannel = async (subChannelId) => {
    const client = getActiveClient();
    client.log('channel/softDeleteSubChannel', subChannelId);
    const softDelted = await deleteSubChannel(subChannelId, false);
    return softDelted;
};
/* end_public_function */

/** @hidden */
const onSubChannelFetched = (callback) => {
    return createEventSubscriber(getActiveClient(), 'onSubChannelFetched', 'local.message-feed.fetched', payload => callback(payload.messageFeeds[0]));
};

const getLocalId = () => `LOCAL_${uuid()}`;
// FIXME: temp solution
let uniqueId;
const createMessageOptimistic = (bundle) => {
    var _a, _b;
    const client = getActiveClient();
    if (!client.cache)
        return;
    /*
     * When creating messages optimistically a messageId needs to be added by the
     * client, created a new variable to allow backward compatibility of API
     *
     * Updated to handle client requirement to add messageId while uploading
     * a message with image.
     * Temporary!
     */
    uniqueId = bundle.referenceId || getLocalId();
    const bundleWithMessageId = Object.assign({ messageId: uniqueId, uniqueId }, bundle);
    client.log('message/createMessage.optimistically', bundleWithMessageId);
    const subChannel = pullFromCache(['subChannel', 'get', bundle.subChannelId]);
    if (subChannel) {
        upsertInCache(['subChannel', 'get', bundle.subChannelId], Object.assign(Object.assign({}, subChannel.data), { messageCount: subChannel.data.messageCount + 1 }));
        if (subChannel.data.channelId === subChannel.data.subChannelId) {
            const channel = pullFromCache([
                'channel',
                'get',
                subChannel.data.channelId,
            ]);
            if (channel === null || channel === void 0 ? void 0 : channel.data) {
                upsertInCache(['channel', 'get', subChannel.data.channelId], Object.assign(Object.assign({}, channel.data), { messageCount: ((_a = channel.data.messageCount) !== null && _a !== void 0 ? _a : 0) + 1 }));
            }
        }
    }
    // as reused to update created and updated time, which should be the same
    const createdTime = new Date().toISOString();
    const message = Object.assign({ creatorId: client.userId, creatorPrivateId: getActiveUser()._id, channelSegment: ((_b = subChannel === null || subChannel === void 0 ? void 0 : subChannel.data.messageCount) !== null && _b !== void 0 ? _b : 0) + 1, childrenNumber: 0, createdAt: createdTime, updatedAt: createdTime, syncState: "syncing" /* Amity.SyncState.Syncing */, isDeleted: false }, bundleWithMessageId);
    const cachedAt = UNSYNCED_OBJECT_CACHED_AT_VALUE;
    pushToCache(['message', 'get', message.messageId], message, { cachedAt });
    fireEvent('local.message.created', { messages: [message] });
    return message;
};
/**
 * ```js
 * import { createMessage, createQuery, runQuery } from '@amityco/ts-sdk'
 *
 * const query = createQuery(createMessage, {
 *   subChannelId: 'foobar',
 *   data: { text: 'hello world' },
 * });
 *
 * runQuery(query, ({ data: message, loading }) => {
 *   console.log(message);
 * });
 * ```
 *
 * Creates an {@link Amity.Message}
 *
 * @param bundle The data necessary to create a new {@link Amity.Message}
 * @returns The newly created {@link Amity.Message}
 *
 * @category Message API
 * @async
 */
const createMessage = async (bundle) => {
    const client = getActiveClient();
    client.log('message/createMessage', bundle);
    const optimisticData = createMessageOptimistic(bundle);
    const referenceId = bundle.referenceId || uniqueId || getLocalId();
    uniqueId = undefined;
    try {
        const { data: payload } = await client.http.post('/api/v5/messages', Object.assign(Object.assign({}, convertParams(bundle)), { referenceId }));
        const data = await prepareMessagePayload(payload);
        const { messages } = data;
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(data, { cachedAt });
        }
        fireEvent('local.message.created', {
            messages: [Object.assign(Object.assign({}, messages[0]), { syncState: "synced" /* Amity.SyncState.Synced */ })],
        });
        return {
            data: LinkedObject.message(messages[0]),
            cachedAt,
        };
    }
    catch (e) {
        fireEvent('local.message.created', {
            messages: [Object.assign(Object.assign({}, optimisticData), { syncState: "error" /* Amity.SyncState.Error */ })],
        });
        throw e;
    }
};
/* end_public_function */

/* begin_public_function
  id: message.edit
*/
/**
 * ```js
 * import { updateMessage } from '@amityco/ts-sdk'
 * const updated = await updateMessage(messageId, {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Message}
 *
 * @param messageId The ID of the {@link Amity.Message} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Message} object
 *
 * @category Message API
 * @async
 */
const updateMessage = async (messageId, patch) => {
    const client = getActiveClient();
    client.log('message/updateMessage', patch);
    console.warn('MessageRepository.updateMessage will be replaced with MessageRepository.editMessage');
    const { data: payload } = await client.http.put(`/api/v5/messages/${encodeURIComponent(messageId)}`, convertParams(patch));
    const data = await prepareMessagePayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { messages } = data;
    fireEvent('local.message.updated', { messages });
    return {
        data: LinkedObject.message(messages.find(message => message.messageId === messageId)),
        cachedAt,
    };
};
/**
 * ```js
 * import { updateMessage } from '@amityco/ts-sdk'
 * const updated = updateMessage.optimistically('foobar', {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Message} in cache
 *
 * @param messageId The ID of the {@link Amity.Message} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Message} object
 *
 * @category Message API
 */
updateMessage.optimistically = (messageId, patch) => {
    const client = getActiveClient();
    client.log('message/updateMessage.optimistically', patch);
    if (!client.cache)
        return;
    const message = pullFromCache(['message', 'get', messageId]);
    if (!message)
        return;
    const cachedAt = -1;
    const updated = Object.assign(Object.assign(Object.assign({}, message.data), patch), { updatedAt: new Date().toISOString() });
    upsertInCache(['message', 'get', messageId], updated, { cachedAt });
    fireEvent('local.message.updated', { messages: [updated] });
    return {
        data: LinkedObject.message(updated),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: message.edit.text_message, message.edit.custom_message
*/
/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const updated = await MessageRepository.editMessage(messageId, {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Message}
 *
 * @param messageId The ID of the {@link Amity.Message} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Message} object
 *
 * @category Message API
 * @async
 */
const editMessage = async (messageId, patch) => {
    const client = getActiveClient();
    client.log('message/editMessage', patch);
    const { data: payload } = await client.http.put(`/api/v5/messages/${encodeURIComponent(messageId)}`, convertParams(patch));
    const data = await prepareMessagePayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { messages } = data;
    fireEvent('local.message.updated', { messages });
    return {
        data: LinkedObject.message(messages.find(message => message.messageId === messageId)),
        cachedAt,
    };
};
/**
 * ```js
 * import { editMessage } from '@amityco/ts-sdk'
 * const updated = editMessage.optimistically('foobar', {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Message} in cache
 *
 * @param messageId The ID of the {@link Amity.Message} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Message} object
 *
 * @category Message API
 */
editMessage.optimistically = (messageId, patch) => {
    const client = getActiveClient();
    client.log('message/editMessage.optimistically', patch);
    if (!client.cache)
        return;
    const message = pullFromCache(['message', 'get', messageId]);
    if (!message)
        return;
    const cachedAt = -1;
    const edited = Object.assign(Object.assign(Object.assign({}, message.data), patch), { updatedAt: new Date().toISOString() });
    upsertInCache(['message', 'get', messageId], edited, { cachedAt });
    fireEvent('local.message.updated', { messages: [edited] });
    return {
        data: LinkedObject.message(edited),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { deleteMessage } from '@amityco/ts-sdk'
 * const success = await deleteMessage('foobar')
 * ```
 *
 * Delete a {@link Amity.Message}
 *
 * @param messageId the ID of the {@link Amity.Message} to delete
 * @return A success boolean if the {@link Amity.Message} was deleted
 *
 * @category Message API
 * @async
 */
const deleteMessage = async (messageId) => {
    const client = getActiveClient();
    client.log('message/deleteMessage', messageId);
    // API-FIX: This endpoint has not been implemented yet.
    const { data: deleted } = await client.http.delete(`/api/v5/messages/${encodeURIComponent(messageId)}`);
    const payload = await prepareMessagePayload(deleted);
    fireEvent('local.message.deleted', {
        messages: [payload.messages[0]],
    });
    return LinkedObject.message(payload.messages[0]);
};
/**
 * ```js
 * import { deleteMessage } from '@amityco/ts-sdk'
 * const success = deleteMessage.optimistically('foobar')
 * ```
 *
 * Deletes a {@link Amity.Message}
 *
 * @param messageId The {@link Amity.Message} ID to delete
 * @return A success boolean if the {@link Amity.Message} was deleted
 *
 * @category Message API
 */
deleteMessage.optimistically = (messageId) => {
    const client = getActiveClient();
    client.log('message/deleteMessage.optimistically', messageId);
    const message = pullFromCache(['message', 'get', messageId]);
    if (!message)
        return;
    const cachedAt = -1;
    const deleted = Object.assign(Object.assign({}, message.data), { isDeleted: true, updatedAt: new Date().toISOString() });
    upsertInCache(['message', 'get', messageId], deleted, { cachedAt });
    fireEvent('local.message.deleted', { messages: [deleted] });
    return {
        data: LinkedObject.message(deleted),
        cachedAt,
    };
};

/* begin_public_function
  id: message.soft_delete
*/
/**
 * ```js
 * import { softDeleteMessage } from '@amityco/ts-sdk'
 * const success = await softDeleteMessage('foobar')
 * ```
 *
 * Delete a {@link Amity.Message}
 *
 * @param messageId the ID of the {@link Amity.Message} to delete
 * @return A success boolean if the {@link Amity.Message} was deleted
 *
 * @category Message API
 * @async
 */
const softDeleteMessage = async (messageId) => {
    const client = getActiveClient();
    client.log('message/softDeleteMessage', messageId);
    // API-FIX: This endpoint has not been implemented yet.
    await client.http.delete(`/api/v5/messages/${encodeURIComponent(messageId)}`);
    const deleted = await getMessage$1(messageId);
    fireEvent('local.message.deleted', { messages: [deleted.data] });
    return LinkedObject.message(deleted.data);
};
/**
 * ```js
 * import { softDeleteMessage } from '@amityco/ts-sdk'
 * const success = softDeleteMessage.optimistically('foobar')
 * ```
 *
 * Deletes a {@link Amity.Message}
 *
 * @param messageId The {@link Amity.Message} ID to delete
 * @return A success boolean if the {@link Amity.Message} was deleted
 *
 * @category Message API
 */
softDeleteMessage.optimistically = (messageId) => {
    const client = getActiveClient();
    client.log('message/softDeleteMessage.optimistically', messageId);
    const message = pullFromCache(['message', 'get', messageId]);
    if (!message)
        return;
    const cachedAt = -1;
    const deleted = Object.assign(Object.assign({}, message.data), { isDeleted: true, updatedAt: new Date().toISOString() });
    upsertInCache(['message', 'get', messageId], deleted, { cachedAt });
    fireEvent('local.message.deleted', { messages: [deleted] });
    return {
        data: LinkedObject.message(deleted),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const success = await MessageRepository.markAsDelivered('subChannelId', 'messageId')
 * ```
 *
 * Update `deliveredToSegment` in  {@link Amity.SubChannelMarker}
 *
 * @param subChannelId the ID of the {@link Amity.SubChannel} of message
 * @param messageId the ID of the {@link Amity.Message} to mark delivered
 * @returns A success boolean if the {@link Amity.SubChannel} was updated
 *
 * @category Message API
 * @async
 */
const markAsDelivered = async (subChannelId, messageId) => {
    const client = getActiveClient();
    client.log('message/markAsDelivered', subChannelId, messageId);
    const { data } = await client.http.put(`/api/v1/markers/message-feeds/${subChannelId}/mark-delivering`, { messageId });
    const { userMarkers, userEntityMarkers, userFeedMarkers } = data, rest = __rest(data, ["userMarkers", "userEntityMarkers", "userFeedMarkers"]);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(Object.assign({ userMarkers, userEntityMarkers: convertChannelMarkerResponse(userEntityMarkers), userFeedMarkers: convertSubChannelMarkerResponse(userFeedMarkers) }, rest), { cachedAt });
    return true;
};

/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const { data: users, prevPage, nextPage } = await MessageRepository.getReadUsers({
 *   messageId: 'foo',
 *   memberships: ['member']
 * })
 * ```
 *
 * Queries a paginable list of read {@link Amity.InternalUser} by messageId
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.InternalUser} objects
 *
 * @category Message API
 * @async
 */
const getReadUsers = async (query) => {
    const client = getActiveClient();
    client.log('user/getReadUsers', query);
    const { page, messageId } = query, params = __rest(query, ["page", "messageId"]);
    const { data } = await client.http.get(`/api/v1/markers/messages/${messageId}/read-users`, {
        params: Object.assign(Object.assign({}, params), { options: {
                token: toToken(page, 'afterbeforeraw'),
            } }),
    });
    const { paging, publicUserIds: readUsers, userFeedMarkers } = data, payload = __rest(data, ["paging", "publicUserIds", "userFeedMarkers"]);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(Object.assign(Object.assign({}, payload), { userFeedMarkers: convertSubChannelMarkerResponse(userFeedMarkers) }), { cachedAt });
        const cacheKey = [
            'read-user',
            'query',
            Object.assign(Object.assign({ messageId }, params), { options: Object.assign({}, page) }),
        ];
        pushToCache(cacheKey, { users: readUsers, paging });
    }
    let users = [];
    if (readUsers.length > 0) {
        ({ data: users } = await getUserByIds(readUsers));
    }
    const prevPage = toPage(paging.previous);
    const nextPage = toPage(paging.next);
    return { data: users, cachedAt, prevPage, nextPage };
};
/**
 * ```js
 * import { getReadUsers } from '@amityco/ts-sdk'
 * const { data: users } = getReadUsers.locally({
 *   messageId: 'foo',
 *   memberships: ['member']
 * })
 * ```
 *
 * Queries a paginable list of read {@link Amity.InternalUser} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.InternalUser} objects
 *
 * @category Message API
 */
getReadUsers.locally = (query) => {
    var _a;
    const client = getActiveClient();
    client.log('user/getReadUsers.locally', query);
    if (!client.cache)
        return;
    const { page } = query, params = __rest(query, ["page"]);
    const cacheKey = [
        'read-user',
        'query',
        Object.assign(Object.assign({}, params), { options: Object.assign({}, page) }),
    ];
    const { data, cachedAt } = (_a = pullFromCache(cacheKey)) !== null && _a !== void 0 ? _a : {};
    const users = data === null || data === void 0 ? void 0 : data.users.map(userId => { var _a; return (_a = pullFromCache(['user', 'get', userId])) === null || _a === void 0 ? void 0 : _a.data; });
    if (!users || users.some(user => !user))
        return;
    const prevPage = toPage(data === null || data === void 0 ? void 0 : data.paging.previous);
    const nextPage = toPage(data === null || data === void 0 ? void 0 : data.paging.next);
    return { data: users, cachedAt, prevPage, nextPage };
};

/**
 * ```js
 * import { getDeliveredUsers } from '@amityco/ts-sdk'
 * const { data: users, prevPage, nextPage } = await getDeliveredUsers({
 *   messageId: 'foo',
 * })
 * ```
 *
 * Queries a paginable list of delivered {@link Amity.InternalUser} by messageId
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.InternalUser} objects
 *
 * @category Message API
 * @async
 */
const getDeliveredUsers = async (query) => {
    const client = getActiveClient();
    client.log('user/getDeliveredUsers', query);
    const { page, messageId } = query, params = __rest(query, ["page", "messageId"]);
    const { data } = await client.http.get(`/api/v1/markers/messages/${messageId}/delivered-users`, {
        params: Object.assign(Object.assign({}, params), { options: {
                token: toToken(page, 'afterbeforeraw'),
            } }),
    });
    const { paging, publicUserIds: deliveredUsers, userFeedMarkers } = data, payload = __rest(data, ["paging", "publicUserIds", "userFeedMarkers"]);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(Object.assign(Object.assign({}, payload), { userFeedMarkers: convertSubChannelMarkerResponse(userFeedMarkers) }), { cachedAt });
        const cacheKey = [
            'delivered-user',
            'query',
            Object.assign(Object.assign({ messageId }, params), { options: Object.assign({}, page) }),
        ];
        pushToCache(cacheKey, { users: deliveredUsers, paging });
    }
    let users = [];
    if (deliveredUsers.length > 0) {
        ({ data: users } = await getUserByIds(deliveredUsers));
    }
    const prevPage = toPage(paging.previous);
    const nextPage = toPage(paging.next);
    return { data: users, cachedAt, prevPage, nextPage };
};
/**
 * ```js
 * import { getDeliveredUsers } from '@amityco/ts-sdk'
 * const { data: users } = getDeliveredUsers.locally({
 *   messageId: 'foo',
 * })
 * ```
 *
 * Queries a paginable list of delivered {@link Amity.InternalUser} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.InternalUser} objects
 *
 * @category Message API
 */
getDeliveredUsers.locally = (query) => {
    var _a;
    const client = getActiveClient();
    client.log('user/getDeliveredUsers.locally', query);
    if (!client.cache)
        return;
    const { page } = query, params = __rest(query, ["page"]);
    const cacheKey = [
        'delivered-user',
        'query',
        Object.assign(Object.assign({}, params), { options: Object.assign({}, page) }),
    ];
    const { data, cachedAt } = (_a = pullFromCache(cacheKey)) !== null && _a !== void 0 ? _a : {};
    const users = data === null || data === void 0 ? void 0 : data.users.map(userId => { var _a; return (_a = pullFromCache(['user', 'get', userId])) === null || _a === void 0 ? void 0 : _a.data; });
    if (!users || users.some(user => !user))
        return;
    const prevPage = toPage(data === null || data === void 0 ? void 0 : data.paging.previous);
    const nextPage = toPage(data === null || data === void 0 ? void 0 : data.paging.next);
    return { data: users, cachedAt, prevPage, nextPage };
};

/* begin_public_function
  id: message.flag
*/
/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const flagged = await MessageRepository.flagMessage(messageId)
 * ```
 *
 * @param messageId of the message to flag
 * @returns the created report result
 *
 * @category Message API
 * @async
 * */
const flagMessage = async (messageId) => {
    const client = getActiveClient();
    client.log('message/flag', messageId);
    const { data: payload } = await client.http.post(`/api/v5/messages/${encodeURIComponent(messageId)}/flags`);
    if (client.cache) {
        const messagePayload = await prepareMessagePayload(payload);
        ingestInCache(messagePayload);
    }
    fireEvent('message.flagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: message.unflag
*/
/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const unflagged = await MessageRepository.unflag(messageId)
 * ```
 *
 * @param messageId of the message to unflag
 * @returns boolean to indicate success
 *
 * @category Report API
 * @async
 * */
const unflagMessage = async (messageId) => {
    const client = getActiveClient();
    client.log('message/unflag', messageId);
    const { data: payload } = await client.http.delete(`/api/v5/messages/${encodeURIComponent(messageId)}/flags`);
    if (client.cache) {
        const messagePayload = await prepareMessagePayload(payload);
        ingestInCache(messagePayload);
    }
    fireEvent('message.unflagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: message.check_flag_by_me
*/
/**
 * ```js
 * import { MessageRepository } from '@amityco/ts-sdk'
 * const isReportedByMe = await MessageRepository.isMessageFlaggedByMe(messageId)
 * ```
 *
 * @param messageId of the message to check a report of.
 * @returns `true` if the report is created by me, `false` if doesn't.
 *
 * @category Report API
 * @async
 * */
const isMessageFlaggedByMe = async (messageId) => {
    const client = getActiveClient();
    client.log('message/isMessageFlaggedByMe', messageId);
    const { data } = await client.http.get(`/api/v5/messages/${encodeURIComponent(messageId)}/flags`);
    return data.result;
};
/* end_public_function */

/**
 * ```js
 * import { onMessageFlagged } from '@amityco/ts-sdk'
 * const dispose = onMessageFlagged(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Message} has been flagged
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageFlagged = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'onMessageFlagged', 'message.flagged', filter);
};

/**
 * ```js
 * import { onMessageUnflagged } from '@amityco/ts-sdk'
 * const dispose = onMessageUnflagged(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when a flag has been removed from a {@link Amity.Message}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageUnflagged = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'onMessageUnflagged', 'message.unflagged', filter);
};

/**
 * ```js
 * import { onMessageFlagCleared } from '@amityco/ts-sdk'
 * const dispose = onMessageFlagCleared(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when flags have been cleared for a {@link Amity.Message}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageFlagCleared = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload);
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'onMessageFlagCleared', 'message.flagCleared', filter);
};

/**
 * ```js
 * import { onMessageReactionAdded } from '@amityco/ts-sdk';
 *
 * const unsubscribe = onMessageReactionAdded(message => {
 *   // ...
 * });
 * ```
 *
 * Fired when a {@link Amity.Message} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onMessageReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload, 'message.reactionAdded');
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'onMessageReactionAdded', 'message.reactionAdded', filter);
};

/**
 * ```js
 * import { onMessageReactionRemoved } from '@amityco/ts-sdk';
 *
 * const unsubscribe = onMessageReactionRemoved(message => {
 *   // ...
 * });
 * ```
 *
 * Fired when a reaction has been removed from a {@link Amity.Message}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onMessageReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = async (rawPayload) => {
        const payload = await prepareMessagePayload(rawPayload, 'message.reactionRemoved');
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'onMessageReactionRemoved', 'message.reactionRemoved', filter);
};

/**
 * ```js
 * import { onMessageFetched } from '@amityco/ts-sdk'
 * const dispose = onMessageFetched(message => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Message} has been fetched
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Message Events
 */
const onMessageFetched = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.messages[0]);
    };
    return createEventSubscriber(client, 'message/onMessageFetched', 'local.message.fetched', filter);
};

/* begin_public_function
  id: message.get
*/
/**
 * ```js
 * import { getMessage } from '@amityco/ts-sdk';
 *
 * let message;
 *
 * const unsubscribe = getMessage(messageId, response => {
 *   message = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Message}
 *
 * @param messageId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the message
 *
 * @category Message Live Object
 */
const getMessage = (messageId, callback) => {
    const responder = (snapshot) => {
        const { data } = snapshot;
        callback(Object.assign(Object.assign({}, snapshot), { data: data ? LinkedObject.message(snapshot.data) : data }));
    };
    return liveObject(messageId, responder, 'messageId', getMessage$1, [
        onMessageFetched,
        onMessageUpdated,
        onMessageDeleted,
        onMessageFlagged,
        onMessageUnflagged,
        onMessageFlagCleared,
        onMessageReactionAdded,
        onMessageReactionRemoved,
        convertEventPayload(onMessageMarkerFetched, 'contentId', 'message'),
        convertEventPayload(onMessageMarked, 'contentId', 'message'),
    ]);
};
/* end_public_function */

/* eslint-disable no-use-before-define */
class MessageQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload, paginationController) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
        this.paginationController = paginationController;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.messages.map(getResolver('message')),
                query: this.query,
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const messages = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: direction === 'next'
                    ? [...new Set([...messages, ...response.messages.map(getResolver('message'))])]
                    : [...new Set([...response.messages.map(getResolver('message')), ...messages])] }));
        }
    }
    reactor(action) {
        return (payload) => {
            var _a, _b, _c;
            if (action === 'onCreate') {
                const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                const { referenceId } = payload;
                if (!collection)
                    return;
                if (this.query.subChannelId !== (payload === null || payload === void 0 ? void 0 : payload.subChannelId) || !collection)
                    return;
                if (this.query.type && this.query.type !== payload.dataType)
                    return;
                if (this.query.excludingTags &&
                    ((_b = this.query.excludingTags) === null || _b === void 0 ? void 0 : _b.some(value => { var _a; return (_a = payload.tags) === null || _a === void 0 ? void 0 : _a.includes(value); })))
                    return;
                if (!!this.query.hasFlags !== !!payload.flagCount)
                    return;
                if (this.query.parentId && this.query.parentId !== payload.parentId)
                    return;
                if (this.query.hasOwnProperty('includeDeleted') &&
                    !this.query.includeDeleted &&
                    payload.isDeleted)
                    return;
                if (this.query.includingTags &&
                    !((_c = this.query.includingTags) === null || _c === void 0 ? void 0 : _c.some(value => { var _a; return (_a = payload.tags) === null || _a === void 0 ? void 0 : _a.includes(value); })))
                    return;
                if ((!this.query.sortBy || this.query.sortBy === 'segmentDesc') &&
                    !this.paginationController.getPrevToken()) {
                    collection.data = [...new Set([referenceId !== null && referenceId !== void 0 ? referenceId : payload.messageId, ...collection.data])];
                }
                if (this.query.sortBy === 'segmentAsc' && !this.paginationController.getNextToken()) {
                    collection.data = [...new Set([...collection.data, referenceId !== null && referenceId !== void 0 ? referenceId : payload.messageId])];
                }
                pushToCache(this.cacheKey, collection);
            }
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

/* eslint-disable no-use-before-define */
/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class MessagePaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const processedQueryParams = convertQueryParams$1(queryParams);
        const { data: queryResponse } = await this.http.get(`/api/v5/messages`, {
            params: Object.assign(Object.assign({}, processedQueryParams), { options: token
                    ? {
                        token,
                    }
                    : Object.assign({}, processedQueryParams.options) }),
        });
        return queryResponse;
    }
}

const getMessageFromMainDB = (messageId) => {
    var _a, _b;
    const message = (_a = pullFromCache(['message', 'get', messageId])) === null || _a === void 0 ? void 0 : _a.data;
    if (message)
        return message;
    const messages = queryCache(['message', 'get']);
    return (_b = messages === null || messages === void 0 ? void 0 : messages.find(({ data }) => data.messageId === messageId)) === null || _b === void 0 ? void 0 : _b.data;
};

class MessageLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['message', 'collection', queryStreamId];
        const paginationController = new MessagePaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new MessageQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareMessagePayload, this.paginationController);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onMessageCreatedMqtt, action: 'onCreate' },
            { fn: onMessageCreatedLocal, action: 'onCreate' },
            { fn: onMessageDeleted, action: 'onDelete' },
            { fn: onMessageUpdated, action: 'onUpdate' },
            { fn: onMessageFlagged, action: 'onFlagged' },
            { fn: onMessageUnflagged, action: 'onUnflagged' },
            { fn: onMessageFlagCleared, action: 'onFlagCleared' },
            { fn: onMessageReactionAdded, action: 'onReactionAdded' },
            { fn: onMessageReactionRemoved, action: 'onReactionRemoved' },
            {
                fn: convertEventPayload(onMessageMarkerFetched, 'contentId', 'message'),
                action: 'onUpdate',
            },
            { fn: convertEventPayload(onMessageMarked, 'contentId', 'message'), action: 'onUpdate' },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(messageId => getMessageFromMainDB(messageId))
            .filter(Boolean)
            .map(message => LinkedObject.message(message))) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            onPrevPage: () => this.loadPage({ direction: "prev" /* Amity.LiveCollectionPageDirection.PREV */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            hasPrevPage: !!this.paginationController.getPrevToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let messages = data;
        /*
         * for cases when message is deleted via RTE, this flag is used to get
         * items from cache that are !deleted
         */
        if (!this.query.includeDeleted) {
            messages = filterByPropEquality(messages, 'isDeleted', false);
        }
        messages = messages.sort((message1, message2) => {
            if (this.query.sortBy === 'segmentAsc') {
                return message1.channelSegment - message2.channelSegment;
            }
            if (this.query.sortBy === 'segmentDesc') {
                return message2.channelSegment - message1.channelSegment;
            }
            return 0;
        });
        return messages;
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                query: this.query,
            });
        }
    }
    async persistModel(response) {
        await this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
}

/* begin_public_function
  id: message.query
*/
/**
 * ```js
 * import { getMessages } from '@amityco/ts-sdk';
 *
 * let messages = [];
 *
 * const unsubscribe = getMessages({
 *   subChannelId: Amity.SubChannel['subChannelId'];
 * }, response => merge(messages, response.data));
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Message} for a given target object
 *
 * @param params for querying messages from a sub channel
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Messages Live Collection
 */
const getMessages = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getMessages(tmpid: ${timestamp}) > listen`);
    const messagesLiveCollection = new MessageLiveCollectionController(params, callback);
    const disposers = messagesLiveCollection.startSubscription();
    const cacheKey = messagesLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getMessages(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

var index$h = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createMessage: createMessage,
  updateMessage: updateMessage,
  editMessage: editMessage,
  deleteMessage: deleteMessage,
  softDeleteMessage: softDeleteMessage,
  markAsDelivered: markAsDelivered,
  getReadUsers: getReadUsers,
  getDeliveredUsers: getDeliveredUsers,
  flagMessage: flagMessage,
  unflagMessage: unflagMessage,
  isMessageFlaggedByMe: isMessageFlaggedByMe,
  onMessageCreatedMqtt: onMessageCreatedMqtt,
  onMessageCreatedLocal: onMessageCreatedLocal,
  onMessageUpdated: onMessageUpdated,
  onMessageDeleted: onMessageDeleted,
  onMessageFlagged: onMessageFlagged,
  onMessageUnflagged: onMessageUnflagged,
  onMessageFlagCleared: onMessageFlagCleared,
  onMessageReactionAdded: onMessageReactionAdded,
  onMessageReactionRemoved: onMessageReactionRemoved,
  onMessageFetched: onMessageFetched,
  getMessage: getMessage,
  getMessages: getMessages,
  convertFromRaw: convertFromRaw$1,
  prepareMessagePayload: prepareMessagePayload,
  convertParams: convertParams,
  convertQueryParams: convertQueryParams$1
});

/**
 * Internal used only
 *
 * Fired when an {@link Amity.userMessageFeedMarkers} has been resolved by Object Rsesolver
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category MessageMarker Events
 */
const onSubChannelUnreadUpdatedLocal = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'subChannelMarker/onSubChannelUnreadUpdatedLocal', 'local.subChannelUnread.updated', filter);
};

/* begin_public_function
  id: subchannel.get
*/
/**
 * ```js
 * import { getSubChannel } from '@amityco/ts-sdk';
 *
 * let subChannel;
 *
 * const unsubscribe = getSubChannel(subChannelId, response => {
 *   subChannel = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.SubChannel}
 *
 * @param subChannelId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the sub channel
 *
 * @category SubChannel Live Object
 */
const getSubChannel = (subChannelId, callback) => {
    const client = getActiveClient();
    let snapshot;
    const reactor = (response) => {
        if (!response.data)
            return callback(response);
        const data = Object.assign(Object.assign({}, response), { data: getSubChannelMessagePreviewWithUser(response.data) });
        const newSnapshot = __rest(data, ["origin"]);
        /**
         * check equality of previous data and current data to avoid redundancy
         * if equal, do not call the callback function
         * If not equal, assign new snapshot and return callback function
         */
        if (isEqual(snapshot, newSnapshot))
            return;
        snapshot = newSnapshot;
        return callback(data);
    };
    return liveObject(subChannelId, reactor, 'subChannelId', getSubChannel$1, [
        onSubChannelFetched,
        callback => {
            const updateMessagePreview = async (subChannel) => {
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                handleSubChannelUpdated(subChannel);
                if (subChannel.subChannelId !== subChannelId)
                    return;
                callback(subChannel);
            };
            return onSubChannelUpdated(updateMessagePreview);
        },
        onSubChannelDeleted,
        convertEventPayload(onSubChannelMarkerFetched, 'feedId', 'subChannel'),
        callback => {
            return onSubChannelMarkerUpdated(subChannelMarkers => {
                var _a;
                const isTargetSubChannel = subChannelMarkers.find(({ feedId }) => feedId === subChannelId);
                if (!isTargetSubChannel)
                    return;
                const subChannel = (_a = pullFromCache([
                    'subChannel',
                    'get',
                    subChannelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!subChannel)
                    return;
                callback(subChannel);
            });
        },
        convertEventPayload((callback) => {
            return onMessageCreatedMqtt(async (message) => {
                if (message.subChannelId !== subChannelId)
                    return;
                await handleMessageCreatedOnSubChannel(message);
                callback(message);
            });
        }, 'subChannelId', 'subChannel'),
        convertEventPayload((callback) => {
            return onMessageCreatedLocal(async (message) => {
                if (message.subChannelId !== subChannelId)
                    return;
                await handleMessageCreatedOnSubChannel(message);
                callback(message);
            });
        }, 'subChannelId', 'subChannel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                if (message.subChannelId !== subChannelId)
                    return;
                handleMessageUpdatedOnSubChannel(message);
                callback(message);
                // TODO: messageFeeds on onMessageUpdated event does not have messagePreviewId and it will save before that cause messagePreview
            };
            return onMessageUpdated(updateMessagePreview);
        }, 'subChannelId', 'subChannel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                if (message.subChannelId !== subChannelId)
                    return;
                if (messagePreviewSetting === "message-preview-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_INCLUDE_DELETED */)
                    await handleMessageUpdatedOnSubChannel(message);
                if (messagePreviewSetting ===
                    "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */) {
                    await getSubChannel$1(message.subChannelId);
                }
                callback(message);
            };
            return onMessageDeleted(updateMessagePreview);
        }, 'subChannelId', 'subChannel'),
        convertEventPayload(onSubChannelUnreadUpdatedLocal, 'subChannelId', 'subChannel'),
    ], {
        forceDispatch: true,
    });
};
/* end_public_function */

/* eslint-disable no-use-before-define */
/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class SubChannelPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        var _a;
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const _b = (_a = convertQueryParams(params)) !== null && _a !== void 0 ? _a : {}, { channelId, includeDeleted } = _b, restProcessedParams = __rest(_b, ["channelId", "includeDeleted"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v5/message-feeds/channel/${channelId}`, {
            params: Object.assign(Object.assign({}, restProcessedParams), { isDeleted: inferIsDeleted(includeDeleted), options }),
        });
        return queryResponse;
    }
}

/* eslint-disable no-use-before-define */
class SubChannelQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.messageFeeds.map(({ messageFeedId }) => messageFeedId),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const subChannels = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [
                    ...new Set([
                        ...subChannels,
                        ...response.messageFeeds.map(({ messageFeedId }) => messageFeedId),
                    ]),
                ] }));
        }
    }
    reactor(action) {
        return (payload) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (!Array.isArray(payload)) {
                if (this.query.channelId !== payload.channelId)
                    return;
                if (action === 'onCreate') {
                    collection.data = [...new Set([payload.subChannelId, ...collection.data])];
                }
                pushToCache(this.cacheKey, collection);
            }
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

/* eslint-disable no-use-before-define */
class SubChannelLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['subChannel', 'collection', queryStreamId];
        const paginationController = new SubChannelPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new SubChannelQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareSubChannelPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
            });
        }
    }
    async persistModel(response) {
        await this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onSubChannelFetched, action: 'onCreate' },
            { fn: onSubChannelCreated, action: 'onCreate' },
            { fn: onSubChannelDeleted, action: 'onDelete' },
            {
                fn: callback => {
                    return onSubChannelUpdated(async (subChannel) => {
                        if (!this.isRelatedCollection(subChannel.subChannelId))
                            return;
                        const client = getActiveClient();
                        const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                        if (messagePreviewSetting !== "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */) {
                            const messagePreview = getSubChannelMessagePreview(subChannel.subChannelId);
                            if ((messagePreview === null || messagePreview === void 0 ? void 0 : messagePreview.subChannelId) === subChannel.subChannelId &&
                                convertDateStringToTimestamp(subChannel.updatedAt) >
                                    convertDateStringToTimestamp(messagePreview.subChannelUpdatedAt)) {
                                pushToCache(['messagePreviewSubChannel', 'get', subChannel.subChannelId], Object.assign(Object.assign({}, messagePreview), { subChannelName: subChannel.displayName, subChannelUpdatedAt: subChannel.updatedAt }));
                            }
                        }
                        callback(subChannel);
                    });
                },
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload((callback) => {
                    return onMessageCreatedMqtt(async (message) => {
                        if (!this.isRelatedCollection(message.subChannelId))
                            return;
                        //  Update related cache including message preview and subChannel cache (lastActivity, messagePreviewId)
                        await handleMessageCreatedOnSubChannel(message);
                        callback(message);
                    });
                }, 'subChannelId', 'subChannel'),
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload((callback) => {
                    return onMessageCreatedLocal(async (message) => {
                        if (!this.isRelatedCollection(message.subChannelId))
                            return;
                        //  Update related cache including message preview and subChannel cache (lastActivity, messagePreviewId)
                        await handleMessageCreatedOnSubChannel(message);
                        callback(message);
                    });
                }, 'subChannelId', 'subChannel'),
                action: 'onUpdate',
            },
            {
                fn: callback => {
                    return onSubChannelMarkerUpdated((subChannelMarkers) => {
                        var _a;
                        const subChannelWithMarkerUpdated = (_a = subChannelMarkers
                            .map(({ feedId }) => pullFromCache(['subChannel', 'get', feedId]))
                            .filter(Boolean)
                            .map(({ data }) => data)) !== null && _a !== void 0 ? _a : [];
                        if (subChannelWithMarkerUpdated.length === 0)
                            return;
                        callback(subChannelWithMarkerUpdated);
                    });
                },
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload(onSubChannelMarkerFetched, 'feedId', 'subChannel'),
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        var _a;
                        const client = getActiveClient();
                        const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                        if (!collection || !collection.data.includes(message.subChannelId))
                            return;
                        handleMessageUpdatedOnSubChannel(message);
                        callback(message);
                    };
                    return onMessageUpdated(updateMessagePreview);
                }, 'subChannelId', 'subChannel'),
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        const client = getActiveClient();
                        const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        if (!this.isRelatedCollection(message.subChannelId))
                            return;
                        if (messagePreviewSetting ===
                            "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */) {
                            await getSubChannel$1(message.subChannelId);
                        }
                        else {
                            await handleMessageUpdatedOnSubChannel(message);
                        }
                        callback(message);
                    };
                    return onMessageDeleted(updateMessagePreview);
                }, 'subChannelId', 'subChannel'),
                action: 'onUpdate',
            },
            {
                fn: convertEventPayload(onSubChannelUnreadUpdatedLocal, 'subChannelId', 'subChannel'),
                action: 'onUpdate',
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(subChannelId => pullFromCache(['subChannel', 'get', subChannelId]))
            .filter(Boolean)
            .map(({ data }) => data)
            .map(getSubChannelMessagePreviewWithUser)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let subChannels = data;
        if (!this.query.includeDeleted) {
            subChannels = filterByPropEquality(data, 'isDeleted', false);
        }
        subChannels.sort(sortByLastActivity);
        return subChannels;
    }
    isRelatedCollection(subChannelId) {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        return collection && collection.data.includes(subChannelId);
    }
}

/* eslint-disable no-use-before-define */
/* begin_public_function
  id: subchannel.query
*/
/**
 * ```js
 * import { getSubChannels } from '@amityco/ts-sdk';
 *
 * let subChannels = [];
 *
 * const unsubscribe = getSubChannels({ channelId }, response => {
 *   merge(subChannels, response.data);
 * });
 * ```
 *
 * Observe all mutations on a list of {@link Amity.SubChannel}s
 *
 * @param params for querying sub channels
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the sub channels
 *
 * @category SubChannel Live Collection
 */
const getSubChannels = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    const timestamp = Date.now();
    log(`getSubChannels(tmpid: ${timestamp}) > listen`);
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const subChannelLiveCollection = new SubChannelLiveCollectionController(params, callback);
    const disposers = subChannelLiveCollection.startSubscription();
    const cacheKey = subChannelLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getSubChannels(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

const disposers = {};
const getParentChannelId = async (subChannelId) => {
    const cached = getSubChannel$1.locally(subChannelId);
    if (cached) {
        return cached.data.channelId;
    }
    const { data } = await getSubChannel$1(subChannelId);
    return data.channelId;
};
const registerTopicSubscribers = async (subChannelId) => {
    const channelId = await getParentChannelId(subChannelId);
    const markedMessageTopic = getMarkedMessageTopic({ channelId, subChannelId });
    disposers[subChannelId] = subscribeTopic(markedMessageTopic);
};
/* begin_public_function
  id: subchannel.start_message_receipt_sync
*/
/**
 * ```js
 * import { SubChannelRepository } from '@amityco/ts-sdk'
 * const success = await SubChannelRepository.startMessageReceiptSync(subChannelId)
 * ```
 *
 * Start reading a {@link Amity.SubChannel}
 *
 * @param subChannelId The {@link Amity.SubChannel} ID to start reading
 * @return true if the reading of the sub channel had begun
 *
 * @category subChannel API
 * @async
 */
const startMessageReceiptSync = async (subChannelId) => {
    await registerTopicSubscribers(subChannelId);
    return true;
};
/* end_public_function */
/* begin_public_function
  id: subchannel.stop_message_receipt_sync
*/
/**
 * ```js
 * import { SubChannelRepository } from '@amityco/ts-sdk'
 * const success = await SubChannelRepository.startMessageReceiptSync(subChannelId)
 * ```
 *
 * Start reading a {@link Amity.SubChannel}
 *
 * @param subChannelId The {@link Amity.SubChannel} ID to start reading
 * @return true if the reading of the sub channel had begun
 *
 * @category subChannel API
 * @async
 */
const stopMessageReceiptSync = (subChannelId) => {
    if (disposers[subChannelId])
        disposers[subChannelId]();
    return true;
};
/* end_public_function */

var index$g = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getSubChannelByIds: getSubChannels$1,
  createSubChannel: createSubChannel,
  updateSubChannel: updateSubChannel,
  deleteSubChannel: deleteSubChannel,
  hardDeleteSubChannel: hardDeleteSubChannel,
  softDeleteSubChannel: softDeleteSubChannel,
  onSubChannelCreated: onSubChannelCreated,
  onSubChannelUpdated: onSubChannelUpdated,
  onSubChannelDeleted: onSubChannelDeleted,
  getSubChannel: getSubChannel,
  getSubChannels: getSubChannels,
  markReadEngineOnLoginHandler: markReadEngineOnLoginHandler,
  startMessageReceiptSync: startMessageReceiptSync,
  stopMessageReceiptSync: stopMessageReceiptSync
});

/**
 * Internal used only
 *
 * Fired when an {@link Amity.channelUnreadInfo} has been updated.
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category ChannelMarker Events
 */
const onChannelUnreadInfoUpdatedLocal = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'channelMarker/onChannelUnreadInfoUpdatedLocal', 'local.channelUnreadInfo.updated', filter);
};

/**
 * Internal used only
 *
 * Fired when an {@link Amity.ChannelUnread} has been updated.
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Channel Events
 */
const onChannelUnreadUpdatedLocal = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'channel/onChannelUnreadUpdatedLocal', 'local.channelUnread.updated', filter);
};

/* begin_public_function
  id: channel.get
*/
/**
 * ```js
 * import { getChannel } from '@amityco/ts-sdk';
 *
 * let channel;
 *
 * const unsubscribe = getChannel(channelId, response => {
 *   channel = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Channel}
 *
 * @param channelId the ID of the channel to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channel
 *
 * @category Message Live Object
 */
const getChannel = (channelId, callback) => {
    const client = getActiveClient();
    let snapshot;
    const reactor = async (response) => {
        if (!response.data)
            return callback(response);
        const data = Object.assign(Object.assign({}, response), { data: constructChannelObject(response.data) });
        const newSnapshot = __rest(data, ["origin"]);
        /**
         * check equality of previous data and current data to avoid redundancy
         * if equal, do not call the callback function
         * If not equal, assign new snapshot and return callback function
         */
        if (isEqual(snapshot, newSnapshot))
            return;
        snapshot = newSnapshot;
        return callback(data);
    };
    return liveObject(channelId, reactor, 'channelId', getChannel$1, [
        onChannelUpdated,
        onChannelDeleted,
        onChannelJoined,
        onChannelLeft,
        onChannelMemberAdded,
        onChannelMemberRemoved,
        onChannelMemberBanned,
        onChannelMemberUnbanned,
        onChannelMuted,
        convertEventPayload(onChannelMarkerFetched, 'entityId', 'channel'),
        convertEventPayload(onChannelMarkerUpdated, 'entityId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                var _a;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                await handleMessageCreated(message);
                if (message.channelId !== channelId)
                    return;
                // channelId from message is channelInternalId
                const channel = (_a = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!channel)
                    return;
                updateChannelCache(channel, {
                    messagePreviewId: message.messageId,
                });
                callback(message);
            };
            return onMessageCreatedMqtt(async (message) => {
                await updateMessagePreview(message);
                callback(message);
            });
        }, 'channelId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                var _a;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                await handleMessageCreated(message);
                if (message.channelId !== channelId)
                    return;
                // channelId from message is channelInternalId
                const channel = (_a = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!channel)
                    return;
                updateChannelCache(channel, {
                    messagePreviewId: message.messageId,
                });
                callback(message);
            };
            return onMessageCreatedLocal(updateMessagePreview);
        }, 'channelId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                var _a;
                const channel = (_a = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!channel || channel.messagePreviewId !== message.messageId)
                    return;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                await handleMessageUpdated(message);
                callback(message);
            };
            return onMessageUpdated(updateMessagePreview);
        }, 'channelId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (message) => {
                var _a;
                const channel = (_a = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!channel || channel.messagePreviewId !== message.messageId)
                    return;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                if (messagePreviewSetting ===
                    "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */) {
                    dropFromCache(['messagePreviewChannel', 'get', channelId]);
                    await getChannel$1(message.channelId);
                }
                else {
                    await handleMessageUpdated(message);
                }
                callback(message);
            };
            return onMessageDeleted(updateMessagePreview);
        }, 'channelId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (subChannel) => {
                var _a, _b;
                const { channelId, subChannelId } = subChannel;
                const messagePreviewCache = (_a = pullFromCache([
                    'messagePreviewChannel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!messagePreviewCache || messagePreviewCache.subChannelId !== subChannelId)
                    return;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                await getChannel$1(channelId);
                const channel = (_b = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _b === void 0 ? void 0 : _b.data;
                if (!channel)
                    return;
                callback(subChannel);
            };
            return onSubChannelDeleted(updateMessagePreview);
        }, 'channelId', 'channel'),
        convertEventPayload((callback) => {
            const updateMessagePreview = async (subChannel) => {
                var _a, _b;
                const messagePreviewSetting = await client.getMessagePreviewSetting(false);
                if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                    return;
                handleSubChannelUpdated(subChannel);
                const messagePreviewCache = (_a = pullFromCache([
                    'messagePreviewChannel',
                    'get',
                    channelId,
                ])) === null || _a === void 0 ? void 0 : _a.data;
                if (!messagePreviewCache ||
                    messagePreviewCache.subChannelId !== subChannel.subChannelId)
                    return;
                const channel = (_b = pullFromCache([
                    'channel',
                    'get',
                    channelId,
                ])) === null || _b === void 0 ? void 0 : _b.data;
                if (!channel)
                    return;
                callback(subChannel);
            };
            return onSubChannelUpdated(updateMessagePreview);
        }, 'channelId', 'channel'),
        convertEventPayload(onSubChannelCreated, 'channelId', 'channel'),
        convertEventPayload(onChannelUnreadInfoUpdatedLocal, 'channelId', 'channel'),
        convertEventPayload(onChannelUnreadUpdatedLocal, 'channelId', 'channel'),
    ], {
        forceDispatch: true,
    });
};
/* end_public_function */

/* eslint-disable no-use-before-define */
/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class ChannelPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, displayName, membership } = queryParams, params = __rest(queryParams, ["limit", "displayName", "membership"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/channels`, {
            params: Object.assign(Object.assign({}, params), { keyword: displayName, filter: membership, options }),
        });
        return queryResponse;
    }
}

/* eslint-disable no-use-before-define */
class ChannelPaginationNoPageController extends PaginationNoPageController {
    async getRequest(queryParams) {
        const { data: queryResponse } = await this.http.get(`/api/v3/channels/list`, {
            params: Object.assign({}, queryParams),
        });
        return queryResponse;
    }
}

/* eslint-disable no-use-before-define */
class ChannelQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload, paginationController) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
        this.paginationController = paginationController;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.channels.map(getResolver('channel')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const channels = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...channels, ...response.channels.map(getResolver('channel'))])] }));
        }
    }
    reactor(action) {
        return (payload) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (this.paginationController instanceof ChannelPaginationNoPageController)
                return this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
            if ([
                "onCreate" /* Amity.ChannelActionType.OnCreate */,
                "onJoin" /* Amity.ChannelActionType.OnJoin */,
                "onResolveChannel" /* Amity.ChannelActionType.OnResolveChannel */,
            ].includes(action)) {
                if (Array.isArray(payload)) {
                    collection.data = [
                        ...new Set([...payload.map(getResolver('channel')), ...collection.data]),
                    ];
                }
                else
                    collection.data = [...new Set([payload.channelInternalId, ...collection.data])];
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

const resolveUnreadInfoOnChannelEvent = (channel) => {
    const client = getActiveClient();
    if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
        const objectResolverEngine = ObjectResolverEngine$1.getInstance();
        objectResolverEngine.resolve(channel.channelId, "userMessageFeedMarker" /* Amity.ReferenceType.USER_MESSAGE_FEED_MARKER */);
    }
};

/**
 * Internal used only
 *
 * Fired when any {@link Amity.Channel} have been resolved by Object resolver
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Channel Events
 */
const onChannelResolved = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'onChannelResolved', 'local.channel.resolved', filter);
};

/**
 * Internal used only
 *
 * Fired when an {@link Amity.userMessageFeedMarkers} has been resolved by Object Rsesolver
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category MessageMarker Events
 */
const onUserMessageFeedMarkerResolved = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'userMessageFeedMarker/onUserMessageFeedMarkerResolved', 'local.userMessageFeedMarkers.resolved', filter);
};

/* eslint-disable no-use-before-define */
class ChannelLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['channel', 'collection', queryStreamId];
        const paginationController = ChannelLiveCollectionController.getPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new ChannelQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), async (channel) => {
            try {
                const client = getActiveClient();
                if (client.isUnreadCountEnabled && client.getMarkerSyncConsistentMode()) {
                    await prepareUnreadCountInfo(channel);
                }
            }
            catch (e) {
                console.error('Error while preparing unread count info', e);
            }
            return prepareChannelPayload(channel);
        }, paginationController);
        this.paginationController = paginationController;
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(response) {
        await this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE(this.getSubscriptions());
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        let data = (_b = collection.data
            .map(channelId => pullFromCache(['channel', 'get', channelId]))
            .filter(Boolean)
            .map(({ data }) => data)
            .map(constructChannelObject)) !== null && _b !== void 0 ? _b : [];
        if (this.paginationController instanceof ChannelPaginationController) {
            data = this.applyFilter(data);
        }
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: this.paginationController instanceof ChannelPaginationController
                ? () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ })
                : undefined,
            data,
            hasNextPage: this.paginationController instanceof ChannelPaginationController
                ? !!this.paginationController.getNextToken()
                : false,
            loading,
            error,
        });
    }
    applyFilter(data) {
        const { userId } = getActiveClient();
        let channels = data;
        channels = filterByPropEquality(channels, 'isDeleted', this.query.isDeleted);
        channels = filterByStringComparePartially(channels, 'displayName', this.query.displayName);
        if (this.query.types) {
            channels = channels.filter(c => { var _a; return (_a = this.query.types) === null || _a === void 0 ? void 0 : _a.includes(c.type); });
        }
        if (this.query.tags) {
            channels = channels.filter(c => { var _a; return (_a = c.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.tags) === null || _a === void 0 ? void 0 : _a.includes(t); }); });
        }
        if (this.query.excludeTags) {
            channels = channels.filter(c => { var _a; return !((_a = c.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.excludeTags) === null || _a === void 0 ? void 0 : _a.includes(t); })); });
        }
        // userId is required to be able to filter channel by current active user
        if (this.query.membership && userId) {
            channels = filterByChannelMembership(channels, this.query.membership, userId);
        }
        switch (this.query.sortBy) {
            case 'firstCreated':
                channels = channels.sort(sortByFirstCreated);
                break;
            case 'lastCreated':
                channels = channels.sort(sortByLastCreated);
                break;
            case 'displayName':
                /*
                 * The server returns channels with empty | null displayName's first before
                 * returning sorted list of channels with displayNames
                 *
                 * This section needs to be updated as displayNames can be null as well
                 */
                channels = channels
                    // this needs to be aligned with the backend data type
                    .map(c => (c.displayName ? c : Object.assign(Object.assign({}, c), { displayName: '' })))
                    .sort(sortByDisplayName);
                break;
            default:
                channels = channels.sort(sortByLastActivity);
                break;
        }
        return channels;
    }
    shouldAbort(targetChannelId) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return true;
        const channelId = (_b = collection === null || collection === void 0 ? void 0 : collection.data) === null || _b === void 0 ? void 0 : _b.find(channel => channel === targetChannelId);
        return !channelId;
    }
    static getMessagePreviewSetting() {
        const client = getActiveClient();
        return client.getMessagePreviewSetting(false);
    }
    static getPaginationController(query) {
        if (query.channelIds && query.channelIds.length > 0) {
            return new ChannelPaginationNoPageController(query);
        }
        return new ChannelPaginationController(query);
    }
    getSubscriptions() {
        const subscriptions = [
            {
                fn: convertEventPayload((callback) => {
                    return onMessageCreatedMqtt(message => {
                        var _a, _b;
                        const objectResolverEngine = ObjectResolverEngine$1.getInstance();
                        const cachedSubChannelUnread = (_a = pullFromCache([
                            'subChannelUnreadInfo',
                            'get',
                            message.subChannelId,
                        ])) === null || _a === void 0 ? void 0 : _a.data;
                        if (!cachedSubChannelUnread)
                            objectResolverEngine.resolve(message.subChannelId, "userMessageFeedMarker" /* Amity.ReferenceType.USER_MESSAGE_FEED_MARKER */);
                        const channelCache = (_b = pullFromCache([
                            'channel',
                            'get',
                            message.channelId,
                        ])) === null || _b === void 0 ? void 0 : _b.data;
                        if (!channelCache) {
                            // channelId from message event payload is channelInternalId
                            objectResolverEngine.resolve(message.channelId, "channel" /* Amity.ReferenceType.CHANNEL */);
                        }
                        else {
                            updateChannelCache(channelCache, {
                                lastActivity: message.createdAt,
                            });
                            callback(message);
                        }
                    });
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    return onMessageCreatedLocal(message => {
                        var _a;
                        const cacheData = (_a = pullFromCache([
                            'channel',
                            'get',
                            message.channelId,
                        ])) === null || _a === void 0 ? void 0 : _a.data;
                        if (!cacheData)
                            return;
                        updateChannelCache(cacheData, {
                            lastActivity: message.createdAt,
                        });
                        callback(message);
                    });
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            { fn: onChannelDeleted, action: "onDelete" /* Amity.ChannelActionType.OnDelete */ },
            { fn: onChannelUpdated, action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */ },
            { fn: onChannelMuted, action: "onMute" /* Amity.ChannelActionType.OnMute */ },
            {
                fn: (callback) => {
                    return onChannelJoined(channel => {
                        resolveUnreadInfoOnChannelEvent(channel);
                        callback(channel);
                    });
                },
                action: "onJoin" /* Amity.ChannelActionType.OnJoin */,
            },
            {
                fn: (reactor) => {
                    const callback = (channel, member) => {
                        var _a, _b;
                        const { userId } = getActiveClient();
                        // if query for channel member and user is not a member, remove channelId from curren collection
                        if (this.query.membership === 'member' && userId === member.userId) {
                            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: (_b = collection === null || collection === void 0 ? void 0 : collection.data.filter(c => c !== channel.channelId)) !== null && _b !== void 0 ? _b : [] }));
                        }
                        return reactor(channel);
                    };
                    return onChannelLeft(callback);
                },
                action: "onLeft" /* Amity.ChannelActionType.OnLeft */,
            },
            { fn: onChannelMemberAdded, action: "onMemberAdded" /* Amity.ChannelActionType.OnMemberAdded */ },
            { fn: onChannelMemberRemoved, action: "onMemberRemoved" /* Amity.ChannelActionType.OnMemberRemoved */ },
            {
                fn: convertEventPayload(onChannelMarkerFetched, 'entityId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload(onChannelMarkerUpdated, 'entityId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        var _a;
                        const messagePreviewSetting = await ChannelLiveCollectionController.getMessagePreviewSetting();
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        handleMessageCreated(message);
                        if (this.shouldAbort(message.channelId))
                            return;
                        const channel = (_a = pullFromCache([
                            'channel',
                            'get',
                            message.channelId,
                        ])) === null || _a === void 0 ? void 0 : _a.data;
                        if (!channel)
                            return;
                        updateChannelCache(channel, {
                            messagePreviewId: message.messageId,
                        });
                        callback(message);
                    };
                    return onMessageCreatedMqtt(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        var _a;
                        const messagePreviewSetting = await ChannelLiveCollectionController.getMessagePreviewSetting();
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        handleMessageCreated(message);
                        if (this.shouldAbort(message.channelId))
                            return;
                        const channel = (_a = pullFromCache([
                            'channel',
                            'get',
                            message.channelId,
                        ])) === null || _a === void 0 ? void 0 : _a.data;
                        if (!channel)
                            return;
                        updateChannelCache(channel, {
                            messagePreviewId: message.messageId,
                        });
                        callback(message);
                    };
                    return onMessageCreatedLocal(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        const messagePreviewSetting = await ChannelLiveCollectionController.getMessagePreviewSetting();
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        handleMessageUpdated(message);
                        if (this.shouldAbort(message.channelId))
                            return;
                        callback(message);
                    };
                    return onMessageUpdated(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (message) => {
                        const messagePreviewSetting = await ChannelLiveCollectionController.getMessagePreviewSetting();
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        if (messagePreviewSetting ===
                            "message-preview-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_INCLUDE_DELETED */)
                            await handleMessageUpdated(message);
                        if (this.shouldAbort(message.channelId))
                            return;
                        if (messagePreviewSetting ===
                            "message-preview-not-include-deleted" /* Amity.MessagePreviewSetting.MESSAGE_PREVIEW_NOT_INCLUDE_DELETED */) {
                            await getChannel$1(message.channelId);
                        }
                        callback(message);
                    };
                    return onMessageDeleted(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (subChannel) => {
                        var _a;
                        const collections = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                        if (!collections)
                            return;
                        const channelId = collections.data.find(channel => {
                            const messagePreviewCache = getChannelMessagePreview(channel);
                            return (messagePreviewCache === null || messagePreviewCache === void 0 ? void 0 : messagePreviewCache.subChannelId) === subChannel.subChannelId;
                        });
                        if (!channelId)
                            return;
                        await getChannel$1(subChannel.channelId);
                        callback(subChannel);
                    };
                    return onSubChannelDeleted(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload((callback) => {
                    const updateMessagePreview = async (subChannel) => {
                        var _a;
                        const messagePreviewSetting = await ChannelLiveCollectionController.getMessagePreviewSetting();
                        if (messagePreviewSetting === "no-message-preview" /* Amity.MessagePreviewSetting.NO_MESSAGE_PREVIEW */)
                            return;
                        const collections = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                        if (!collections)
                            return;
                        await handleSubChannelUpdated(subChannel);
                        if (this.shouldAbort(subChannel.channelId))
                            return;
                        callback(subChannel);
                    };
                    return onSubChannelUpdated(updateMessagePreview);
                }, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload(onSubChannelCreated, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: onChannelResolved,
                action: "onResolveChannel" /* Amity.ChannelActionType.OnResolveChannel */,
            },
            {
                fn: (callback) => {
                    const handleUserFeedMarkerResolved = async (marker) => {
                        if (marker.feedMarkers) {
                            const channels = marker.feedMarkers
                                .map(feedMarker => {
                                var _a;
                                return (_a = pullFromCache([
                                    'channel',
                                    'get',
                                    feedMarker.entityId,
                                ])) === null || _a === void 0 ? void 0 : _a.data;
                            })
                                .filter(Boolean);
                            callback(channels);
                        }
                    };
                    return onUserMessageFeedMarkerResolved(handleUserFeedMarkerResolved);
                },
                action: "OnResolveUnread" /* Amity.ChannelActionType.OnResolveUnread */,
            },
            {
                fn: convertEventPayload(onChannelUnreadInfoUpdatedLocal, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
            {
                fn: convertEventPayload(onChannelUnreadUpdatedLocal, 'channelId', 'channel'),
                action: "onUpdate" /* Amity.ChannelActionType.OnUpdate */,
            },
        ];
        if (this.paginationController instanceof PaginationController) {
            return [
                ...subscriptions,
                {
                    fn: (callback) => {
                        return onChannelCreated(channel => {
                            resolveUnreadInfoOnChannelEvent(channel);
                            callback(channel);
                        });
                    },
                    action: "onCreate" /* Amity.ChannelActionType.OnCreate */,
                },
            ];
        }
        return subscriptions;
    }
}

/* eslint-disable no-use-before-define */
/* begin_public_function
  id: channel.query
*/
/**
 * ```js
 * import { getChannels } from '@amityco/ts-sdk'
 *
 * let channels = []
 * const unsub = getChannels({
 *   displayName: Amity.Channel['displayName'],
 * }, response => merge(channels, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Channel}s
 *
 * @param params for querying channels
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channels
 *
 * @category Channel Live Collection
 */
const getChannels = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getChannels(tmpid: ${timestamp}) > listen`);
    const channelLiveCollection = new ChannelLiveCollectionController(params, callback);
    const disposers = channelLiveCollection.startSubscription();
    const cacheKey = channelLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getChannels(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/**
 *
 * Calculate user unread from {@link Amity.ChannelUnread} objects
 *
 * @returns the {@link Amity.UserUnread} objects
 *
 * @category Channel API
 * @async
 */
const getTotalChannelsUnread$1 = () => {
    var _a;
    const client = getActiveClient();
    client.log('channel/getTotalChannelsUnread.locally');
    const cachedChannelsUnread = ((_a = queryCache(['channelUnread', 'get'])) === null || _a === void 0 ? void 0 : _a.filter(({ data }) => {
        return !data.isDeleted;
    })) || [];
    const totalChannelsUnread = (cachedChannelsUnread === null || cachedChannelsUnread === void 0 ? void 0 : cachedChannelsUnread.reduce((acc, { data }) => {
        acc.unreadCount += data.unreadCount;
        acc.isMentioned = acc.isMentioned || data.isMentioned;
        return acc;
    }, { unreadCount: 0, isMentioned: false })) || { unreadCount: 0, isMentioned: false };
    const cachedAt = client.cache && Date.now();
    return {
        data: totalChannelsUnread,
        cachedAt,
    };
};

/* begin_public_function
  id: totalChannelsUnread.get
*/
/**
 * ```js
 * import { ChannelRepository } from '@amityco/ts-sdk';
 *
 * let totalChannelsUnread;
 *
 * const unsubscribe = ChannelRepository.getTotalChannelsUnread(response => {
 *   unread = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.UserUnread}
 *
 * @returns An {@link Amity.UserUnread} function to run when willing to stop observing the message
 *
 * @category User Unread Live Object
 *
 */
const getTotalChannelsUnread = (callback) => {
    const { _id: userId } = getActiveUser();
    if (!userId)
        throw new ASCError('The _id has not been defined in ActiveUser', 800000 /* Amity.ClientError.UNKNOWN_ERROR */, "error" /* Amity.ErrorLevel.ERROR */);
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log('For using Live Object feature you need to enable Cache!');
    }
    const timestamp = Date.now();
    log(`liveTotalChannelsUnread(tmpid: ${timestamp}) > listen`);
    const disposers = [];
    let isUnsyncedModel = false; // for messages
    let model;
    const dispatcher = (data) => {
        const { data: userUnread } = data;
        const callbackModel = userUnread
            ? {
                unreadCount: userUnread.unreadCount,
                isMentioned: userUnread.isMentioned,
            }
            : undefined;
        model = callbackModel ? convertGetterPropsToStatic(callbackModel) : callbackModel;
        callback({
            data: callbackModel
                ? Object.assign(Object.assign({}, callbackModel), { isMentioned: callbackModel.isMentioned }) : callbackModel,
            loading: data.loading,
            error: data.error,
        });
    };
    const realtimeRouter = (userUnread) => {
        if (isEqual(model, userUnread))
            return;
        dispatcher({
            loading: false,
            data: userUnread,
        });
    };
    const onFetch = () => {
        const query = createQuery(async () => getTotalChannelsUnread$1());
        runQuery(query, ({ error, data, loading, origin, cachedAt }) => {
            if (cachedAt === UNSYNCED_OBJECT_CACHED_AT_VALUE) {
                dispatcher({
                    data,
                    origin,
                    loading: false,
                    error: new ASCApiError(UNSYNCED_OBJECT_CACHED_AT_MESSAGE, 800800 /* Amity.ClientError.DISALOOW_UNSYNCED_OBJECT */, "error" /* Amity.ErrorLevel.ERROR */),
                });
                isUnsyncedModel = true;
                disposers.forEach(fn => fn());
            }
            else if (!isUnsyncedModel) {
                dispatcher({ loading, data, origin, error });
            }
            if (error) {
                disposers.forEach(fn => fn());
            }
        });
    };
    disposers.push(onChannelUnreadUpdatedLocal(realtimeRouter));
    onFetch();
    return () => {
        disposers.forEach(fn => fn());
    };
};

/* begin_public_function
  id: channel.member.add
*/
/**
 * ```js
 * import { addMembers } from '@amityco/ts-sdk'
 * const updated = await addMembers(channelId, ['foo', 'bar'])
 * ```
 *
 * Adds a list of {@link Amity.InternalUser} to a {@link Amity.Channel}
 *
 * @param channelId The ID of the {@link Amity.Channel} to perform
 * @param userIds The list of IDs {@link Amity.InternalUser} to add
 * @returns A success boolean if the {@link Amity.InternalUser} were added to the {@link Amity.Channel}
 *
 * @category Channel API
 * @async
 */
const addMembers$1 = async (channelId, userIds) => {
    const client = getActiveClient();
    client.log('channel/addMembers', channelId, userIds);
    const { data: payload } = await client.http.post(`/api/v3/channels/${encodeURIComponent(channelId)}/users`, { channelId, userIds });
    /*
     * should fire event for each user that was added
     */
    userIds.forEach(id => fireEvent('channel.membersAdded', Object.assign(Object.assign({}, payload), { channelUsers: payload.channelUsers.filter(u => u.userId === id) })));
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && channelUser.membership === 'member');
};
/* end_public_function */

/* begin_public_function
  id: channel.member.remove
*/
/**
 * ```js
 * import { removeMembers } from '@amityco/ts-sdk'
 * const updated = await removeMembers(channelId, ['foo', 'bar'])
 * ```
 *
 * Removes a list of {@link Amity.InternalUser} from a {@link Amity.Channel}
 *
 * @param channelId The ID of the {@link Amity.Channel} to perform
 * @param userIds The list of IDs {@link Amity.InternalUser} to remove
 * @returns A success boolean if the list of {@link Amity.InternalUser} were removed from the {@link Amity.Channel}
 *
 * @category Channel API
 * @async
 */
const removeMembers$1 = async (channelId, userIds) => {
    const client = getActiveClient();
    client.log('channel/removeMembers', channelId, userIds);
    const { data: payload } = await client.http.delete(`/api/v3/channels/${encodeURIComponent(channelId)}/users`, { data: { channelId, userIds } });
    /*
     * should fire event for each user that was removed
     */
    userIds.forEach(id => fireEvent('channel.membersRemoved', Object.assign(Object.assign({}, payload), { channelUsers: payload.channelUsers.filter(u => u.userId === id) })));
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && channelUser.membership !== 'member');
};
/* end_public_function */

/* eslint-disable no-use-before-define */
/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class ChannelMemberPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, includeDeleted } = queryParams, params = __rest(queryParams, ["limit", "includeDeleted"]);
        const options = token ? { token } : { limit };
        const isDeleted = includeDeleted === false ? false : undefined;
        const { data: queryResponse } = await this.http.get(`/api/v4/channels/${encodeURIComponent(params.channelId)}/users`, {
            params: Object.assign(Object.assign({}, params), { options,
                isDeleted }),
        });
        return queryResponse;
    }
}

/* eslint-disable no-use-before-define */
class ChannelMemberQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.channelUsers.map(({ channelId, userId }) => getResolver('channelUsers')({ channelId, userId })),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const channelUsers = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [
                    ...new Set([
                        ...channelUsers,
                        ...response.channelUsers.map(({ channelId, userId }) => getResolver('channelUsers')({ channelId, userId })),
                    ]),
                ] }));
        }
    }
    reactor(action) {
        return (channel, channelMember) => {
            var _a;
            if (this.query.channelId !== channelMember.channelId)
                return;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            const channelMemberCacheId = getResolver('channelUsers')({
                channelId: this.query.channelId,
                userId: channelMember.userId,
            });
            if (channelMember.membership === 'none') {
                collection.data = collection.data.filter(m => m !== channelMemberCacheId);
            }
            else if (!collection.data.includes(channelMemberCacheId)) {
                collection.data = [channelMemberCacheId, ...collection.data];
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

const onUserDeleted$1 = (channelId) => (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a, _b;
        const userPayload = prepareUserPayload(payload);
        if (userPayload.users.length === 0)
            return;
        const user = userPayload.users[0];
        ingestInCache(userPayload);
        const channelUserCacheKey = getResolver('channelUsers')({
            channelId,
            userId: user.userId,
        });
        const cacheData = (_a = pullFromCache([
            'channelUsers',
            'get',
            channelUserCacheKey,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        upsertInCache(['channelUsers', 'get', channelUserCacheKey], Object.assign(Object.assign({}, cacheData), { user }));
        const channel = (_b = pullFromCache([
            'channel',
            'get',
            channelId,
        ])) === null || _b === void 0 ? void 0 : _b.data;
        if (!channel)
            return;
        callback(channel, cacheData);
    };
    return createEventSubscriber(client, 'user.deleted', 'user.deleted', filter);
};

/* eslint-disable no-use-before-define */
class ChannelMemberLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['channelUsers', 'collection', queryStreamId];
        const paginationController = new ChannelMemberPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new ChannelMemberQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareChannelPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onChannelJoined, action: 'onJoin' },
            { fn: onChannelLeft, action: 'onLeft' },
            { fn: onChannelMemberAdded, action: 'onMemberAdded' },
            { fn: onChannelMemberRemoved, action: 'onMemberRemoved' },
            { fn: onChannelMemberBanned, action: 'onChannelMemberBanned' },
            { fn: onChannelMemberUnbanned, action: 'onChannelMemberUnbanned' },
            { fn: onChannelMemberRoleAdded, action: 'onChannelMemberRoleAdded' },
            { fn: onChannelMemberRoleRemoved, action: 'onChannelMemberRoleRemoved' },
            { fn: onUserDeleted$1(this.query.channelId), action: 'onChannelMemberChanged' },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['channelUsers', 'get', id]))
            .filter(Boolean)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let channelMembers = filterByPropIntersection(data, 'roles', this.query.roles);
        if (this.query.memberships) {
            /*
             * even though membership includes muted as a possible value
             * when querying the server.
             * Muted is specified under seperarte property namely isMuted
             * Hence why I've seperately checked for it's equality
             */
            channelMembers = channelMembers.filter(member => {
                var _a, _b;
                if (((_a = this.query.memberships) === null || _a === void 0 ? void 0 : _a.includes('muted')) && member.isMuted) {
                    return true;
                }
                if (member.membership !== 'none') {
                    return (_b = this.query.memberships) === null || _b === void 0 ? void 0 : _b.includes(member.membership);
                }
                return false;
            });
        }
        if (this.query.includeDeleted === false) {
            channelMembers = channelMembers.filter(member => { var _a; return ((_a = member.user) === null || _a === void 0 ? void 0 : _a.isDeleted) !== true; });
        }
        // sort, 'lastCreated' is the default sort order
        const sortBy = this.query.sortBy ? this.query.sortBy : 'lastCreated';
        channelMembers = channelMembers.sort(sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);
        return channelMembers;
    }
}

/* eslint-disable no-use-before-define */
/*
 * Exported for testing
 * @hidden
 */
const applyFilter$1 = (data, params) => {
    let channelMembers = filterByPropIntersection(data, 'roles', params.roles);
    if (params.memberships) {
        /*
         * even though membership includes muted as a possible value
         * when querying the server.
         * Muted is specified under seperarte property namely isMuted
         * Hence why I've seperately checked for it's equality
         */
        channelMembers = channelMembers.filter(member => {
            // @ts-ignore
            if (params.memberships.includes('muted') && member.isMuted) {
                return true;
            }
            // @ts-ignore
            return params.memberships.includes(member.membership);
        });
    }
    // sort, 'lastCreated' is the default sort order
    const sortBy = params.sortBy ? params.sortBy : 'lastCreated';
    channelMembers = channelMembers.sort(sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);
    return channelMembers;
};
/* begin_public_function
  id: channel.member.query
*/
/**
 * ```js
 * import { getMembers } from '@amityco/ts-sdk'
 *
 * let channelMembers = []
 * const unsub = getMembers({
 *   channelId: Amity.Channel['channelId'],
 * }, response => merge(channelMembers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.ChannelUser}s
 *
 * @param params for querying channel users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channel users
 *
 * @category Channel Live Collection
 */
const getMembers$1 = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        // eslint-disable-next-line no-console
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getMembers(tmpid: ${timestamp}) > listen`);
    const channelMemberLiveCollection = new ChannelMemberLiveCollectionController(params, callback);
    const disposers = channelMemberLiveCollection.startSubscription();
    const cacheKey = channelMemberLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getMembers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/* eslint-disable no-use-before-define */
/* begin_public_function
  id: channel.member.search
*/
/**
 * ```js
 * import { ChannelRepository } from '@amityco/ts-sdk'
 *
 * let channelMembers = []
 * const unsub = ChannelRepository.Membership.searchMembers({
 *   channelId: Amity.Channel['channelId'],
 * }, response => merge(channelMembers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.ChannelUser}s
 *
 * @param params for searching channel users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the channel users
 *
 * @category Channel Live Collection
 */
const searchMembers$1 = (params, callback, config) => {
    return getMembers$1(params, callback);
};
/* end_public_function */

var index$f = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addMembers: addMembers$1,
  removeMembers: removeMembers$1,
  applyFilter: applyFilter$1,
  getMembers: getMembers$1,
  searchMembers: searchMembers$1
});

/* begin_public_function
  id: channel.moderation.add_roles
*/
/**
 * ```js
 * import { addRole } from '@amityco/ts-sdk'
 * const updated = await addRole(channelId, 'foo', ['bar'])
 * ```
 *
 * Adds an {@link Amity.Role} to a list of {@link Amity.InternalUser} on a {@link Amity.Channel}
 *
 * @param channelId The ID of the {@link Amity.Channel} to perform
 * @param roleId The ID of the {@link Amity.Role} to apply
 * @param userId Array of IDs of the {@link Amity.InternalUser} to perform
 * @returns A success boolean if the {@link Amity.Role} were added to list of {@link Amity.InternalUser} in the {@link Amity.Channel}
 *
 * @category Channel API
 * @async
 */
const addRole = async (channelId, roleId, userIds) => {
    const client = getActiveClient();
    client.log('channel/addRole', channelId, roleId, userIds);
    const { data: payload } = await client.http.post(`/api/v3/channels/${encodeURIComponent(channelId)}/users/roles`, { channelId, role: roleId, userIds });
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    fireEvent('local.channel-moderator.role-added', data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && channelUser.roles.includes(roleId));
};
/* end_public_function */

/* begin_public_function
  id: channel.moderation.remove_roles
*/
/**
 * ```js
 * import { removeRole } from '@amityco/ts-sdk'
 * const updated = await removeRole(channelId, 'foo', ['bar'])
 * ```
 *
 * Removes an {@link Amity.Role} from a list of {@link Amity.InternalUser} on a {@link Amity.Channel}
 *
 * @param channelId The ID of the {@link Amity.Channel} to perform
 * @param roleId The ID of the {@link Amity.Role} to apply
 * @param userIds Array of IDs of the {@link Amity.InternalUser} to perform
 * @returns A success boolean if the {@link Amity.Role} were removed from list of {@link Amity.InternalUser} in the {@link Amity.Channel}
 *
 * @category Channel API
 * @async
 */
const removeRole = async (channelId, roleId, userIds) => {
    const client = getActiveClient();
    client.log('channel/removeRole', channelId, roleId, userIds);
    const { data: payload } = await client.http.delete(`/api/v3/channels/${encodeURIComponent(channelId)}/users/roles`, { data: { channelId, role: roleId, userIds } });
    const data = await prepareChannelPayload(payload);
    if (client.cache)
        ingestInCache(data);
    fireEvent('local.channel-moderator.role-removed', data);
    const { channelUsers } = data;
    return !!channelUsers.find(channelUser => channelUser.channelId === channelId && !channelUser.roles.includes(roleId));
};
/* end_public_function */

/* begin_public_function
  id: channel.moderation.ban_members
*/
/**
 * ```js
 * import { banMembers } from '@amityco/ts-sdk'
 *
 * await banMembers('channel-id-1', ['userId1', 'userId2'])
 * ```
 *
 * @param channelId of {@link Amity.Channel} from which the users should be banned
 * @param userIds of the {@link Amity.InternalUser}'s to be banned
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Channel API
 * @async
 * */
const banMembers$1 = async (channelId, userIds) => {
    const client = getActiveClient();
    client.log('channel/banMembers', { userIds, channelId });
    const { data: payload } = await client.http.put(`/api/v3/channels/${channelId}/users/ban`, {
        userIds,
    });
    const preparedPayload = await prepareChannelPayload(payload);
    const { channelUsers } = preparedPayload;
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(preparedPayload, { cachedAt });
    return {
        data: channelUsers === null || channelUsers === void 0 ? void 0 : channelUsers.filter(user => user.membership === 'banned'),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: channel.moderation.unban_members
*/
/**
 * ```js
 * import { unbanMembers } from '@amityco/ts-sdk'
 *
 * await unbanMembers('channel-id-1', ['userId1', 'userId2'])
 * ```
 *
 * @param channelId of {@link Amity.Channel} where the users should be unbanned
 * @param userIds of the {@link Amity.InternalUser}'s to be unbanned
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Channel API
 * @async
 * */
const unbanMembers$1 = async (channelId, userIds) => {
    const client = getActiveClient();
    client.log('channel/unbanMembers', { userIds, channelId });
    const { data: payload } = await client.http.put(`/api/v3/channels/${encodeURIComponent(channelId)}/users/unban`, {
        userIds,
    });
    const preparedPayload = await prepareChannelPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(preparedPayload, { cachedAt });
    const { channelUsers } = preparedPayload;
    return {
        data: channelUsers === null || channelUsers === void 0 ? void 0 : channelUsers.filter(user => user.membership === 'member'),
        cachedAt,
    };
};
/* end_public_function */

const MUTE_FOREVER = -1;
/* begin_public_function
  id: channel.moderation.mute_members
*/
/**
 * ```js
 * import { muteMembers } from '@amityco/ts-sdk'
 *
 * await muteMembers('channel-id-1', ['userId1', 'userId2'], 10)
 * ```
 *
 * @param channelId of {@link Amity.Channel} from which the users should be muted
 * @param userIds of the {@link Amity.InternalUser}'s to be muted
 * @param period to be muted in seconds
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Channel API
 * @async
 * */
const muteMembers = async (channelId, userIds, mutePeriod = MUTE_FOREVER) => {
    const client = getActiveClient();
    client.log('channel/muteMembers', { userIds, channelId, mutePeriod });
    const { data } = await client.http.put(`/api/v2/channel/${channelId}/users/mute`, {
        userIds,
        mutePeriod: mutePeriod === MUTE_FOREVER ? mutePeriod : mutePeriod * 1000,
    });
    const { success } = data;
    return success;
};
/* end_public_function */

/* begin_public_function
  id: channel.moderation.unban_members
*/
/**
 * ```js
 * import { unbanMembers } from '@amityco/ts-sdk'
 *
 * await unbanMembers('channel-id-1', ['userId1', 'userId2'])
 * ```
 *
 * @param channelId of {@link Amity.Channel} where the users should be unbanned
 * @param userIds of the {@link Amity.InternalUser}'s to be unbanned
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Channel API
 * @async
 * */
const unmuteMembers = async (channelId, userIds) => {
    const client = getActiveClient();
    client.log('channel/unmuteMembers', { userIds, channelId });
    const { data } = await client.http.put(`/api/v2/channel/${encodeURIComponent(channelId)}/users/mute`, {
        userIds,
        mutePeriod: 0,
    });
    const { success } = data;
    return success;
};
/* end_public_function */

var index$e = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addRole: addRole,
  removeRole: removeRole,
  banMembers: banMembers$1,
  unbanMembers: unbanMembers$1,
  muteMembers: muteMembers,
  unmuteMembers: unmuteMembers
});

var index$d = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Membership: index$f,
  Moderation: index$e,
  getChannelByIds: getChannelByIds$1,
  createChannel: createChannel,
  updateChannel: updateChannel,
  deleteChannel: deleteChannel,
  joinChannel: joinChannel,
  leaveChannel: leaveChannel,
  muteChannel: muteChannel,
  unmuteChannel: unmuteChannel,
  onChannelCreated: onChannelCreated,
  onChannelUpdated: onChannelUpdated,
  onChannelDeleted: onChannelDeleted,
  onChannelJoined: onChannelJoined,
  onChannelLeft: onChannelLeft,
  onChannelMuted: onChannelMuted,
  onChannelMemberAdded: onChannelMemberAdded,
  onChannelMemberRemoved: onChannelMemberRemoved,
  onChannelMemberBanned: onChannelMemberBanned,
  onChannelMemberUnbanned: onChannelMemberUnbanned,
  onChannelMemberRoleAdded: onChannelMemberRoleAdded,
  onChannelMemberRoleRemoved: onChannelMemberRoleRemoved,
  getChannel: getChannel,
  getChannels: getChannels,
  getTotalChannelsUnread: getTotalChannelsUnread,
  MARKER_INCLUDED_CHANNEL_TYPE: MARKER_INCLUDED_CHANNEL_TYPE,
  isUnreadCountSupport: isUnreadCountSupport,
  convertFromRaw: convertFromRaw,
  preUpdateChannelCache: preUpdateChannelCache,
  prepareChannelPayload: prepareChannelPayload
});

const saveCommunityUsers = (communities, communityUsers) => {
    if (communities.length === 0 || communityUsers.length === 0)
        return;
    communities.forEach(({ communityId }) => {
        const collection = communityUsers.filter(({ communityId: userCommunityId }) => communityId === userCommunityId);
        pushToCache(['communityUsers', 'collection', communityId], collection);
    });
};

/**
 * ```js
 * import { getCommunities } from '@amityco/ts-sdk'
 * const communities = await getCommunities(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Community} objects
 *
 * @param communityIds the IDs of the {@link Amity.Community} to fetch
 * @returns the associated collection of {@link Amity.Community} objects
 *
 * @category Community API
 * @async
 */
const getCommunities$1 = async (communityIds) => {
    const client = getActiveClient();
    client.log('community/getCommunities', communityIds);
    // API-FIX: endpoint should not be /list, parameters should be querystring.
    const { data: payload } = await client.http.get(`/api/v3/communities/list`, {
        params: { communityIds },
    });
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
        saveCommunityUsers(data.communities, data.communityUsers);
    }
    return {
        data: data.communities,
        cachedAt,
    };
};
/**
 * ```js
 * import { getCommunities } from '@amityco/ts-sdk'
 * const communities = getCommunities.locally(['foo', 'bar']) ?? []
 * ```
 *
 * Fetches a collection of {@link Amity.Community} objects from cache
 *
 * @param communityIds the IDs of the {@link Amity.Community} to fetch
 * @returns the associated collection of {@link Amity.Community} objects
 *
 * @category Community API
 */
getCommunities$1.locally = (communityIds) => {
    var _a;
    const client = getActiveClient();
    client.log('community/getCommunities.locally', communityIds);
    if (!client.cache)
        return;
    const cached = communityIds
        .map(communityId => pullFromCache(['community', 'get', communityId]))
        .filter(Boolean);
    const communities = cached.map(({ data }) => data);
    const oldest = (_a = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _a === void 0 ? void 0 : _a[0];
    if ((cached === null || cached === void 0 ? void 0 : cached.length) < communityIds.length)
        return;
    return {
        data: communities,
        cachedAt: oldest.cachedAt,
    };
};

/* begin_public_function
  id: community.create
*/
/**
 * ```js
 * import { createCommunity } from '@amityco/ts-sdk'
 * const created = await createCommunity({ communityId: 'foobar', displayName: 'foobar' })
 * ```
 *
 * Creates an {@link Amity.Community}
 *
 * @param bundle The data necessary to create a new {@link Amity.Community}
 * @returns The newly created {@link Amity.Community}
 *
 * @category Community API
 * @async
 */
const createCommunity = async (bundle) => {
    const client = getActiveClient();
    client.log('user/createCommunity', bundle);
    const { data: payload } = await client.http.post('/api/v3/communities/', prepareCommunityRequest(bundle));
    fireEvent('community.created', payload);
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
        saveCommunityUsers(data.communities, data.communityUsers);
    }
    const { communities } = data;
    return {
        data: communities[0],
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: community.update
*/
/**
 * ```js
 * import { updateCommunity } from '@amityco/ts-sdk'
 * const updated = await updateCommunity(communityId, { displayName: 'foobar' })
 * ```
 *
 * Updates an {@link Amity.Community}
 *
 * @param communityId The ID of the {@link Amity.Community} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Community} object
 *
 * @category Community API
 * @async
 */
const updateCommunity = async (communityId, patch) => {
    const client = getActiveClient();
    client.log('community/updateCommunity', communityId, patch);
    const { data: payload } = await client.http.put(`/api/v3/communities/${communityId}`, prepareCommunityRequest(patch));
    fireEvent('community.updated', payload);
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
        saveCommunityUsers(data.communities, data.communityUsers);
    }
    const { communities } = data;
    return {
        data: communities.find(community => community.communityId === communityId),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const community = await CommunityRepository.getCommunity('foobar')
 * ```
 *
 * Fetches a {@link Amity.Community} object
 *
 * @param communityId the ID of the {@link Amity.Community} to fetch
 * @returns the associated {@link Amity.Community} object
 *
 * @category Community API
 * @async
 */
const getCommunity$1 = async (communityId) => {
    const client = getActiveClient();
    client.log('community/getCommunity', communityId);
    // API-FIX: endpoint should not be /list, parameters should be querystring.
    const { data: payload } = await client.http.get(`/api/v3/communities/${communityId}`);
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
        saveCommunityUsers(data.communities, data.communityUsers);
    }
    const { communities } = data;
    return {
        data: communities.find(community => community.communityId === communityId),
        cachedAt,
    };
};
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const community = CommunityRepository.getCommunity.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Community} object from cache
 *
 * @param communityId the ID of the {@link Amity.Community} to fetch
 * @returns the associated {@link Amity.Community} object
 *
 * @category Community API
 */
getCommunity$1.locally = (communityId) => {
    const client = getActiveClient();
    client.log('community/getCommunity.locally', communityId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['community', 'get', communityId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/* begin_public_function
  id: community.delete
*/
/**
 * ```js
 * import { deleteCommunity } from '@amityco/ts-sdk'
 * const success = await deleteCommunity('foobar')
 * ```
 *
 * Deletes a {@link Amity.Community}
 *
 * @param communityId The {@link Amity.Community} ID to delete
 * @return A success boolean if the {@link Amity.Community} was deleted
 *
 * @category Community API
 * @async
 */
const deleteCommunity = async (communityId) => {
    const client = getActiveClient();
    client.log('community/deleteCommunity', communityId);
    // API-FIX: This endpoint has not been implemented yet.
    await client.http.delete(`/api/v3/communities/${communityId}`);
    const deleted = await getCommunity$1(communityId);
    fireEvent('community.deleted', {
        communities: [deleted.data],
        categories: [],
        communityUsers: [],
        feeds: [],
        files: [],
        users: [],
    });
    return deleted.data;
};
/* end_public_function */

/* begin_public_function
  id: community.join
*/
/**
 * ```js
 * import { joinCommunity } from '@amityco/ts-sdk'
 * const isJoined = await joinCommunity('foobar')
 * ```
 *
 * Joins a {@link Amity.Community} object
 *
 * @param communityId the {@link Amity.Community} to join
 * @returns A success boolean if the {@link Amity.Community} was joined
 *
 * @category Community API
 * @async
 */
const joinCommunity = async (communityId) => {
    const client = getActiveClient();
    client.log('community/joinCommunity', communityId);
    const { data: payload } = await client.http.post(`/api/v3/communities/${communityId}/join`);
    fireEvent('local.community.joined', payload);
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId && communityUser.communityMembership === 'member');
};
/* end_public_function */

/* begin_public_function
  id: community.leave
*/
/**
 * ```js
 * import { leaveCommunity } from '@amityco/ts-sdk'
 * const isLeft = await leaveCommunity('foobar')
 * ```
 *
 * Leaves a {@link Amity.Community} object
 *
 * @param communityId the {@link Amity.Community} to leave
 * @returns A success boolean if {@link Amity.Community} was left
 *
 * @category Community API
 * @async
 */
const leaveCommunity = async (communityId) => {
    const client = getActiveClient();
    client.log('community/leaveCommunity', communityId);
    const { data: payload } = await client.http.delete(`/api/v3/communities/${communityId}/leave`);
    fireEvent('local.community.left', payload);
    const data = prepareCommunityPayload(payload);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId && communityUser.communityMembership !== 'member');
};
/* end_public_function */

const createCommunityEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        const unpackedPayload = prepareCommunityPayload(payload);
        if (!client.cache) {
            // TODO: here we are missing specific properties here!
            callback(unpackedPayload.communities[0]);
        }
        else {
            ingestInCache(unpackedPayload);
            const community = pullFromCache([
                'community',
                'get',
                unpackedPayload.communities[0].communityId,
            ]);
            callback(community.data);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onCommunityCreated } from '@amityco/ts-sdk'
 * const dispose = onCommunityCreated(community => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} have been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityCreated = (callback) => createCommunityEventSubscriber('community.created', callback);

/**
 * ```js
 * import { onCommunityUpdated } from '@amityco/ts-sdk'
 * const dispose = onCommunityUpdated(community => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUpdated = (callback) => createCommunityEventSubscriber('community.updated', callback);

/**
 * ```js
 * import { onCommunityDeleted } from '@amityco/ts-sdk'
 * const dispose = onCommunityDeleted(community => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityDeleted = (callback) => createCommunityEventSubscriber('community.deleted', callback);

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class CommunitiesPaginationController$1 extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/communities`, {
            params: Object.assign(Object.assign({}, params), { isDeleted: inferIsDeleted(params.includeDeleted), keyword: params.displayName, filter: params.membership, options }),
        });
        return queryResponse;
    }
}

class CommunitiesQueryStreamController$1 extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communities.map(getResolver('community')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communities = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...communities, ...response.communities.map(getResolver('community'))])] }));
        }
    }
    reactor(action) {
        return (community) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityActions$4;
(function (EnumCommunityActions) {
    EnumCommunityActions["OnCommunityCreated"] = "onCommunityCreated";
    EnumCommunityActions["OnCommunityDeleted"] = "onCommunityDeleted";
    EnumCommunityActions["OnCommunityUpdated"] = "onCommunityUpdated";
})(EnumCommunityActions$4 || (EnumCommunityActions$4 = {}));

var EnumCommunityMemberActions$1;
(function (EnumCommunityMemberActions) {
    EnumCommunityMemberActions["OnCommunityJoined"] = "onCommunityJoined";
    EnumCommunityMemberActions["OnCommunityLeft"] = "onCommunityLeft";
    EnumCommunityMemberActions["OnCommunityUserBanned"] = "onCommunityUserBanned";
    EnumCommunityMemberActions["OnCommunityUserChanged"] = "onCommunityUserChanged";
    EnumCommunityMemberActions["OnCommunityUserRoleAdded"] = "onCommunityUserRoleAdded";
    EnumCommunityMemberActions["OnCommunityUserRoleRemoved"] = "onCommunityUserRoleRemoved";
    EnumCommunityMemberActions["OnCommunityUserUnbanned"] = "onCommunityUserUnbanned";
    EnumCommunityMemberActions["OnMemberCountChanged"] = "OnMemberCountChanged";
    EnumCommunityMemberActions["OnCommunityUserAdded"] = "OnCommunityUserAdded";
    EnumCommunityMemberActions["onCommunityUserRemoved"] = "onCommunityUserRemoved";
    EnumCommunityMemberActions["OnUserDeleted"] = "OnUserDeleted";
})(EnumCommunityMemberActions$1 || (EnumCommunityMemberActions$1 = {}));

/* begin_public_function
  id: community.membership.add_members
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const updated = await CommunityRepository.moderation.addMembers(communityId, ['foo', 'bar'])
 * ```
 *
 * Adds a list of {@link Amity.InternalUser} to a {@link Amity.Community} to add users to
 *
 * @param communityId The ID of the {@link Amity.Community} to perform
 * @param userIds The list of IDs {@link Amity.InternalUser} to add
 * @returns A success boolean if the {@link Amity.InternalUser} were added to the {@link Amity.Community}
 *
 * @category Community API
 * @async
 */
const addMembers = async (communityId, userIds) => {
    const client = getActiveClient();
    client.log('community/moderation/addMembers', communityId, userIds);
    const { data: payload } = await client.http.post(`/api/v3/communities/${communityId}/users`, { communityId, userIds });
    fireEvent('local.community.userAdded', payload);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    if (client.cache)
        ingestInCache(data);
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId && communityUser.communityMembership === 'member');
};
/* end_public_function */

/* begin_public_function
  id: community.membership.remove_member
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const updated = await CommunityRepository.moderation.removeMembers(communityId, ['foo', 'bar'])
 * ```
 *
 * Removes a list of {@link Amity.InternalUser} from a {@link Amity.Community}
 *
 * @param communityId The ID of the {@link Amity.Community} to edit
 * @param userIds The list of IDs {@link Amity.InternalUser} to remove
 * @returns A success boolean if the list of {@link Amity.InternalUser} were removed from the {@link Amity.Community}
 *
 * @category Community API
 * @async
 */
const removeMembers = async (communityId, userIds) => {
    const client = getActiveClient();
    client.log('community/moderation/removeMembers', communityId, userIds);
    const { data: payload } = await client.http.delete(`/api/v3/communities/${communityId}/users`, { data: { communityId, userIds } });
    fireEvent('local.community.userRemoved', payload);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    if (client.cache)
        ingestInCache(data);
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId && communityUser.communityMembership !== 'member');
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class CommunityMembersPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, includeDeleted } = queryParams, params = __rest(queryParams, ["limit", "includeDeleted"]);
        const options = token ? { token } : { limit };
        const isDeleted = includeDeleted === false ? false : undefined;
        const { data: queryResponse } = await this.http.get(`/api/v3/communities/${params.communityId}/users`, {
            params: Object.assign(Object.assign({}, params), { options,
                isDeleted }),
        });
        return queryResponse;
    }
}

class CommunityMembersQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communityUsers.map(({ communityId, userId }) => getResolver('communityUsers')({ communityId, userId })),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communityUsers = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [
                    ...new Set([
                        ...communityUsers,
                        ...response.communityUsers.map(({ communityId, userId }) => getResolver('communityUsers')({ communityId, userId })),
                    ]),
                ] }));
        }
    }
    reactor(action) {
        return (community, communityMembers) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            communityMembers.forEach(communityMember => {
                const communityMemberCacheId = getResolver('communityUsers')({
                    communityId: this.query.communityId,
                    userId: communityMember.userId,
                });
                if (communityMember.communityMembership === 'none') {
                    collection.data = collection.data.filter(m => m !== communityMemberCacheId);
                }
                else if (!collection.data.includes(communityMemberCacheId)) {
                    collection.data = [communityMemberCacheId, ...collection.data];
                }
            });
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

function hasPermission(member, payload, permission) {
    if (member.permissions.some(x => x === permission)) {
        return true;
    }
    return payload
        .communityUsers.find(user => user.userId === member.userId)
        .permissions.some(x => x === permission);
}
function getEventRelatedMember(event, payload) {
    if (event === 'community.joined' || event === 'community.left') {
        return payload.communityUsers;
    }
    if (event === 'community.userRemoved' || event === 'local.community.userRemoved') {
        return payload.communityUsers.filter(x => x.communityMembership === 'none');
    }
    if (event === 'community.userBanned') {
        return payload.communityUsers.filter(x => x.communityMembership === 'banned');
    }
    // NOTE: it might be that in certain edge cases permission check won't be enough
    if (event === 'community.userUnbanned') {
        return payload.communityUsers.filter(x => !hasPermission(x, payload, 'BAN_COMMUNITY_USER'));
    }
    return payload.communityUsers.filter(x => !hasPermission(x, payload, 'ADD_COMMUNITY_USER'));
}
const createCommunityMemberEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        const preparedPayload = prepareCommunityPayload(payload);
        const { communities, communityUsers } = preparedPayload;
        /*
         * community.isJoined is not part of the communityMembership payload, and needs
         * to be calculated based on the communityMembership value
         */
        const communitiesWithMembership = updateMembershipStatus(communities, communityUsers);
        preparedPayload.communities = communitiesWithMembership;
        if (!client.cache) {
            // TODO: here we are missing specific properties here!
            callback(preparedPayload.communities[0], getEventRelatedMember(event, preparedPayload));
        }
        else {
            // NOTE: The event payload should be merge with existing cache data
            ingestInCache(preparedPayload, undefined, false);
            const community = pullFromCache([
                'community',
                'get',
                preparedPayload.communities[0].communityId,
            ]);
            const members = getEventRelatedMember(event, preparedPayload)
                .map(member => {
                const memberCache = pullFromCache([
                    'communityUsers',
                    'get',
                    getResolver('communityUsers')(member),
                ]);
                return memberCache === null || memberCache === void 0 ? void 0 : memberCache.data;
            })
                .filter(isNonNullable);
            callback(community.data, members);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};
const createLocalCommunityMemberEventSubscriber = (event, callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        const preparedPayload = prepareCommunityPayload(payload);
        const { communities, communityUsers } = preparedPayload;
        /*
         * community.isJoined is not part of the communityMembership payload, and needs
         * to be calculated based on the communityMembership value
         */
        const communitiesWithMembership = updateMembershipStatus(communities, communityUsers);
        preparedPayload.communities = communitiesWithMembership;
        if (!client.cache) {
            // TODO: here we are missing specific properties here!
            callback(preparedPayload.communities[0], getEventRelatedMember(event, preparedPayload));
        }
        else {
            // NOTE: The event payload should be merge with existing cache data
            ingestInCache(preparedPayload, undefined, false);
            const community = pullFromCache([
                'community',
                'get',
                preparedPayload.communities[0].communityId,
            ]);
            const members = getEventRelatedMember(event, preparedPayload)
                .map(member => {
                const memberCache = pullFromCache([
                    'communityUsers',
                    'get',
                    getResolver('communityUsers')(member),
                ]);
                return memberCache === null || memberCache === void 0 ? void 0 : memberCache.data;
            })
                .filter(isNonNullable);
            callback(community.data, members);
        }
    };
    return createEventSubscriber(client, event, event, filter);
};

/**
 * ```js
 * import { onCommunityUserAdded } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserAdded((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been added to a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserAdded = (callback) => createCommunityMemberEventSubscriber('community.userAdded', callback);

/**
 * ```js
 * import { onCommunityUserRemoved } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserRemoved((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been removed from a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserRemoved = (callback) => createCommunityMemberEventSubscriber('community.userRemoved', callback);

/**
 * ```js
 * import { onCommunityUserBanned } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserBanned((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been banned from a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserBanned = (callback) => createCommunityMemberEventSubscriber('community.userBanned', callback);

/**
 * ```js
 * import { onCommunityUserChanged } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserChanged((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been added or removed from a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserChanged = (callback) => createCommunityMemberEventSubscriber('community.userChanged', callback);

/**
 * ```js
 * import { onCommunityUserUnbanned } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserUnbanned((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been unbanned from a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserUnbanned = (callback) => createCommunityMemberEventSubscriber('community.userUnbanned', callback);

/**
 * ```js
 * import { onCommunityUserRoleAdded } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserRoleAdded((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a role has been added to {@link Amity.CommunityUser}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserRoleAdded = (callback) => createCommunityMemberEventSubscriber('community.roleAdded', callback);

/**
 * ```js
 * import { onCommunityUserRoleRemoved } from '@amityco/ts-sdk'
 * const dispose = onCommunityUserRoleRemoved((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a role has been removed from {@link Amity.CommunityUser}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityUserRoleRemoved = (callback) => createCommunityMemberEventSubscriber('community.roleRemoved', callback);

/**
 * ```js
 * import { onLocalCommunityUserAdded } from '@amityco/ts-sdk'
 * const dispose = onLocalCommunityUserAdded((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been added to a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onLocalCommunityUserAdded = (callback) => createLocalCommunityMemberEventSubscriber('local.community.userAdded', callback);

/**
 * ```js
 * import { onLocalCommunityUserRemoved } from '@amityco/ts-sdk'
 * const dispose = onLocalCommunityUserRemoved((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a user has been removed from a {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onLocalCommunityUserRemoved = (callback) => createLocalCommunityMemberEventSubscriber('local.community.userRemoved', callback);

/**
 * ```js
 * import { onCommunityJoined } from '@amityco/ts-sdk'
 * const dispose = onCommunityJoined((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} has been joined
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityJoined = (callback) => createCommunityMemberEventSubscriber('community.joined', callback);

/**
 * ```js
 * import { onCommunityLeft } from '@amityco/ts-sdk'
 * const dispose = onCommunityLeft((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} has been left
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onCommunityLeft = (callback) => createCommunityMemberEventSubscriber('community.left', callback);

const onLocalCommunityJoined = (callback) => createLocalCommunityMemberEventSubscriber('local.community.joined', callback);

const onLocalCommunityLeft = (callback) => createLocalCommunityMemberEventSubscriber('local.community.left', callback);

/**
 * ```js
 * import { onLocalCommunityRoleRemoved } from '@amityco/ts-sdk'
 * const dispose = onLocalCommunityRoleRemoved((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.communityUsers} 's role has been added to any {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onLocalCommunityRoleRemoved = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const { communities, communityUsers } = payload;
        callback(communities[0], communityUsers.filter(communityUser => communityUser.communityMembership === 'member'));
    };
    return createEventSubscriber(client, 'onLocalCommunityRoleRemoved', 'local.community.roleRemoved', filter);
};

/**
 * ```js
 * import { onLocalCommunityRoleAdded } from '@amityco/ts-sdk'
 * const dispose = onLocalCommunityRoleAdded((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when any {@link Amity.communityUsers} 's role has been added to any {@link Amity.Community}
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onLocalCommunityRoleAdded = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const { communities, communityUsers } = payload;
        callback(communities[0], communityUsers.filter(communityUser => communityUser.communityMembership === 'member'));
    };
    return createEventSubscriber(client, 'onLocalCommunityRoleAdded', 'local.community.roleAdded', filter);
};

/**
 * ```js
 * import { onUserDeleted } from '@amityco/ts-sdk'
 * const dispose = onUserDeleted((community, member) => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.Community} has been joined
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Community Events
 */
const onUserDeleted = (communityId) => (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        var _a, _b;
        const userPayload = prepareUserPayload(payload);
        if (userPayload.users.length === 0)
            return;
        const user = userPayload.users[0];
        ingestInCache(userPayload);
        const communityUserCacheKey = getResolver('communityUsers')({
            communityId,
            userId: user.userId,
        });
        const cacheData = (_a = pullFromCache([
            'communityUsers',
            'get',
            communityUserCacheKey,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        pushToCache(['communityUsers', 'get', communityUserCacheKey], Object.assign(Object.assign({}, cacheData), { user }));
        const community = (_b = pullFromCache(['community', 'get', communityId])) === null || _b === void 0 ? void 0 : _b.data;
        callback(community, [
            Object.assign(Object.assign({}, cacheData), { user }),
        ]);
    };
    return createEventSubscriber(client, 'user.deleted', 'user.deleted', filter);
};

class CommunityMembersLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['communityUsers', 'collection', queryStreamId];
        const paginationController = new CommunityMembersPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new CommunityMembersQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserBanned, action: EnumCommunityMemberActions$1.OnCommunityUserBanned },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnCommunityUserChanged },
            { fn: onCommunityUserRoleAdded, action: EnumCommunityMemberActions$1.OnCommunityUserRoleAdded },
            {
                fn: onCommunityUserRoleRemoved,
                action: EnumCommunityMemberActions$1.OnCommunityUserRoleRemoved,
            },
            {
                fn: onLocalCommunityRoleAdded,
                action: EnumCommunityMemberActions$1.OnCommunityUserRoleAdded,
            },
            {
                fn: onLocalCommunityRoleRemoved,
                action: EnumCommunityMemberActions$1.OnCommunityUserRoleRemoved,
            },
            { fn: onCommunityUserUnbanned, action: EnumCommunityMemberActions$1.OnCommunityUserUnbanned },
            { fn: onLocalCommunityUserAdded, action: EnumCommunityMemberActions$1.OnCommunityUserAdded },
            {
                fn: onLocalCommunityUserRemoved,
                action: EnumCommunityMemberActions$1.onCommunityUserRemoved,
            },
            {
                fn: onUserDeleted(this.query.communityId),
                action: EnumCommunityMemberActions$1.OnCommunityUserChanged,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['communityUsers', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let communityMembers = filterByPropIntersection(data, 'roles', this.query.roles);
        if (this.query.memberships) {
            communityMembers = communityMembers.filter(({ communityMembership }) => {
                const memberships = this.query.memberships || [];
                return memberships.includes(communityMembership);
            });
        }
        if (this.query.includeDeleted === false) {
            communityMembers = communityMembers.filter(({ user }) => (user === null || user === void 0 ? void 0 : user.isDeleted) !== true);
        }
        switch (this.query.sortBy) {
            case 'firstCreated':
                communityMembers = communityMembers.sort(sortByFirstCreated);
                break;
            case 'lastCreated':
            default:
                communityMembers = communityMembers.sort(sortByLastCreated);
                break;
        }
        return communityMembers;
    }
}

/*
 * Exported for testing
 * @hidden
 */
const applyFilter = (data, params) => {
    let communityMembers = filterByPropIntersection(data, 'roles', params.roles);
    if (params.memberships) {
        communityMembers = communityMembers.filter(({ communityMembership }) => {
            const membership = params.memberships;
            return membership.includes(communityMembership);
        });
    }
    const sortBy = params.sortBy ? params.sortBy : 'lastCreated';
    communityMembers = communityMembers.sort(sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);
    return communityMembers;
};
/* begin_public_function
  id: community.membership.query
*/
/**
 * ```js
 * import { getMembers } from '@amityco/ts-sdk'
 *
 * let communityMembers = []
 * const unsub = getMembers({
 *   communityId: Amity.Community['communityId'],
 * }, response => merge(communityMembers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.CommunityUser}s
 *
 * @param params for querying community users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the community users
 *
 * @category Community Live Collection
 */
const getMembers = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getMembers(tmpid: ${timestamp}) > listen`);
    const communityMemberLiveCollection = new CommunityMembersLiveCollectionController(params, resp => {
        callback(resp);
    });
    const disposers = communityMemberLiveCollection.startSubscription();
    const cacheKey = communityMemberLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getMembers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class SearchCommunityMembersPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, includeDeleted } = queryParams, params = __rest(queryParams, ["limit", "includeDeleted"]);
        const options = token ? { token } : { limit };
        const isDeleted = includeDeleted === false ? false : undefined;
        const { data: queryResponse } = await this.http.get(`/api/v3/communities/${params.communityId}/users`, {
            params: Object.assign(Object.assign({}, params), { options,
                isDeleted }),
        });
        return queryResponse;
    }
}

class SearchCommunityMembersQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communityUsers.map(({ communityId, userId }) => getResolver('communityUsers')({ communityId, userId })),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communityUsers = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [
                    ...new Set([
                        ...communityUsers,
                        ...response.communityUsers.map(({ communityId, userId }) => getResolver('communityUsers')({ communityId, userId })),
                    ]),
                ] }));
        }
    }
    reactor(action) {
        return (community, communityMembers) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            communityMembers.forEach(communityMember => {
                const communityMemberCacheId = getResolver('communityUsers')({
                    communityId: this.query.communityId,
                    userId: communityMember.userId,
                });
                if (communityMember.communityMembership === 'none') {
                    collection.data = collection.data.filter(m => m !== communityMemberCacheId);
                }
            });
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityMemberActions;
(function (EnumCommunityMemberActions) {
    EnumCommunityMemberActions["OnCommunityJoined"] = "onCommunityJoined";
    EnumCommunityMemberActions["OnCommunityLeft"] = "onCommunityLeft";
    EnumCommunityMemberActions["OnCommunityUserBanned"] = "onCommunityUserBanned";
    EnumCommunityMemberActions["OnCommunityUserChanged"] = "onCommunityUserChanged";
    EnumCommunityMemberActions["OnCommunityUserRoleAdded"] = "onCommunityUserRoleAdded";
    EnumCommunityMemberActions["OnCommunityUserRoleRemoved"] = "onCommunityUserRoleRemoved";
    EnumCommunityMemberActions["OnCommunityUserUnbanned"] = "onCommunityUserUnbanned";
})(EnumCommunityMemberActions || (EnumCommunityMemberActions = {}));

/* eslint-disable no-use-before-define */
class SearchCommunityMembersLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['communityUsers', 'collection', queryStreamId];
        const paginationController = new SearchCommunityMembersPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new SearchCommunityMembersQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityJoined, action: EnumCommunityMemberActions.OnCommunityJoined },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions.OnCommunityLeft },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions.OnCommunityLeft },
            { fn: onCommunityUserBanned, action: EnumCommunityMemberActions.OnCommunityUserBanned },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions.OnCommunityUserChanged },
            {
                fn: onLocalCommunityRoleRemoved,
                action: EnumCommunityMemberActions.OnCommunityUserRoleRemoved,
            },
            {
                fn: onCommunityUserRoleRemoved,
                action: EnumCommunityMemberActions.OnCommunityUserRoleRemoved,
            },
            { fn: onCommunityUserUnbanned, action: EnumCommunityMemberActions.OnCommunityUserUnbanned },
            {
                fn: onUserDeleted(this.query.communityId),
                action: EnumCommunityMemberActions.OnCommunityUserChanged,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['communityUsers', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let communityMembers = filterByPropIntersection(data, 'roles', this.query.roles);
        if (this.query.memberships) {
            communityMembers = communityMembers.filter(({ communityMembership }) => {
                const memberships = this.query.memberships || [];
                return memberships.includes(communityMembership);
            });
        }
        if (this.query.search) {
            communityMembers = filterBySearchTerm(communityMembers, this.query.search);
        }
        if (this.query.includeDeleted === false) {
            communityMembers = communityMembers.filter(({ user }) => (user === null || user === void 0 ? void 0 : user.isDeleted) !== true);
        }
        return communityMembers;
    }
}

/* begin_public_function
  id: community.membership.query
*/
/**
 * ```js
 * import { searchMembers } from '@amityco/ts-sdk'
 *
 * let communityMembers = []
 * const unsub = searchMembers({
 *   communityId: Amity.Community['communityId'],
 * }, response => merge(communityMembers, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.CommunityUser}s
 *
 * @param params for querying community users
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the community users
 *
 * @category Community Live Collection
 */
const searchMembers = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getMembers(tmpid: ${timestamp}) > listen`);
    const searchCommunityMemberLiveCollection = new SearchCommunityMembersLiveCollectionController(params, resp => {
        callback(resp);
    });
    const disposers = searchCommunityMemberLiveCollection.startSubscription();
    const cacheKey = searchCommunityMemberLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getMembers(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

var index$c = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addMembers: addMembers,
  removeMembers: removeMembers,
  applyFilter: applyFilter,
  getMembers: getMembers,
  searchMembers: searchMembers,
  onCommunityUserAdded: onCommunityUserAdded,
  onCommunityUserRemoved: onCommunityUserRemoved,
  onCommunityUserBanned: onCommunityUserBanned,
  onCommunityUserChanged: onCommunityUserChanged,
  onCommunityUserUnbanned: onCommunityUserUnbanned,
  onCommunityUserRoleAdded: onCommunityUserRoleAdded,
  onCommunityUserRoleRemoved: onCommunityUserRoleRemoved,
  onLocalCommunityUserAdded: onLocalCommunityUserAdded,
  onLocalCommunityUserRemoved: onLocalCommunityUserRemoved,
  onCommunityJoined: onCommunityJoined,
  onCommunityLeft: onCommunityLeft,
  onLocalCommunityJoined: onLocalCommunityJoined,
  onLocalCommunityLeft: onLocalCommunityLeft
});

class SearchCommunityLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['community', 'collection', queryStreamId];
        const paginationController = new CommunitiesPaginationController$1(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new CommunitiesQueryStreamController$1(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityDeleted, action: EnumCommunityActions$4.OnCommunityDeleted },
            { fn: onCommunityUpdated, action: EnumCommunityActions$4.OnCommunityUpdated },
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnMemberCountChanged },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['community', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        const { userId } = getActiveClient();
        let communities = data;
        if (!this.query.includeDeleted) {
            communities = filterByPropEquality(communities, 'isDeleted', false);
        }
        if (this.query.categoryId) {
            communities = communities.filter(c => { var _a; return (_a = c.categoryIds) === null || _a === void 0 ? void 0 : _a.includes(this.query.categoryId); });
        }
        if (this.query.tags) {
            communities = communities.filter(c => { var _a; return (_a = c.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.tags) === null || _a === void 0 ? void 0 : _a.includes(t); }); });
        }
        if (this.query.membership && userId) {
            communities = filterByCommunityMembership(communities, this.query.membership, userId);
        }
        return communities;
    }
}

/* begin_public_function
  id: community.query
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * let communities = []
 * const unsub = CommunityRepository.searchCommunities({
 *   displayName: Amity.Community['displayName'],
 * }, response => merge(communities, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Community}s
 *
 * @param params for querying communities
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the communities
 *
 * @category Community Live Collection
 */
const searchCommunities = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`searchCommunities(tmpid: ${timestamp}) > listen`);
    const searchCommunitiesLiveCollection = new SearchCommunityLiveCollectionController(params, callback);
    const disposers = searchCommunitiesLiveCollection.startSubscription();
    const cacheKey = searchCommunitiesLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`searchCommunities(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class CommunitiesPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/communities`, {
            params: Object.assign(Object.assign({}, params), { isDeleted: inferIsDeleted(params.includeDeleted), filter: params.membership, options }),
        });
        return queryResponse;
    }
}

class CommunitiesQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
            saveCommunityUsers(response.communities, response.communityUsers);
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communities.map(getResolver('community')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communities = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...communities, ...response.communities.map(getResolver('community'))])] }));
        }
    }
    reactor(action) {
        return (community) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            /*
             * Simply update a collection and let responder decide what to do with data
             */
            collection.data = [...new Set([community.communityId, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityActions$3;
(function (EnumCommunityActions) {
    EnumCommunityActions["OnCommunityCreated"] = "onCommunityCreated";
    EnumCommunityActions["OnCommunityDeleted"] = "onCommunityDeleted";
    EnumCommunityActions["OnCommunityUpdated"] = "onCommunityUpdated";
})(EnumCommunityActions$3 || (EnumCommunityActions$3 = {}));

class CommunityLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['community', 'collection', queryStreamId];
        const paginationController = new CommunitiesPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new CommunitiesQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityCreated, action: EnumCommunityActions$3.OnCommunityCreated },
            { fn: onCommunityDeleted, action: EnumCommunityActions$3.OnCommunityDeleted },
            { fn: onCommunityUpdated, action: EnumCommunityActions$3.OnCommunityUpdated },
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnMemberCountChanged },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['community', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        const { userId } = getActiveClient();
        let communities = data;
        if (!this.query.includeDeleted) {
            communities = filterByPropEquality(communities, 'isDeleted', false);
        }
        if (this.query.categoryId) {
            communities = communities.filter(c => { var _a; return (_a = c.categoryIds) === null || _a === void 0 ? void 0 : _a.includes(this.query.categoryId); });
        }
        if (this.query.tags) {
            communities = communities.filter(c => { var _a; return (_a = c.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.tags) === null || _a === void 0 ? void 0 : _a.includes(t); }); });
        }
        if (this.query.membership && userId) {
            communities = filterByCommunityMembership(communities, this.query.membership, userId);
        }
        const sortFn = (() => {
            switch (this.query.sortBy) {
                case 'firstCreated':
                    return sortByFirstCreated;
                case 'lastCreated':
                    return sortByLastCreated;
                default:
                    return sortByLastCreated;
            }
        })();
        communities = communities.sort(sortFn);
        return communities;
    }
}

/* begin_public_function
  id: community.query
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * let communities = []
 * const unsub = CommunityRepository.getCommunities({
 *   displayName: Amity.Community['displayName'],
 * }, response => merge(communities, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Community}s
 *
 * @param params for querying communities
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the communities
 *
 * @category Community Live Collection
 */
const getCommunities = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getCommunities(tmpid: ${timestamp}) > listen`);
    const communitiesLiveCollection = new CommunityLiveCollectionController(params, callback);
    const disposers = communitiesLiveCollection.startSubscription();
    const cacheKey = communitiesLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getCommunities(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/* begin_public_function
  id: community.get
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk';
 *
 * let community;
 *
 * const unsub = CommunityRepository.getCommunity(communityId, response => {
 *   community = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Community}
 *
 * @param communityId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the community
 *
 * @category Community Live Object
 */
const getCommunity = (communityId, callback) => {
    return liveObject(communityId, callback, 'communityId', getCommunity$1, [
        onCommunityUpdated,
        onCommunityDeleted,
        onCommunityJoined,
        onCommunityLeft,
        onLocalCommunityJoined,
        onLocalCommunityLeft,
        onCommunityUserBanned,
        onCommunityUserUnbanned,
        onCommunityUserChanged,
    ]);
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class TrendingCommunitiesPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/communities/top-trending`, {
            params: Object.assign(Object.assign({}, params), { options }),
        });
        return queryResponse;
    }
}

class TrendingCommunitiesQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
            saveCommunityUsers(response.communities, response.communityUsers);
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communities.map(getResolver('community')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communities = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...communities, ...response.communities.map(getResolver('community'))])] }));
        }
    }
    reactor(action) {
        return (community) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityActions$2;
(function (EnumCommunityActions) {
    EnumCommunityActions["OnCommunityDeleted"] = "onCommunityDeleted";
    EnumCommunityActions["OnCommunityUpdated"] = "onCommunityUpdated";
})(EnumCommunityActions$2 || (EnumCommunityActions$2 = {}));

class TrendingCommunityLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['trendingCommunity', 'collection', queryStreamId];
        const paginationController = new TrendingCommunitiesPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new TrendingCommunitiesQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityDeleted, action: EnumCommunityActions$2.OnCommunityDeleted },
            { fn: onCommunityUpdated, action: EnumCommunityActions$2.OnCommunityUpdated },
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnMemberCountChanged },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = (_b = collection.data
            .map(id => pullFromCache(['community', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : [];
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
}

/* begin_public_function
  id: community.query.trending_communities
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * let communities = []
 * const unsub = CommunityRepository.getCommunities({
 *   displayName: Amity.Community['displayName'],
 * }, response => merge(communities, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Community}s
 *
 * @param params for querying communities
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the communities
 *
 * @category Community Live Collection
 */
const getTrendingCommunities = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getTrendingCommunities(tmpid: ${timestamp}) > listen`);
    const trendingCommunitiesLiveCollection = new TrendingCommunityLiveCollectionController(params, callback);
    const disposers = trendingCommunitiesLiveCollection.startSubscription();
    const cacheKey = trendingCommunitiesLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getTrendingCommunities(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class RecommendedCommunitiesPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/communities/recommended`, {
            params: Object.assign(Object.assign({}, params), { options }),
        });
        return queryResponse;
    }
}

class RecommendedCommunitiesQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
            saveCommunityUsers(response.communities, response.communityUsers);
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.communities.map(getResolver('community')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communities = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...communities, ...response.communities.map(getResolver('community'))])] }));
        }
    }
    reactor(action) {
        return (community) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityActions$1;
(function (EnumCommunityActions) {
    EnumCommunityActions["OnCommunityDeleted"] = "onCommunityDeleted";
    EnumCommunityActions["OnCommunityUpdated"] = "onCommunityUpdated";
})(EnumCommunityActions$1 || (EnumCommunityActions$1 = {}));

class RecommendedCommunityLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['community', 'collection', queryStreamId];
        const paginationController = new RecommendedCommunitiesPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new RecommendedCommunitiesQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityDeleted, action: EnumCommunityActions$1.OnCommunityDeleted },
            { fn: onCommunityUpdated, action: EnumCommunityActions$1.OnCommunityUpdated },
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnMemberCountChanged },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = (_b = collection.data
            .map(id => pullFromCache(['community', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : [];
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
}

/* begin_public_function
  id: community.query.recommended_communities
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * let communities = []
 * const unsub = CommunityRepository.getCommunities({
 *   displayName: Amity.Community['displayName'],
 * }, response => merge(communities, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Community}s
 *
 * @param params for querying communities
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the communities
 *
 * @category Community Live Collection
 */
const getRecommendedCommunities = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getRecommendedCommunities(tmpid: ${timestamp}) > listen`);
    const recommendedCommunitiesLiveCollection = new RecommendedCommunityLiveCollectionController(params, callback);
    const disposers = recommendedCommunitiesLiveCollection.startSubscription();
    const cacheKey = recommendedCommunitiesLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getRecommendedCommunities(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

class SemanticSearchCommunityPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, communityMembershipStatus } = queryParams, params = __rest(queryParams, ["limit", "communityMembershipStatus"]);
        const baseOptions = {
            type: queryParams.limit ? 'pagination' : undefined,
        };
        const options = token ? Object.assign(Object.assign({}, baseOptions), { token }) : Object.assign(Object.assign({}, baseOptions), { limit });
        const { data: queryResponse } = await this.http.get(`/api/v1/semantic-search/communities`, {
            params: Object.assign(Object.assign({}, params), { filter: communityMembershipStatus !== null && communityMembershipStatus !== void 0 ? communityMembershipStatus : "all" /* AmityCommunityMemberStatusFilter.ALL */, options }),
        });
        return queryResponse;
    }
}

function prepareSemanticCommunitiesReferenceId(response) {
    return response.communities.map(community => {
        const score = response.searchResult.find(result => result.communityId === community.communityId);
        return `${community.communityId}:${score}`;
    });
}

class SemanticSearchCommunityQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: prepareSemanticCommunitiesReferenceId(response),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const communities = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...communities, ...prepareSemanticCommunitiesReferenceId(response)])] }));
        }
    }
    reactor(action) {
        return (community) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            collection.data = [...new Set([community.communityId, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
        //
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

var EnumCommunityActions;
(function (EnumCommunityActions) {
    EnumCommunityActions["OnCommunityCreated"] = "onCommunityCreated";
    EnumCommunityActions["OnCommunityDeleted"] = "onCommunityDeleted";
    EnumCommunityActions["OnCommunityUpdated"] = "onCommunityUpdated";
})(EnumCommunityActions || (EnumCommunityActions = {}));

class SemanticSearchCommunityLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['community', 'collection', queryStreamId];
        const paginationController = new SemanticSearchCommunityPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new SemanticSearchCommunityQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareSemanticSearchCommunityPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommunityCreated, action: EnumCommunityActions.OnCommunityCreated },
            { fn: onCommunityDeleted, action: EnumCommunityActions.OnCommunityDeleted },
            { fn: onCommunityUpdated, action: EnumCommunityActions.OnCommunityUpdated },
            { fn: onCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
            { fn: onCommunityUserChanged, action: EnumCommunityMemberActions$1.OnMemberCountChanged },
            { fn: onLocalCommunityJoined, action: EnumCommunityMemberActions$1.OnCommunityJoined },
            { fn: onLocalCommunityLeft, action: EnumCommunityMemberActions$1.OnCommunityLeft },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(communityIdWithScore => {
            const [communityId, score] = communityIdWithScore.split(':');
            return {
                communityId,
                score: parseFloat(score),
            };
        })
            .sort((a, b) => b.score - a.score)
            .map(({ communityId }) => pullFromCache(['community', 'get', communityId]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        const { userId } = getActiveClient();
        let communities = data;
        if (this.query.categoryIds) {
            communities = communities.filter(c => {
                var _a;
                return (_a = c.categoryIds) === null || _a === void 0 ? void 0 : _a.some((id) => {
                    if (!this.query.categoryIds)
                        return true;
                    if (this.query.categoryIds.length === 0)
                        return true;
                    return this.query.categoryIds.includes(id);
                });
            });
        }
        if (this.query.tags) {
            communities = communities.filter(c => { var _a; return (_a = c.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.tags) === null || _a === void 0 ? void 0 : _a.includes(t); }); });
        }
        if (this.query.communityMembershipStatus && userId) {
            communities = filterByCommunityMembership(communities, this.query.communityMembershipStatus, userId);
        }
        return communities;
    }
}

/**
 * search posts by semantic search
 *
 * @returns the associated pinned post(s)
 *
 * @category Posts Live Collection
 *
 */
const semanticSearchCommunities = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`semanticSearchCommunities(tmpid: ${timestamp}) > listen`);
    const semanticSearchPostLiveCollection = new SemanticSearchCommunityLiveCollectionController(params, callback);
    const disposers = semanticSearchPostLiveCollection.startSubscription();
    const cacheKey = semanticSearchPostLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`semanticSearchCommunities(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

var AmityCommunityMemberStatusFilter;
(function (AmityCommunityMemberStatusFilter) {
    AmityCommunityMemberStatusFilter["ALL"] = "all";
    AmityCommunityMemberStatusFilter["MEMBER"] = "member";
    AmityCommunityMemberStatusFilter["NOT_MEMBER"] = "notMember";
})(AmityCommunityMemberStatusFilter || (AmityCommunityMemberStatusFilter = {}));

/* begin_public_function
  id: community.moderation.add_roles
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const updated = await CommunityRepository.moderation.addRoles(communityId, ['foo', 'bar'])
 * ```
 *
 * Adds a list of {@link Amity.Role} to a list of {@link Amity.InternalUser} on a {@link Amity.Community}
 *
 * @param communityId The ID of the {@link Amity.Community} to perform
 * @param roleIds Array of IDs of the {@link Amity.Role} to apply
 * @param userIds Array of IDs of the {@link Amity.InternalUser} to perform
 * @returns A success boolean if the {@link Amity.Role} were added to list of {@link Amity.InternalUser} in the {@link Amity.Community}
 *
 * @category Community API
 * @async
 */
const addRoles = async (communityId, roleIds, userIds) => {
    const client = getActiveClient();
    client.log('community/moderation/addRoles', communityId, roleIds, userIds);
    const { data: payload } = await client.http.post(`/api/v4/communities/${communityId}/users/roles`, { communityId, roles: roleIds, userIds });
    const data = prepareCommunityMembershipPayload(payload);
    if (client.cache)
        ingestInCache(data);
    fireEvent('local.community.roleAdded', data);
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId &&
        roleIds.some(role => communityUser.roles.includes(role)));
};
/* end_public_function */

/* begin_public_function
  id: community.moderation.remove_roles
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 * const updated = await CommunityRepository.moderation.removeRoles(communityId, ['foo', 'bar'])
 * ```
 *
 * Removes a list of {@link Amity.Role} from a list of {@link Amity.InternalUser} on a {@link Amity.Community}
 *
 * @param communityId The ID of the {@link Amity.Community} to perform
 * @param roleIds Array of IDs of the {@link Amity.Role} to apply
 * @param userIds Array of IDs of the {@link Amity.InternalUser} to perform
 * @returns A success boolean if the {@link Amity.Role} were removed from list of {@link Amity.InternalUser} in the {@link Amity.Community}
 *
 * @category Community API
 * @async
 */
const removeRoles = async (communityId, roleIds, userIds) => {
    const client = getActiveClient();
    client.log('community/moderation/removeRoles', communityId, roleIds, userIds);
    const { data: payload } = await client.http.delete(`/api/v4/communities/${communityId}/users/roles`, { data: { communityId, roles: roleIds, userIds } });
    const data = prepareCommunityMembershipPayload(payload);
    if (client.cache)
        ingestInCache(data);
    fireEvent('local.community.roleRemoved', data);
    const { communityUsers } = data;
    return !!communityUsers.find(communityUser => communityUser.communityId === communityId &&
        !roleIds.some(role => communityUser.roles.includes(role)));
};
/* end_public_function */

/* begin_public_function
  id: community.moderation.ban_members
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * await CommunityRepository.Moderation.banMembers('communityId', ['userId1', 'userId2'])
 * ```
 *
 * @param communityId of {@link Amity.Community} from which the users should be banned
 * @param userIds of the {@link Amity.InternalUser}'s to be banned
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Community API
 * @async
 * */
const banMembers = async (communityId, userIds) => {
    const client = getActiveClient();
    client.log('community/banMembers', { userIds, communityId });
    const { data: payload } = await client.http.put(`/api/v3/communities/${communityId}/users/ban`, {
        userIds,
    });
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { communityUsers } = data;
    return {
        data: communityUsers.filter(u => userIds.includes(u.userId)),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: community.moderation.unban_members
*/
/**
 * ```js
 * import { CommunityRepository } from '@amityco/ts-sdk'
 *
 * await CommunityRepository.Moderation.unbanMembers('communityId', ['userId1', 'userId2'])
 * ```
 *
 * @param communityId of {@link Amity.Community} from which the users should be unbanned
 * @param userIds of the {@link Amity.InternalUser}'s to be unbanned
 * @returns the updated {@link Amity.Membership}'s object
 *
 * @category Community API
 * @async
 * */
const unbanMembers = async (communityId, userIds) => {
    const client = getActiveClient();
    client.log('community/unbanMembers', { userIds, communityId });
    const { data: payload } = await client.http.put(`/api/v3/communities/${communityId}/users/unban`, {
        userIds,
    });
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { communityUsers } = data;
    return {
        data: communityUsers.filter(u => userIds.includes(u.userId)),
        cachedAt,
    };
};
/* end_public_function */

var index$b = /*#__PURE__*/Object.freeze({
  __proto__: null,
  addRoles: addRoles,
  removeRoles: removeRoles,
  banMembers: banMembers,
  unbanMembers: unbanMembers
});

var index$a = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Moderation: index$b,
  Membership: index$c,
  getCommunityByIds: getCommunities$1,
  createCommunity: createCommunity,
  updateCommunity: updateCommunity,
  deleteCommunity: deleteCommunity,
  joinCommunity: joinCommunity,
  leaveCommunity: leaveCommunity,
  onCommunityCreated: onCommunityCreated,
  onCommunityUpdated: onCommunityUpdated,
  onCommunityDeleted: onCommunityDeleted,
  searchCommunities: searchCommunities,
  getCommunities: getCommunities,
  getCommunity: getCommunity,
  getTrendingCommunities: getTrendingCommunities,
  getRecommendedCommunities: getRecommendedCommunities,
  semanticSearchCommunities: semanticSearchCommunities,
  get AmityCommunityMemberStatusFilter () { return AmityCommunityMemberStatusFilter; }
});

/* begin_public_function
  id: community.category.get
*/
/**
 * ```js
 * import { getCategory } from '@amityco/ts-sdk'
 * const { data: category } = await getCategory('foo')
 * ```
 *
 * Fetches a {@link Amity.Category} object
 *
 * @param categoryId the ID of the {@link Amity.Category} to fetch
 * @returns the associated {@link Amity.Category} object
 *
 * @category Category API
 * @async
 */
const getCategory = async (categoryId) => {
    const client = getActiveClient();
    client.log('category/getCategory', categoryId);
    const { data } = await client.http.get(`/api/v3/community-categories/${encodeURIComponent(categoryId)}`);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { categories } = data;
    return {
        data: LinkedObject.category(categories.find(category => category.categoryId === categoryId)),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getCategory } from '@amityco/ts-sdk'
 * const { data: category } = getCategory.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Category} object from cache
 *
 * @param categoryId the ID of the {@link Amity.Category} to fetch
 * @returns the associated {@link Amity.Category} object
 *
 * @category Category API
 */
getCategory.locally = (categoryId) => {
    const client = getActiveClient();
    client.log('category/getCategory.locally', categoryId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['category', 'get', categoryId]);
    if (!cached)
        return;
    return {
        data: LinkedObject.category(cached.data),
        cachedAt: cached.cachedAt,
    };
};

const queryCategories = async (query) => {
    const client = getActiveClient();
    client.log('category/queryCategories', query);
    const _a = query !== null && query !== void 0 ? query : {}, { page, limit, includeDeleted } = _a, params = __rest(_a, ["page", "limit", "includeDeleted"]);
    const options = (() => {
        if (page)
            return { token: page };
        if (limit)
            return { limit };
        return undefined;
    })();
    const { data } = await client.http.get(`/api/v3/community-categories`, {
        params: Object.assign(Object.assign({}, params), { isDeleted: inferIsDeleted(includeDeleted), options }),
    });
    const { paging } = data, payload = __rest(data, ["paging"]);
    const { categories } = payload;
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(payload, { cachedAt });
        const cacheKey = [
            'category',
            'query',
            Object.assign(Object.assign({}, params), { includeDeleted, options }),
        ];
        pushToCache(cacheKey, { categories: categories.map(getResolver('category')), paging });
    }
    return {
        data: categories,
        cachedAt,
        paging,
    };
};
queryCategories.locally = (query) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('category/queryCategories.locally', query);
    if (!client.cache)
        return;
    const _c = query !== null && query !== void 0 ? query : {}, { page, limit = 10 } = _c, params = __rest(_c, ["page", "limit"]);
    const options = (() => {
        if (page)
            return { token: page };
        if (limit)
            return { limit };
        return undefined;
    })();
    const queryKey = ['category', 'query', Object.assign(Object.assign({}, params), { options })];
    const { data, cachedAt } = (_a = pullFromCache(queryKey)) !== null && _a !== void 0 ? _a : {};
    if (!(data === null || data === void 0 ? void 0 : data.categories.length))
        return;
    const categories = data.categories
        .map(categoryId => pullFromCache(['category', 'get', categoryId]))
        .filter(Boolean)
        .map(({ data }) => data);
    const { paging } = data;
    return categories.length === ((_b = data === null || data === void 0 ? void 0 : data.categories) === null || _b === void 0 ? void 0 : _b.length)
        ? { data: categories, cachedAt, paging }
        : undefined;
};

/* begin_public_function
  id: community.category.query
*/
/**
 * ```js
 * import { getCategories } from '@amityco/ts-sdk'
 *
 * let categories = []
 * const unsub = getCategories({}, response => merge(categories, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Category}s
 *
 * @param params for querying categories
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the categories
 *
 * @category Category Live Collection
 */
const getCategories = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getCategories(tmpid: ${timestamp}) > listen`);
    const { limit: queryLimit } = params, queryParams = __rest(params, ["limit"]);
    const limit = queryLimit !== null && queryLimit !== void 0 ? queryLimit : COLLECTION_DEFAULT_PAGINATION_LIMIT;
    const { policy = COLLECTION_DEFAULT_CACHING_POLICY } = config !== null && config !== void 0 ? config : {};
    const disposers = [];
    const cacheKey = ['category', 'collection', {}];
    const responder = (data) => {
        var _a, _b;
        let categories = (_a = data.data
            .map(categoryId => pullFromCache(['category', 'get', categoryId]))
            .filter(Boolean)
            .map(({ data }) => LinkedObject.category(data))) !== null && _a !== void 0 ? _a : [];
        if (!params.includeDeleted) {
            categories = filterByPropEquality(categories, 'isDeleted', false);
        }
        switch (params.sortBy) {
            case 'firstCreated':
                categories = categories.sort(sortByFirstCreated);
                break;
            case 'lastCreated':
                categories = categories.sort(sortByLastCreated);
                break;
            default:
                categories = categories.sort(sortByName);
        }
        callback({
            onNextPage: onFetch,
            data: categories,
            hasNextPage: !!((_b = data.params) === null || _b === void 0 ? void 0 : _b.page),
            loading: data.loading,
            error: data.error,
        });
    };
    /*
     * const realtimeRouter = () => {
     * @TODO: At the time of creating this method category does not have any
     * observers
     *};
     */
    const onFetch = (initial = false) => {
        var _a, _b;
        const collection = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        const categories = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
        if (!initial && categories.length > 0 && !(collection === null || collection === void 0 ? void 0 : collection.params.page))
            return;
        const query = createQuery(queryCategories, Object.assign(Object.assign({}, queryParams), { limit: initial ? limit : undefined, page: !initial ? collection === null || collection === void 0 ? void 0 : collection.params.page : undefined }));
        runQuery(query, ({ data: result, error, loading, paging }) => {
            const data = {
                loading,
                error,
                params: { page: paging === null || paging === void 0 ? void 0 : paging.next },
                data: categories,
            };
            if (result) {
                data.data = [...new Set([...categories, ...result.map(getResolver('category'))])];
            }
            pushToCache(cacheKey, data);
            responder(data);
        }, queryOptions(policy));
    };
    disposers.push(() => {
        // @TODO -> update once observers added
    });
    onFetch(true);
    return () => {
        log(`getCategories(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getCategory: getCategory,
  getCategories: getCategories
});

/* begin_public_function
  id: feed.query.global_feed
*/
/**
 * ```js
 * import { queryGlobalFeed } from '@amityco/ts-sdk'
 * const posts = await queryGlobalFeed()
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Post} objects
 *
 * @category Feed API
 * @async
 * */
const queryGlobalFeed = async (query) => {
    const client = getActiveClient();
    client.log('feed/queryGlobalFeed', query);
    const _a = query !== null && query !== void 0 ? query : {}, { queryToken } = _a, params = __rest(_a, ["queryToken"]);
    const options = (() => {
        if (queryToken)
            return { token: queryToken };
        return undefined;
    })();
    const { data: queryPayload } = await client.http.get(`/api/v4/me/global-feeds`, {
        params: Object.assign(Object.assign({}, params), { options }),
    });
    const { paging } = queryPayload, payload = __rest(queryPayload, ["paging"]);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const { posts } = data;
    const { communities: processedCommunity } = prepareCommunityPayload(data);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(Object.assign(Object.assign({}, data), { communitis: processedCommunity }));
        const cacheKey = ['globalFeed', 'query', Object.assign(Object.assign({}, params), { options })];
        pushToCache(cacheKey, { posts: posts.map(getResolver('post')), paging });
    }
    return {
        data: posts.map(LinkedObject.post),
        cachedAt,
        paging,
    };
};
/* end_public_function */
/**
 * ```js
 * import { queryGlobalFeed } from '@amityco/ts-sdk'
 * const posts = await queryGlobalFeed.locally()
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Post} objects
 *
 * @category Feed API
 * @async
 * */
queryGlobalFeed.locally = (query) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('post/queryGlobalFeed.locally', query);
    if (!client.cache)
        return;
    const params = __rest(query !== null && query !== void 0 ? query : {}, []);
    const queryKey = ['globalFeed', 'query', Object.assign({}, params)];
    const { data, cachedAt } = (_a = pullFromCache(queryKey)) !== null && _a !== void 0 ? _a : {};
    if (!(data === null || data === void 0 ? void 0 : data.posts.length))
        return;
    const posts = data.posts
        .map(postId => pullFromCache(['post', 'get', postId]))
        .filter(Boolean)
        .map(({ data }) => data)
        .map(LinkedObject.post);
    const { paging } = data;
    return posts.length === ((_b = data === null || data === void 0 ? void 0 : data.posts) === null || _b === void 0 ? void 0 : _b.length)
        ? {
            data: posts,
            cachedAt,
            paging,
        }
        : undefined;
};

/* begin_public_function
  id: feed.query.custom_ranking_feed
*/
/**
 * ```js
 * import { FeedRepository } from '@amityco/ts-sdk'
 * const posts = await FeedRepository.getCustomRankingGlobalFeed()
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Post} objects
 *
 * @category Feed API
 * @async
 * */
const getCustomRankingGlobalFeed = async (query) => {
    const client = getActiveClient();
    client.log('feed/getCustomRankingGlobalFeed', query);
    const _a = query !== null && query !== void 0 ? query : {}, { queryToken, limit } = _a, params = __rest(_a, ["queryToken", "limit"]);
    const options = (() => {
        if (queryToken)
            return { token: queryToken };
        return undefined;
    })();
    const { data: queryPayload } = await client.http.get(`/api/v5/me/global-feeds`, {
        params: Object.assign(Object.assign({}, params), { limit: !queryToken ? limit : undefined, options }),
    });
    const { paging } = queryPayload, payload = __rest(queryPayload, ["paging"]);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const { posts } = data;
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data);
        const cacheKey = ['customGlobalFeed', 'query', Object.assign(Object.assign({}, params), { options })];
        pushToCache(cacheKey, { posts: posts.map(getResolver('post')), paging });
    }
    return { data: posts.map(LinkedObject.post), cachedAt, paging };
};
/* end_public_function */
/**
 * ```js
 * import { FeedRepository } from '@amityco/ts-sdk'
 * const posts = await FeedRepository.getCustomRankingGlobalFeed.locally()
 * ```
 *
 * Queries a paginable list of {@link Amity.Post} objects from cache
 *
 * @param query The query parameters
 * @returns A page of {@link Amity.Post} objects
 *
 * @category Feed API
 * @async
 * */
getCustomRankingGlobalFeed.locally = (query) => {
    var _a, _b;
    const client = getActiveClient();
    client.log('post/getCustomRankingGlobalFeed.locally', query);
    if (!client.cache)
        return;
    const params = __rest(query !== null && query !== void 0 ? query : {}, []);
    const queryKey = ['customGlobalFeed', 'query', Object.assign({}, params)];
    const { data, cachedAt } = (_a = pullFromCache(queryKey)) !== null && _a !== void 0 ? _a : {};
    if (!(data === null || data === void 0 ? void 0 : data.posts.length))
        return;
    const posts = data.posts
        .map(postId => pullFromCache(['post', 'get', postId]))
        .filter(Boolean)
        .map(({ data }) => data);
    const { paging } = data;
    return posts.length === ((_b = data === null || data === void 0 ? void 0 : data.posts) === null || _b === void 0 ? void 0 : _b.length)
        ? { data: posts.map(LinkedObject.post), cachedAt, paging }
        : undefined;
};

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  queryGlobalFeed: queryGlobalFeed,
  getCustomRankingGlobalFeed: getCustomRankingGlobalFeed
});

/* begin_public_function
  id: post.get_by_ids
*/
/**
 * ```js
 * import { getPostByIds } from '@amityco/ts-sdk'
 * const { data: posts } = await getPostByIds(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Post} objects
 *
 * @param postIds the IDs of the {@link Amity.Post} to fetch
 * @returns the associated collection of {@link Amity.Post} objects
 *
 * @category Post API
 * @async
 */
const getPostByIds = async (postIds) => {
    const client = getActiveClient();
    client.log('post/getPostByIds', postIds);
    const encodedPostIds = postIds.map(postId => encodeURIComponent(postId));
    let payload;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/posts/list`, {
            params: { postIds: encodedPostIds },
        });
        payload = response.data;
    }
    catch (error) {
        postIds.forEach(postId => {
            if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
                pushToTombstone('post', postId);
            }
        });
        throw error;
    }
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    return {
        data: data.posts.map(LinkedObject.post),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getPostByIds } from '@amityco/ts-sdk'
 * const { data: posts } = getPostByIds.locally(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Post} objects from cache
 *
 * @param postIds the IDs of the {@link Amity.Post} to fetch
 * @returns the associated collection of {@link Amity.Post} objects
 *
 * @category Post API
 */
getPostByIds.locally = (postIds) => {
    var _a;
    const client = getActiveClient();
    client.log('post/getPostByIds.locally', postIds);
    if (!client.cache)
        return;
    const cached = postIds
        .map(postId => pullFromCache(['post', 'get', postId]))
        .filter(Boolean);
    const posts = cached.map(({ data }) => data);
    const oldest = (_a = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _a === void 0 ? void 0 : _a[0];
    if ((cached === null || cached === void 0 ? void 0 : cached.length) < postIds.length)
        return;
    return {
        data: posts.map(LinkedObject.post),
        cachedAt: oldest.cachedAt,
    };
};

/* begin_public_function
  id: post.create.text_post, post.create.image_post, post.create.file_post, post.create.video_post, post.create.poll_post, post.create.livestream_post, post.create.custom_post
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const created = await PostRepository.createPost({
 *   targetType: 'user',
 *   targetId: 'foobar',
 *   data: { text: 'hello world' }
 * }))
 * ```
 *
 * Creates an {@link Amity.Post}
 *
 * @param bundle The data necessary to create a new {@link Amity.Post}
 * @returns The newly created {@link Amity.Post}
 *
 * @category Post API
 * @async
 */
const createPost = async (bundle) => {
    const client = getActiveClient();
    client.log('post/createPost', bundle);
    if (!bundle.dataType || ['text', 'image', 'file', 'video'].includes(bundle.dataType)) {
        // eslint-disable-next-line no-param-reassign
        delete bundle.dataType;
    }
    const { data: payload } = await client.http.post('/api/v4/posts', bundle);
    fireEvent('post.created', payload);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { posts } = data;
    return {
        data: LinkedObject.post(posts[0]),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: post.edit, post.edit.custom_post
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const updated = await PostRepository.editPost(postId, {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Post}
 *
 * @param postId The ID of the {@link Amity.Post} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Post} object
 *
 * @category Post API
 * @async
 */
const editPost = async (postId, patch) => {
    const client = getActiveClient();
    client.log('user/editPost', patch);
    const { data: payload } = await client.http.put(`/api/v4/posts/${encodeURIComponent(postId)}`, patch);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('local.post.updated', data);
    const { posts } = data;
    return {
        data: LinkedObject.post(posts.find(post => post.postId === postId)),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { deletePost } from '@amityco/ts-sdk'
 * const success = await deletePost('foobar')
 * ```
 *
 * Deletes a {@link Amity.Post}
 *
 * @param postId The {@link Amity.Post} ID to delete
 * @return A success boolean if the {@link Amity.Post} was deleted
 *
 * @private
 * @async
 */
const deletePost = async (postId, permanent = false) => {
    var _a;
    const client = getActiveClient();
    const post = await getPost$2(postId);
    await client.http.delete(`/api/v4/posts/${encodeURIComponent(postId)}`, {
        params: {
            postId,
            permanent,
        },
    });
    // there is currently a limitation which doesn't allow us to fire event to tell that community
    // has been updated. reason is that, when the object is deleted, we don't have its `communityId`
    // and so we cannot refetch the community or advertise on events. hopefully this should be solved
    // later when realtime events covers that for us.
    if (post.data.targetType === 'community') {
        const community = await getCommunity$1(post.data.targetId);
        const communityUsersCache = (_a = queryCache(['communityUsers', 'get'])) !== null && _a !== void 0 ? _a : [];
        const communityUsers = communityUsersCache
            .filter(({ key }) => {
            // cache key is ['communityUsers', 'get', `${communityId}#`${userId}`}]
            if (key[0] !== 'communityUsers')
                return false;
            if (key[1] !== 'get')
                return false;
            if (typeof key[2] === 'string')
                return key[2].includes(community.data.communityId);
            return false;
        })
            .map(({ data }) => data);
        fireEvent('community.updated', {
            communities: [community.data],
            categories: [],
            communityUsers,
            feeds: [],
            files: [],
            users: [],
        });
    }
    // to support hard deletion
    const deleted = Object.assign(Object.assign({}, post.data), { isDeleted: true });
    if (permanent) {
        setTimeout(() => {
            pushToTombstone('post', postId);
        }, 0);
    }
    else {
        upsertInCache(['post', 'get', postId], { isDeleted: true });
    }
    fireEvent('local.post.deleted', {
        posts: [deleted],
        categories: [],
        comments: [],
        communities: [],
        communityUsers: [],
        feeds: [],
        files: [],
        postChildren: [],
        users: [],
        videoStreamings: [],
    });
    return LinkedObject.post(deleted);
};

/* begin_public_function
  id: post.soft_delete
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const success = await PostRepository.softDeletePost('foobar')
 * ```
 *
 * Soft deletes a {@link Amity.Post}
 *
 * @param postId The {@link Amity.Post} ID to soft delete
 * @return A success boolean if the {@link Amity.Post} was deleted
 *
 * @category Post API
 * @async
 */
const softDeletePost = async (postId) => {
    const client = getActiveClient();
    client.log('post/softDeletePost', postId);
    const softDeleted = await deletePost(postId, false);
    return LinkedObject.post(softDeleted);
};
/* end_public_function */

/* begin_public_function
  id: post.hard_delete
*/
/**
 * ```js
 * import { hardDeletePost } from '@amityco/ts-sdk'
 * const success = await hardDeletePost('foobar')
 * ```
 *
 * Hard deletes a {@link Amity.Post}
 *
 * @param postId The {@link Amity.Post} ID to be hard delete
 * @return A success boolean if the {@link Amity.Post} was deleted
 *
 * @category Post API
 * @async
 */
const hardDeletePost = async (postId) => {
    const client = getActiveClient();
    client.log('post/hardDeletePost', postId);
    const hardDeleted = await deletePost(postId, true);
    return LinkedObject.post(hardDeleted);
};
/* end_public_function */

/* begin_public_function
  id: post.approve
*/
/**
 * ```js
 * import { approvePost } from '@amityco/ts-sdk'
 *
 * const { data: post } = await approvePost('postId')
 * ```
 *
 * Approves a {@link Amity.Post}
 *
 * @param postId The {@link Amity.Post} ID to be approved
 * @return A {@link Amity.Post} that was approved
 *
 * @category Post API
 * @async
 */
const approvePost = async (postId) => {
    const client = getActiveClient();
    client.log('post/approvePost', postId);
    const { data: payload } = await client.http.post(`/api/v3/posts/${encodeURIComponent(postId)}/approve`);
    fireEvent('post.approved', payload);
    // fire virtual event for community update
    if (payload.posts[0].targetType === 'community') {
        fireEvent('community.updated', payload);
    }
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    return {
        data: LinkedObject.post(data.posts.find(post => post.postId === postId)),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: post.decline
*/
/**
 * ```js
 * import { declinePost } from '@amityco/ts-sdk'
 *
 * const {data: post} = await declinePost('postId')
 * ```
 *
 * Declines a {@link Amity.Post}
 *
 * @param postId The {@link Amity.Post} ID to be declined
 * @return A {@link Amity.Post} that was declined
 *
 * @category Post API
 * @async
 */
const declinePost = async (postId) => {
    const client = getActiveClient();
    client.log('post/declinePost', postId);
    const { data: payload } = await client.http.post(`/api/v3/posts/${encodeURIComponent(postId)}/decline`);
    // fire virtual event
    if (payload.posts[0].targetType === 'community') {
        fireEvent('community.updated', payload);
    }
    fireEvent('post.declined', payload);
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    return {
        data: LinkedObject.post(payload.posts.find(post => post.postId === postId)),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: post.flag
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const flagged = await PostRepository.flagPost(postId)
 * ```
 *
 * @param postId of the post to flag
 * @returns a boolean
 *
 * @category Post API
 * @async
 * */
const flagPost = async (postId) => {
    const client = getActiveClient();
    client.log('post/flagPost', postId);
    const { data: payload } = await client.http.post(`/api/v3/posts/${encodeURIComponent(postId)}/flag`);
    if (client.cache) {
        ingestInCache(prepareMembershipPayload(payload, 'communityUsers'));
    }
    fireEvent('post.flagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: post.unflag
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const unflagged = await PostRepository.unflagPost(postId)
 * ```
 *
 * @param postId of the post to unflag
 * @returns the unflag post result
 *
 * @category Post API
 * @async
 * */
const unflagPost = async (postId) => {
    const client = getActiveClient();
    client.log('post/unflagPost', postId);
    const { data: payload } = await client.http.delete(`/api/v3/posts/${encodeURIComponent(postId)}/unflag`);
    if (client.cache) {
        ingestInCache(prepareMembershipPayload(payload, 'communityUsers'));
    }
    fireEvent('post.unflagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: post.check_flag_by_me
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 * const isReported = await PostRepository.isPostFlaggedByMe('post', postId)
 * ```
 *
 * @param postId of the post to check if flagged by current user
 * @returns `true` if the post is flagged by me, `false` if doesn't.
 *
 * @category Post API
 * @async
 * */
const isPostFlaggedByMe = async (postId) => {
    const client = getActiveClient();
    client.log('post/isPostFlaggedByMe', postId);
    const { data: { result }, } = await client.http.get(`/api/v3/posts/${postId}/isflagbyme`);
    return result;
};
/* end_public_function */

/* begin_public_function
  id: comment.get_by_ids
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const comments = await CommentRepository.getCommentByIds(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Comment} objects
 *
 * @param commentIds the IDs of the {@link Amity.Comment} to fetch
 * @returns the associated collection of {@link Amity.Comment} objects
 *
 * @category Comment API
 * @async
 */
const getCommentByIds = async (commentIds) => {
    const client = getActiveClient();
    client.log('comment/getCommentByIds', commentIds);
    const encodedCommentIds = commentIds.map(commentId => encodeURIComponent(commentId));
    let data;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/comments/list`, {
            params: { commentIds: encodedCommentIds },
        });
        data = response.data;
    }
    catch (error) {
        commentIds.forEach(commentId => {
            if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
                pushToTombstone('comment', commentId);
            }
        });
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    return {
        data: data.comments.map(comment => LinkedObject.comment(comment)),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getCommentByIds } from '@amityco/ts-sdk'
 * const comments = getCommentByIds.locally(['foo', 'bar'])
 * ```
 *
 * Fetches a collection of {@link Amity.Comment} objects from cache
 *
 * @param commentIds the IDs of the {@link Amity.Comment} to fetch
 * @returns the associated collection of {@link Amity.Comment} objects
 *
 * @category Comment API
 */
getCommentByIds.locally = (commentIds) => {
    var _a;
    const client = getActiveClient();
    client.log('comment/getCommentByIds.locally', commentIds);
    if (!client.cache)
        return;
    const cached = commentIds
        .map(commentId => pullFromCache(['comment', 'get', commentId]))
        .filter(Boolean);
    const comments = cached.map(({ data }) => data);
    const oldest = (_a = cached.sort((a, b) => (a.cachedAt < b.cachedAt ? -1 : 1))) === null || _a === void 0 ? void 0 : _a[0];
    if ((cached === null || cached === void 0 ? void 0 : cached.length) < commentIds.length)
        return;
    return {
        data: comments.map(comment => LinkedObject.comment(comment)),
        cachedAt: oldest.cachedAt,
    };
};

/* begin_public_function
  id: comment.create
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const newComment = await CommentRepository.createComment(bundle)
 * ```
 *
 * Creates an {@link Amity.Comment}
 *
 * @param bundle The data necessary to create a new {@link Amity.Comment}
 * @returns The newly created {@link Amity.Comment}
 *
 * @category Comment API
 * @async
 */
const createComment = async (bundle) => {
    var _a;
    const client = getActiveClient();
    client.log('comment/createComment', bundle);
    const { data } = await client.http.post('/api/v3/comments', bundle);
    const { comments } = data;
    // BE always returns an array of comments If it got record 0 from BE it might have a problem on creation logic
    if (comments.length === 0)
        throw new Error('Comment not created');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    if (['post', 'content'].includes(bundle.referenceType)) {
        const post = (_a = pullFromCache(['post', 'get', bundle.referenceId])) === null || _a === void 0 ? void 0 : _a.data;
        if (post) {
            post.commentsCount += 1;
            fireEvent('local.post.updated', {
                posts: [post],
                categories: [],
                comments: [],
                communities: [],
                communityUsers: data.communityUsers,
                feeds: [],
                files: data.files,
                postChildren: [],
                users: data.users,
                videoStreamings: [],
            });
        }
    }
    else if (bundle.referenceType === 'story') {
        const storyIndex = pullFromCache([
            "story-reference" /* STORY_KEY_CACHE.STORY_ID_TO_REFERENCE_ID */,
            bundle.referenceId,
        ]);
        if (storyIndex === null || storyIndex === void 0 ? void 0 : storyIndex.data) {
            const cacheStory = pullFromCache([
                "story" /* STORY_KEY_CACHE.STORY */,
                'get',
                storyIndex.data,
            ]);
            if (cacheStory === null || cacheStory === void 0 ? void 0 : cacheStory.data) {
                fireEvent('story.updated', {
                    stories: [
                        Object.assign(Object.assign({}, cacheStory.data), { commentsCount: cacheStory.data.commentsCount + 1, comments: [...new Set([...cacheStory.data.comments, comments[0].commentId])] }),
                    ],
                    categories: [],
                    comments,
                    communities: [],
                    communityUsers: data.communityUsers,
                    files: data.files,
                    users: data.users,
                });
            }
        }
    }
    fireEvent('local.comment.created', data);
    return {
        data: LinkedObject.comment(comments[0]),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: comment.update_comment
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const updated = await CommentRepository.updateComment(commentId, {
 *   data: { text: 'hello world' }
 * })
 * ```
 *
 * Updates an {@link Amity.Comment}
 *
 * @param commentId The ID of the {@link Amity.Comment} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Comment} object
 *
 * @category Comment API
 * @async
 */
const updateComment = async (commentId, patch) => {
    const client = getActiveClient();
    client.log('user/updateComment', patch);
    const { data } = await client.http.put(`/api/v3/comments/${encodeURIComponent(commentId)}`, patch);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('comment.updated', data);
    const { comments } = data;
    return {
        data: LinkedObject.comment(comments.find(comment => comment.commentId === commentId)),
        cachedAt,
    };
};
/* end_public_function */

// Due to we have optimistic logic, we will use referenceId as a id in SDK instead of storyId
const applyMissingField = (rawData, isCreated = false) => {
    const { storyId, referenceId } = rawData;
    if (!isCreated) {
        if (referenceId)
            return Object.assign(Object.assign({}, rawData), { syncState: "synced" /* Amity.SyncState.Synced */ });
    }
    return Object.assign(Object.assign({}, rawData), { syncState: "synced" /* Amity.SyncState.Synced */, referenceId: storyId });
};
const convertRawStoryToInternal = (data, isCreated = false) => {
    const { stories } = data;
    const storiesData = stories.map(story => applyMissingField(story, isCreated));
    return Object.assign(Object.assign({}, data), { stories: storiesData });
};

const getStoryByStoryId$1 = async (storyId) => {
    const client = getActiveClient();
    client.log('story/getStoryByStoryId', storyId);
    // Get story referenceId from cache
    const cacheReferenceId = pullFromCache([
        "story-reference" /* STORY_KEY_CACHE.STORY_ID_TO_REFERENCE_ID */,
        storyId,
    ]);
    if (cacheReferenceId === null || cacheReferenceId === void 0 ? void 0 : cacheReferenceId.data) {
        const { data: referenceId } = cacheReferenceId;
        isInTombstone('story', referenceId);
    }
    let data;
    try {
        const response = await client.http.get(`/api/v4/stories/${storyId}`);
        data = convertRawStoryToInternal(response.data);
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('story', storyId);
        }
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        ingestInCache(data, { cachedAt });
    }
    return {
        data: data.stories[0],
        cachedAt,
    };
};
getStoryByStoryId$1.locally = (storyId) => {
    const client = getActiveClient();
    client.log('story/getStorybyStoryId', storyId);
    // Get story referenceId from cache
    const cacheReferenceId = pullFromCache([
        "story-reference" /* STORY_KEY_CACHE.STORY_ID_TO_REFERENCE_ID */,
        storyId,
    ]);
    if (cacheReferenceId === null || cacheReferenceId === void 0 ? void 0 : cacheReferenceId.data) {
        const { data: referenceId } = cacheReferenceId;
        isInTombstone('story', referenceId);
    }
    const cachedAt = client.cache && Date.now();
    const storyCache = pullFromCache(['story', 'get', storyId]);
    if (!storyCache)
        return;
    return {
        data: storyCache.data,
        cachedAt,
    };
};

/* begin_public_function
  id: comment.soft_delete, comment.hard_delete
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const success = await CommentRepository.deleteComment('foobar')
 * ```
 *
 * Deletes a {@link Amity.Comment}
 *
 * @param commentId The {@link Amity.Comment} ID to delete
 * @return A success boolean if the {@link Amity.Comment} was deleted
 *
 * @category Comment API
 * @async
 */
const deleteComment = async (commentId, permanent = false) => {
    var _a;
    const client = getActiveClient();
    const comment = await getComment$2(commentId);
    // API-FIX: This endpoint has not been implemented yet.
    await client.http.delete(`/api/v4/comments/${encodeURIComponent(commentId)}`, {
        params: {
            commentId,
            permanent,
        },
    });
    // to support hard deletion
    const deleted = Object.assign(Object.assign({}, comment.data), { isDeleted: true });
    if (comment.data.referenceType === 'story') {
        const story = await getStoryByStoryId$1(comment.data.referenceId);
        fireEvent('local.story.updated', {
            stories: [story.data],
            categories: [],
            comments: [],
            communities: [],
            communityUsers: [],
            files: [],
            users: [],
        });
    }
    else {
        const post = (_a = pullFromCache(['post', 'get', comment.data.referenceId])) === null || _a === void 0 ? void 0 : _a.data;
        if (post) {
            let removeCount;
            if (!deleted.parentId) {
                // NOTE: delete the parent comment will remove all children comments
                removeCount = deleted.childrenNumber + 1;
            }
            else
                removeCount = 1;
            post.commentsCount -= removeCount;
            fireEvent('local.post.updated', {
                posts: [post],
                categories: [],
                comments: [],
                communities: [],
                communityUsers: [],
                feeds: [],
                files: [],
                postChildren: [],
                users: [],
                videoStreamings: [],
            });
        }
    }
    fireEvent('local.comment.deleted', {
        comments: [deleted],
        commentChildren: [],
        files: [],
        users: [],
        communityUsers: [],
    });
    if (permanent) {
        scheduleTask(() => pushToTombstone('comment', commentId));
    }
    else {
        upsertInCache(['comment', 'get', commentId], { isDeleted: true });
    }
    return deleted;
};
/* end_public_function */

/* begin_public_function
  id: comment.soft_delete
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const success = await CommentRepository.softDeleteComment('foobar')
 * ```
 *
 * Deletes a {@link Amity.Comment}
 *
 * @param commentId The {@link Amity.Comment} ID to delete
 * @return A success boolean if the {@link Amity.Comment} was deleted
 *
 * @category Comment API
 * @async
 */
const softDeleteComment = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/softDeleteComment', commentId);
    const softDeleted = deleteComment(commentId);
    return softDeleted;
};
/* end_public_function */

/* begin_public_function
  id: comment.hard_delete
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const success = await CommentRepository.hardDeleteComment('foobar')
 * ```
 *
 * Deletes a {@link Amity.Comment}
 *
 * @param commentId The {@link Amity.Comment} ID to delete
 * @return A success boolean if the {@link Amity.Comment} was deleted
 *
 * @category Comment API
 * @async
 */
const hardDeleteComment = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/hardDeleteComment', commentId);
    const hardDeleted = deleteComment(commentId, true);
    return hardDeleted;
};
/* end_public_function */

/* begin_public_function
  id: comment.flag
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const flagged = await CommentRepository.flagComment('commentId')
 * ```
 *
 * @param commentId The ID of the comment to flag
 * @returns the created report result
 *
 * @category Comment API
 * @async
 * */
const flagComment = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/flagComment', commentId);
    const { data: payload } = await client.http.post(`/api/v3/comments/${encodeURIComponent(commentId)}/flag`);
    if (client.cache) {
        ingestInCache(payload);
    }
    fireEvent('comment.flagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: comment.unflag
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const unflagged = await CommentRepository.unflagComment('commentId')
 * ```
 *
 * @param commentId The ID of comment to unflag
 * @returns the unflagged result
 *
 * @category Comment API
 * @async
 * */
const unflagComment = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/unflagComment', commentId);
    const { data: payload } = await client.http.delete(`/api/v3/comments/${encodeURIComponent(commentId)}/unflag`);
    if (client.cache) {
        ingestInCache(payload);
    }
    fireEvent('comment.unflagged', payload);
    return !!payload;
};
/* end_public_function */

/* begin_public_function
  id: comment.check_flag_by_me
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk'
 * const isReported = await CommentRepository.isCommentFlaggedByMe('commentId')
 * ```
 *
 * @param commentId The ID of the comment to check if flagged by current user
 * @returns `true` if the comment is flagged by me, `false` if doesn't.
 *
 * @category Comment API
 * @async
 * */
const isCommentFlaggedByMe = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/isCommentFlaggedByMe', commentId);
    const { data: { result }, } = await client.http.get(`/api/v3/comments/${commentId}/isflagbyme`);
    return result;
};
/* end_public_function */

const getComment$1 = async (commentId) => {
    const client = getActiveClient();
    client.log('comment/getComment', commentId);
    isInTombstone('comment', commentId);
    let data;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/comments/${encodeURIComponent(commentId)}`);
        data = response.data;
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('comment', commentId);
        }
        throw error;
    }
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { comments } = data;
    return {
        data: comments.find(comment => comment.commentId === commentId),
        cachedAt,
    };
};
getComment$1.locally = (commentId) => {
    const client = getActiveClient();
    client.log('comment/getComment.locally', commentId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['comment', 'get', commentId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/**
 * ```js
 * import { onCommentDeleteLocal } from '@amityco/ts-sdk'
 * const dispose = onCommentDeleteLocal(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentDeleteLocal = (callback) => createLocalCommentEventSubscriber('local.comment.deleted', callback);

/**
 * ```js
 * import { onLocalCommentReactionAdded } from '@amityco/ts-sdk'
 * const dispose = onLocalCommentReactionAdded(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onLocalCommentReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = ({ comment }) => {
        if (!client.cache) {
            callback(comment);
        }
        else {
            upsertInCache(['comment', 'get', comment.commentId], comment);
            callback(commentLinkedObject(comment));
        }
    };
    return createEventSubscriber(client, 'local.comment.addReaction', 'local.comment.addReaction', filter);
};

/**
 * ```js
 * import { onLocalCommentReactionRemoved } from '@amityco/ts-sdk'
 * const dispose = onLocalCommentReactionRemoved(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onLocalCommentReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = ({ comment }) => {
        if (!client.cache) {
            callback(comment);
        }
        else {
            upsertInCache(['comment', 'get', comment.commentId], comment);
            callback(commentLinkedObject(comment));
        }
    };
    return createEventSubscriber(client, 'local.comment.removeReaction', 'local.comment.removeReaction', filter);
};

/* begin_public_function
  id: comment.get
*/
/**
 * ```js
 * import { CommentRepository } from '@amityco/ts-sdk';
 *
 * let comment;
 *
 * const unsub = CommentRepository.getComment(commentId, response => {
 *   comment = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Comment}
 *
 * @param commentId the ID of the comment to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the comment
 *
 * @category Comment Live Object
 */
const getComment = (commentId, callback) => {
    return liveObject(commentId, callback, 'commentId', getComment$1, [
        onCommentDeleteLocal,
        onCommentDeleted,
        onCommentFlagged,
        onCommentReactionAdded,
        onCommentReactionRemoved,
        onCommentUnflagged,
        onCommentUpdated,
        onLocalCommentReactionAdded,
        onLocalCommentReactionRemoved,
    ]);
};
/* end_public_function */

class CommentPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, includeDeleted } = queryParams, params = __rest(queryParams, ["limit", "includeDeleted"]);
        const baseOptions = {
            type: params.sortBy || queryParams.limit ? 'pagination' : undefined,
        };
        const options = token ? Object.assign(Object.assign({}, baseOptions), { token }) : Object.assign(Object.assign({}, baseOptions), { limit });
        const { data: queryResponse } = await this.http.get(`/api/v3/comments`, {
            params: Object.assign(Object.assign({}, params), { isDeleted: inferIsDeleted(includeDeleted), options }),
        });
        return queryResponse;
    }
}

var EnumCommentActions;
(function (EnumCommentActions) {
    EnumCommentActions["OnCommentCreated"] = "onCommentCreated";
    EnumCommentActions["OnCommentUpdated"] = "onCommentUpdated";
    EnumCommentActions["OnCommentDeleted"] = "onCommentDeleted";
    EnumCommentActions["OnCommentFlagged"] = "onCommentFlagged";
    EnumCommentActions["OnCommentUnflagged"] = "onCommentUnflagged";
    EnumCommentActions["OnCommentReactionAdded"] = "onCommentReactionAdded";
    EnumCommentActions["OnCommentReactionRemoved"] = "onCommentReactionRemoved";
})(EnumCommentActions || (EnumCommentActions = {}));

class CommentQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.comments.map(getResolver('comment')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const comments = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...comments, ...response.comments.map(getResolver('comment'))])] }));
        }
    }
    reactor(action) {
        return (comment) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (this.query.referenceId !== comment.referenceId ||
                this.query.referenceType !== comment.referenceType ||
                !collection) {
                return;
            }
            if (this.query.parentId && this.query.parentId !== comment.parentId) {
                return;
            }
            if (!this.query.parentId && comment.parentId) {
                return;
            }
            if (action === EnumCommentActions.OnCommentCreated) {
                collection.data = [...new Set([comment.commentId, ...collection.data])];
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

/**
 * ```js
 * import { onCommentCreated } from '@amityco/ts-sdk'
 * const dispose = onCommentCreated(comment => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalComment} has been created
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Comment Events
 */
const onCommentCreatedLocal = (callback) => {
    return createLocalCommentEventSubscriber('local.comment.created', callback);
};

class CommentLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['comments', 'collection', queryStreamId];
        const paginationController = new CommentPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new CommentQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareCommentPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onCommentCreatedLocal, action: EnumCommentActions.OnCommentCreated },
            { fn: onCommentDeleteLocal, action: EnumCommentActions.OnCommentDeleted },
            { fn: onCommentCreated, action: EnumCommentActions.OnCommentCreated },
            { fn: onCommentUpdated, action: EnumCommentActions.OnCommentUpdated },
            { fn: onCommentDeleted, action: EnumCommentActions.OnCommentDeleted },
            { fn: onCommentFlagged, action: EnumCommentActions.OnCommentFlagged },
            { fn: onCommentUnflagged, action: EnumCommentActions.OnCommentUnflagged },
            { fn: onCommentReactionAdded, action: EnumCommentActions.OnCommentReactionAdded },
            { fn: onCommentReactionRemoved, action: EnumCommentActions.OnCommentReactionRemoved },
            { fn: onLocalCommentReactionAdded, action: EnumCommentActions.OnCommentReactionAdded },
            { fn: onLocalCommentReactionRemoved, action: EnumCommentActions.OnCommentReactionRemoved },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['comment', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.comment);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let comments = data;
        if (!this.query.includeDeleted) {
            comments = filterByPropEquality(comments, 'isDeleted', false);
        }
        if (this.query.parentId) {
            comments = comments.filter(comment => comment.parentId === this.query.parentId);
        }
        if (typeof this.query.hasFlag === 'boolean') {
            if (this.query.hasFlag) {
                comments = comments.filter(comment => comment.hashFlag != null);
            }
            else {
                comments = comments.filter(comment => comment.hashFlag == null);
            }
        }
        if (this.query.dataTypes) {
            if (this.query.dataTypes.matchType === 'exact') {
                comments = comments.filter(comment => {
                    var _a, _b;
                    const sortedDataTypesQueryValue = ((_a = this.query.dataTypes) === null || _a === void 0 ? void 0 : _a.values.sort()) || [];
                    const sortedDataTypesCommentValue = ((_b = comment.dataTypes) === null || _b === void 0 ? void 0 : _b.sort()) || [];
                    if (sortedDataTypesCommentValue.length !== sortedDataTypesQueryValue.length) {
                        return false;
                    }
                    return sortedDataTypesQueryValue.every((value, index) => value === sortedDataTypesCommentValue[index]);
                });
            }
            if (this.query.dataTypes.matchType === 'any') {
                comments = comments.filter(comment => { var _a; return (_a = this.query.dataTypes) === null || _a === void 0 ? void 0 : _a.values.some(value => { var _a; return (_a = comment.dataTypes) === null || _a === void 0 ? void 0 : _a.includes(value); }); });
            }
        }
        switch (this.query.sortBy) {
            case 'firstCreated':
                comments = comments.sort(sortByFirstCreated);
                break;
            case 'lastCreated':
            default:
                comments = comments.sort(sortByLastCreated);
                break;
        }
        return comments;
    }
}

/* begin_public_function
  id: comment.query
*/
/**
 * ```js
 * import { getComments } from '@amityco/ts-sdk'
 *
 * let comments = []
 * const unsub = getComments({
 *   referenceType: Amity.InternalComment['referenceType'];
 *   referenceId: Amity.InternalComment['referenceId'];
 * }, response => merge(comments, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.InternalComment} for a given target object
 *
 * @param referenceType the type of the target
 * @param referenceId the ID of the target
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Comments Live Collection
 */
const getComments = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log('For using Live Collection feature you need to enable Cache!');
    }
    const timestamp = Date.now();
    log(`getComments(tmpid: ${timestamp}) > listen`);
    const commentsLiveCollection = new CommentLiveCollectionController(params, callback);
    const disposers = commentsLiveCollection.startSubscription();
    const cacheKey = commentsLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getComments(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getCommentByIds: getCommentByIds,
  createComment: createComment,
  updateComment: updateComment,
  deleteComment: deleteComment,
  softDeleteComment: softDeleteComment,
  hardDeleteComment: hardDeleteComment,
  flagComment: flagComment,
  unflagComment: unflagComment,
  isCommentFlaggedByMe: isCommentFlaggedByMe,
  onCommentCreated: onCommentCreated,
  onCommentUpdated: onCommentUpdated,
  onCommentDeleted: onCommentDeleted,
  onCommentFlagged: onCommentFlagged,
  onCommentUnflagged: onCommentUnflagged,
  onCommentReactionAdded: onCommentReactionAdded,
  onCommentReactionRemoved: onCommentReactionRemoved,
  getComment: getComment,
  getComments: getComments
});

/**
 * ```js
 * import { onPostUpdatedLocal } from '@amityco/ts-sdk'
 * const dispose = onPostUpdatedLocal(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onPostUpdatedLocal = (callback) => createLocalPostEventSubscriber('local.post.updated', callback);

/**
 * ```js
 * import { onLocalPostReactionAdded } from '@amityco/ts-sdk'
 * const dispose = onPostReactionAdded(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onLocalPostReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = ({ post }) => {
        if (!client.cache) {
            callback(post);
        }
        else {
            upsertInCache(['post', 'get', post.postId], post);
            callback(post);
        }
    };
    return createEventSubscriber(client, 'local.post.addReaction', 'local.post.addReaction', filter);
};

/**
 * ```js
 * import { onLocalPostReactionRemoved } from '@amityco/ts-sdk'
 * const dispose = onPostReactionRemoved(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been reacted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onLocalPostReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = ({ post }) => {
        if (!client.cache) {
            callback(post);
        }
        else {
            upsertInCache(['post', 'get', post.postId], post);
            callback(post);
        }
    };
    return createEventSubscriber(client, 'local.post.removeReaction', 'local.post.removeReaction', filter);
};

/**
 * ```js
 * import { onLocalPostDeleted } from '@amityco/ts-sdk'
 * const dispose = onLocalPostDeleted(post => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalPost} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Post Events
 */
const onLocalPostDeleted = (callback) => createLocalPostEventSubscriber('local.post.deleted', callback);

/* begin_public_function
  id: post.get
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk';
 *
 * let post;
 *
 * const unsub = PostRepository.getPost(postId, response => {
 *   post = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Post}
 *
 * @param postId the ID of the message to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the sub channel
 *
 * @category Post Live Object
 */
const getPost$1 = (postId, callback) => {
    const responder = (snapshot) => {
        const { data } = snapshot;
        callback(Object.assign(Object.assign({}, snapshot), { data: data ? LinkedObject.post(snapshot.data) : data }));
    };
    return liveObject(postId, responder, 'postId', getPost$2, [
        onPostApproved,
        onPostDeclined,
        onLocalPostReactionAdded,
        onLocalPostReactionRemoved,
        (callback) => {
            return onPostDeleted((post) => {
                var _a;
                let targetPost = post;
                // check if the deleted post is a child of the target post
                if (post.parentPostId === postId && post.isDeleted) {
                    const parentPost = (_a = pullFromCache([
                        'post',
                        'get',
                        post.parentPostId,
                    ])) === null || _a === void 0 ? void 0 : _a.data;
                    if (parentPost) {
                        parentPost.children = parentPost.children.filter(childId => childId !== post.postId);
                        pushToCache(['post', 'get', parentPost.postId], parentPost);
                        // if the deleted post is a child of the target post, then the target post is the parent post
                        targetPost = parentPost;
                    }
                }
                callback(targetPost);
            });
        },
        onPostFlagged,
        (callback) => {
            return onPostReactionAdded((post) => {
                callback(LinkedObject.post(post));
            });
        },
        (callback) => {
            return onPostReactionRemoved((post) => {
                callback(LinkedObject.post(post));
            });
        },
        onPostUnflagged,
        onPostUpdated,
        onPostUpdatedLocal,
        onLocalPostDeleted,
        convertEventPayload((callback) => {
            return onCommentCreated(async (comment) => {
                if (comment.referenceId === postId) {
                    await getPost$2(postId);
                    callback(comment);
                }
            });
        }, 'referenceId', 'post'),
        convertEventPayload((callback) => {
            return onCommentDeleted(async (comment) => {
                if (comment.referenceId === postId) {
                    await getPost$2(postId);
                    callback(comment);
                }
            });
        }, 'referenceId', 'post'),
    ]);
};
/* end_public_function */

class PostPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT, includeDeleted, matchingOnlyParentPost } = queryParams, params = __rest(queryParams, ["limit", "includeDeleted", "matchingOnlyParentPost"]);
        const { dataTypes } = params;
        const baseOptions = {
            type: params.sortBy || queryParams.limit ? 'pagination' : undefined,
        };
        const options = token ? Object.assign(Object.assign({}, baseOptions), { token }) : Object.assign(Object.assign({}, baseOptions), { limit });
        const { data: queryResponse } = await this.http.get(`/api/v4/posts`, {
            params: Object.assign(Object.assign({}, params), { isDeleted: inferIsDeleted(includeDeleted), 
                /*
                 * when creating post like image, file, video BE will create 2 posts
                 * 1. parent post to store text with dataType=text
                 * 2. child post to store dataTypes post data
                 *
                 * By default, BE queries only parent post
                 */
                matchingOnlyParentPost: matchingOnlyParentPost !== null && matchingOnlyParentPost !== void 0 ? matchingOnlyParentPost : !(dataTypes === null || dataTypes === void 0 ? void 0 : dataTypes.length), options }),
        });
        return queryResponse;
    }
}

var EnumPostActions;
(function (EnumPostActions) {
    EnumPostActions["OnPostCreated"] = "onPostCreated";
    EnumPostActions["OnPostUpdated"] = "onPostUpdated";
    EnumPostActions["OnPostDeleted"] = "onPostDeleted";
    EnumPostActions["OnPostFlagged"] = "onPostFlagged";
    EnumPostActions["OnPostUnflagged"] = "onPostUnflagged";
    EnumPostActions["OnPostReactionAdded"] = "onPostReactionAdded";
    EnumPostActions["OnPostReactionRemoved"] = "onPostReactionRemoved";
    EnumPostActions["OnPostApproved"] = "onPostApproved";
    EnumPostActions["OnPostDeclined"] = "onPostDeclined";
})(EnumPostActions || (EnumPostActions = {}));

class PostQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.posts.map(getResolver('post')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const posts = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...posts, ...response.posts.map(getResolver('post'))])] }));
        }
    }
    reactor(action) {
        return (post) => {
            var _a, _b;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (post.parentPostId && post.isDeleted) {
                const parentPost = (_b = pullFromCache([
                    'post',
                    'get',
                    post.parentPostId,
                ])) === null || _b === void 0 ? void 0 : _b.data;
                if (!parentPost || (parentPost === null || parentPost === void 0 ? void 0 : parentPost.targetId) !== this.query.targetId)
                    return;
                parentPost.children = parentPost.children.filter(childId => childId !== post.postId);
                pushToCache(['post', 'get', parentPost.postId], parentPost);
            }
            else {
                if (this.query.targetId !== post.targetId)
                    return;
                if (this.query.targetType !== post.targetType)
                    return;
            }
            if (action === EnumPostActions.OnPostDeclined) {
                collection.data = collection.data.filter(postId => postId !== post.postId);
            }
            if (action === EnumPostActions.OnPostCreated || action === EnumPostActions.OnPostApproved) {
                collection.data = [...new Set([post.postId, ...collection.data])];
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

const getPost = async (postId) => {
    const client = getActiveClient();
    client.log('post/getPost', postId);
    isInTombstone('post', postId);
    let payload;
    try {
        // API-FIX: endpoint should not be /list, parameters should be querystring.
        const response = await client.http.get(`/api/v3/posts/${encodeURIComponent(postId)}`);
        payload = response.data;
    }
    catch (error) {
        if (checkIfShouldGoesToTombstone(error === null || error === void 0 ? void 0 : error.code)) {
            pushToTombstone('post', postId);
        }
        throw error;
    }
    const data = prepareMembershipPayload(payload, 'communityUsers');
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { posts } = data;
    const result = posts.find(post => post.postId === postId);
    return {
        data: result,
        cachedAt,
    };
};
getPost.locally = (postId) => {
    const client = getActiveClient();
    client.log('post/getPost.locally', postId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['post', 'get', postId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

class PostLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['posts', 'collection', queryStreamId];
        const paginationController = new PostPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new PostQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), preparePostPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onPostCreated, action: EnumPostActions.OnPostCreated },
            { fn: onPostUpdated, action: EnumPostActions.OnPostUpdated },
            { fn: onPostUpdatedLocal, action: EnumPostActions.OnPostUpdated },
            { fn: onPostDeleted, action: EnumPostActions.OnPostDeleted },
            { fn: onPostFlagged, action: EnumPostActions.OnPostFlagged },
            { fn: onPostUnflagged, action: EnumPostActions.OnPostUnflagged },
            { fn: onPostApproved, action: EnumPostActions.OnPostApproved },
            { fn: onPostDeclined, action: EnumPostActions.OnPostDeclined },
            { fn: onPostReactionAdded, action: EnumPostActions.OnPostReactionAdded },
            { fn: onPostReactionRemoved, action: EnumPostActions.OnPostReactionRemoved },
            { fn: onLocalPostReactionAdded, action: EnumPostActions.OnPostReactionAdded },
            { fn: onLocalPostReactionRemoved, action: EnumPostActions.OnPostReactionRemoved },
            { fn: onLocalPostDeleted, action: EnumPostActions.OnPostDeleted },
            {
                fn: convertEventPayload((callback) => {
                    return onCommentCreated(async (comment) => {
                        var _a;
                        const currentCollection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                        if (!currentCollection || currentCollection.data.includes(comment.referenceId))
                            return;
                        await getPost(comment.referenceId);
                        callback(comment);
                    });
                }, 'referenceId', 'post'),
                action: EnumPostActions.OnPostUpdated,
            },
            {
                fn: convertEventPayload((callback) => {
                    return onCommentDeleted(async (comment) => {
                        var _a;
                        const currentCollection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
                        if (!currentCollection || currentCollection.data.includes(comment.referenceId))
                            return;
                        await getPost(comment.referenceId);
                        callback(comment);
                    });
                }, 'referenceId', 'post'),
                action: EnumPostActions.OnPostUpdated,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(id => pullFromCache(['post', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.post);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        var _a;
        let posts = data;
        if (!this.query.includeDeleted) {
            posts = filterByPropEquality(posts, 'isDeleted', false);
        }
        if (this.query.tags) {
            posts = posts.filter(p => { var _a; return (_a = p.tags) === null || _a === void 0 ? void 0 : _a.some(t => { var _a; return (_a = this.query.tags) === null || _a === void 0 ? void 0 : _a.includes(t); }); });
        }
        if (this.query.targetType === 'community' && this.query.feedType) {
            posts = filterByFeedType(posts, this.query.feedType);
        }
        if ((_a = this.query.dataTypes) === null || _a === void 0 ? void 0 : _a.length) {
            posts = filterByPostDataTypes(posts, this.query.dataTypes);
        }
        switch (this.query.sortBy) {
            case 'firstCreated':
                posts = posts.sort(sortByFirstCreated);
                break;
            case 'lastCreated':
            default:
                posts = posts.sort(sortByLastCreated);
                break;
        }
        return posts;
    }
}

/* begin_public_function
  id: post.query
*/
/**
 * ```js
 * import { PostRepository } from '@amityco/ts-sdk'
 *
 * let posts = []
 * const unsub = PostRepository.getPosts({
 *   targetType: Amity.PostTargetType,
 *   targetId: Amity.Post['targetId'],
 * }, response => merge(posts, response.data))
 * ```
 *
 * Observe all mutations on a list of {@link Amity.Post} for a given target object
 *
 * @param params.targetType the type of the target
 * @param params.targetId the ID of the target
 * @param callback the function to call when new data are available
 * @param config
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the messages
 *
 * @category Posts Live Collection
 */
const getPosts = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getPosts(tmpid: ${timestamp}) > listen`);
    const postsLiveCollection = new PostLiveCollectionController(params, callback);
    const disposers = postsLiveCollection.startSubscription();
    const cacheKey = postsLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getPosts(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};
/* end_public_function */

class PinnedPostPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const params = __rest(queryParams, ["limit"]);
        const { communityId, placement } = params;
        const path = placement
            ? `/api/v1/pinned-posts/communities/${communityId}/${placement}`
            : `/api/v1/pinned-posts/communities/${communityId}`;
        const { data: queryResponse } = await this.http.get(path);
        return queryResponse;
    }
}

class PinnedPostQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    // eslint-disable-next-line class-methods-use-this
    async saveToMainDB(response) {
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(response, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.pins.map(getResolver('pin')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const pinnedPosts = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...pinnedPosts, ...response.pins.map(getResolver('pin'))])] }));
            this.notifyChange({
                origin: "server" /* Amity.LiveDataOrigin.SERVER */,
                loading: false,
            });
        }
    }
}

class PinnedPostLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['pinnedPosts', 'collection', queryStreamId];
        const paginationController = new PinnedPostPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new PinnedPostQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), response => response);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    // eslint-disable-next-line class-methods-use-this
    startSubscription() {
        return [];
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        let data = ((_b = collection.data
            .map(id => pullFromCache(['pin', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.pinnedPost);
        data = this.applyFilter(data);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            data,
            loading,
            error,
        });
    }
    applyFilter(data) {
        let pinnedPost = data;
        switch (this.query.sortBy) {
            case 'lastCreated':
                pinnedPost = pinnedPost.sort(({ post: postA }, { post: postB }) => sortByLastCreated({ createdAt: postA === null || postA === void 0 ? void 0 : postA.createdAt }, { createdAt: postB === null || postB === void 0 ? void 0 : postB.createdAt }));
                break;
        }
        return pinnedPost;
    }
}

/**
 * Get pinned posts for a community
 *
 * @param communityId the ID of the community
 * @param placement the placement of the pinned post ('announcement' or 'default'), or null to fetch all pinned posts
 * @returns the associated pinned post(s)
 *
 * @category Pined Posts Live Collection
 *
 */
const getPinnedPosts = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getPinnedPosts(tmpid: ${timestamp}) > listen`);
    const pinnedPostLiveCollection = new PinnedPostLiveCollectionController(params, callback);
    const disposers = pinnedPostLiveCollection.startSubscription();
    const cacheKey = pinnedPostLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getPinnedPosts(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

class GlobalPinnedPostPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        __rest(queryParams, ["limit"]);
        const path = '/api/v1/pinned-posts/global';
        const { data: queryResponse } = await this.http.get(path);
        return queryResponse;
    }
}

class GlobalPinnedPostQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    // eslint-disable-next-line class-methods-use-this
    async saveToMainDB(response) {
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(response, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.pins.map(getResolver('pin')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const pinnedPosts = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...pinnedPosts, ...response.pins.map(getResolver('pin'))])] }));
            this.notifyChange({
                origin: "server" /* Amity.LiveDataOrigin.SERVER */,
                loading: false,
            });
        }
    }
    reactor(action) {
        return (post) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (action === EnumPostActions.OnPostDeleted) {
                collection.data = collection.data.filter(referenceId => referenceId !== `global#${post.postId}`);
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class GlobalPinnedPostLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['pinnedPosts', 'collection', queryStreamId];
        const paginationController = new GlobalPinnedPostPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new GlobalPinnedPostQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), response => response);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    // eslint-disable-next-line class-methods-use-this
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onLocalPostDeleted, action: EnumPostActions.OnPostDeleted },
            {
                fn: onPostDeleted,
                action: EnumPostActions.OnPostDeleted,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = ((_b = collection.data
            .map(id => pullFromCache(['pin', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.pinnedPost);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            data,
            loading,
            error,
        });
    }
}

/**
 * Get global pinned posts
 *
 * @returns the global pinned post(s)
 *
 * @category Pined Posts Live Collection
 *
 */
const getGlobalPinnedPosts = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getGlobalPinnedPosts(tmpid: ${timestamp}) > listen`);
    const globalPinnedPostLiveCollection = new GlobalPinnedPostLiveCollectionController(params, callback);
    const disposers = globalPinnedPostLiveCollection.startSubscription();
    const cacheKey = globalPinnedPostLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getGlobalPinnedPosts(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

class SemanticSearchPostPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const baseOptions = {
            type: queryParams.limit ? 'pagination' : undefined,
        };
        const options = token ? Object.assign(Object.assign({}, baseOptions), { token }) : Object.assign(Object.assign({}, baseOptions), { limit });
        const { data: queryResponse } = await this.http.get(`/api/v1/semantic-search/posts`, {
            params: Object.assign(Object.assign({}, params), { options }),
        });
        return queryResponse;
    }
}

function preparePostResponse(response) {
    return response.posts.map(post => {
        const postScore = response.searchResult.find(result => result.postId === post.postId);
        return `${post.postId}:${postScore.score}`;
    });
}
function getPostIdsFromCache(cacheData) {
    return (cacheData !== null && cacheData !== void 0 ? cacheData : []).map(postIdWithScore => {
        return postIdWithScore.split(':')[0];
    });
}

class SemanticSearchPostQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: preparePostResponse(response),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const posts = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...posts, ...preparePostResponse(response)])] }));
        }
    }
    reactor(action) {
        return (post) => {
            var _a, _b;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            if (post.parentPostId && post.isDeleted) {
                const parentSemanticSearchPost = (_b = pullFromCache([
                    'post',
                    'get',
                    post.parentPostId,
                ])) === null || _b === void 0 ? void 0 : _b.data;
                if (!parentSemanticSearchPost || (parentSemanticSearchPost === null || parentSemanticSearchPost === void 0 ? void 0 : parentSemanticSearchPost.targetId) !== this.query.targetId)
                    return;
                parentSemanticSearchPost.children = parentSemanticSearchPost.children.filter(childId => childId !== post.postId);
                pushToCache(['post', 'get', parentSemanticSearchPost.postId], parentSemanticSearchPost);
            }
            else {
                if (this.query.targetId !== post.targetId)
                    return;
                if (this.query.targetType !== post.targetType)
                    return;
            }
            if (action === EnumPostActions.OnPostDeclined) {
                collection.data = collection.data.filter(postId => postId !== post.postId);
            }
            if (action === EnumPostActions.OnPostCreated || action === EnumPostActions.OnPostApproved) {
                collection.data = [...new Set([post.postId, ...collection.data])];
            }
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class SemanticSearchPostLiveCollectionController extends LiveCollectionController {
    constructor(inputQuery, callback) {
        const query = Object.assign(Object.assign({}, inputQuery), { matchingOnlyParentPost: inputQuery.matchingOnlyParentPost == null ? true : inputQuery.matchingOnlyParentPost, dataTypes: inputQuery.dataTypes == null ? ['text', 'image'] : inputQuery.dataTypes });
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['posts', 'collection', queryStreamId];
        const paginationController = new SemanticSearchPostPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new SemanticSearchPostQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareSemanticSearchPostPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onPostUpdated, action: EnumPostActions.OnPostUpdated },
            { fn: onPostDeleted, action: EnumPostActions.OnPostDeleted },
            { fn: onPostFlagged, action: EnumPostActions.OnPostFlagged },
            {
                fn: onPostUnflagged,
                action: EnumPostActions.OnPostUnflagged,
            },
            { fn: onPostApproved, action: EnumPostActions.OnPostApproved },
            { fn: onPostDeclined, action: EnumPostActions.OnPostDeclined },
            {
                fn: onPostReactionAdded,
                action: EnumPostActions.OnPostReactionAdded,
            },
            {
                fn: onPostReactionRemoved,
                action: EnumPostActions.OnPostReactionRemoved,
            },
            {
                fn: convertEventPayload((callback) => {
                    return onCommentCreated(async (comment) => {
                        const collectionCache = pullFromCache(this.cacheKey);
                        const currentCollectionPostIds = getPostIdsFromCache(collectionCache === null || collectionCache === void 0 ? void 0 : collectionCache.data);
                        if (currentCollectionPostIds.includes(comment.referenceId))
                            return;
                        await getPost$2(comment.referenceId);
                        callback(comment);
                    });
                }, 'referenceId', 'post'),
                action: EnumPostActions.OnPostUpdated,
            },
            {
                fn: convertEventPayload((callback) => {
                    return onCommentDeleted(async (comment) => {
                        const collectionCache = pullFromCache(this.cacheKey);
                        const currentCollectionPostIds = getPostIdsFromCache(collectionCache === null || collectionCache === void 0 ? void 0 : collectionCache.data);
                        if (currentCollectionPostIds.includes(comment.referenceId))
                            return;
                        await getPost$2(comment.referenceId);
                        callback(comment);
                    });
                }, 'referenceId', 'post'),
                action: EnumPostActions.OnPostUpdated,
            },
        ]);
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = this.applyFilter((_b = collection.data
            .map(postIdWithScore => {
            const [postId, score] = postIdWithScore.split(':');
            return {
                postId,
                score: parseFloat(score),
            };
        })
            .sort((a, b) => b.score - a.score)
            .map(({ postId }) => pullFromCache(['post', 'get', postId]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.post);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        let posts = data;
        if (this.query.targetType) {
            posts = posts.filter(post => post.targetType === this.query.targetType);
        }
        if (this.query.targetId) {
            posts = posts.filter(post => post.targetId === this.query.targetId);
        }
        if (this.query.dataTypes && this.query.dataTypes.length > 0) {
            posts = filterByPostDataTypes(posts, this.query.dataTypes);
        }
        return posts;
    }
}

/**
 * search posts by semantic search
 *
 * @returns the associated pinned post(s)
 *
 * @category Posts Live Collection
 *
 */
const semanticSearchPosts = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`semanticSearchPosts(tmpid: ${timestamp}) > listen`);
    const semanticSearchPostLiveCollection = new SemanticSearchPostLiveCollectionController(params, callback);
    const disposers = semanticSearchPostLiveCollection.startSubscription();
    const cacheKey = semanticSearchPostLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`semanticSearchPosts(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getPostByIds: getPostByIds,
  createPost: createPost,
  editPost: editPost,
  deletePost: deletePost,
  softDeletePost: softDeletePost,
  hardDeletePost: hardDeletePost,
  approvePost: approvePost,
  declinePost: declinePost,
  flagPost: flagPost,
  unflagPost: unflagPost,
  isPostFlaggedByMe: isPostFlaggedByMe,
  onPostCreated: onPostCreated,
  onPostUpdated: onPostUpdated,
  onPostDeleted: onPostDeleted,
  onPostApproved: onPostApproved,
  onPostDeclined: onPostDeclined,
  onPostFlagged: onPostFlagged,
  onPostUnflagged: onPostUnflagged,
  onPostReactionAdded: onPostReactionAdded,
  onPostReactionRemoved: onPostReactionRemoved,
  getPost: getPost$1,
  getPosts: getPosts,
  getPinnedPosts: getPinnedPosts,
  getGlobalPinnedPosts: getGlobalPinnedPosts,
  semanticSearchPosts: semanticSearchPosts
});

/* begin_public_function
  id: stream.create
*/
/**
 * ```js
 * import { createStream } from '@amityco/ts-sdk'
 * const created = await createStream({ title: 'my stream', 'thumbnailFileId': fileId  })
 * ```
 *
 * Creates an {@link Amity.InternalStream}
 *
 * @param bundle The data necessary to create a new {@link Amity.InternalStream}
 * @returns The newly created {@link Amity.InternalStream}
 *
 * @category Stream API
 * @async
 */
const createStream = async (bundle) => {
    const client = getActiveClient();
    client.log('stream/createStream', bundle);
    const { data } = await client.http.post('/api/v3/video-streaming', bundle);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { videoStreamings } = data;
    return {
        data: LinkedObject.stream(videoStreamings[0]),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: stream.update
*/
/**
 * ```js
 * import { updateStream } from '@amityco/ts-sdk'
 * const updated = await updateStream(streamId, { title: 'foobar' })
 * ```
 *
 * Updates an {@link Amity.Stream}
 *
 * @param streamId The ID of the {@link Amity.Stream} to edit
 * @param patch The patch data to apply
 * @returns the updated {@link Amity.Stream} object
 *
 * @category Stream API
 * @async
 */
const updateStream = async (streamId, patch) => {
    const client = getActiveClient();
    client.log('stream/updateStream', streamId, patch);
    const { data } = await client.http.put(`/api/v3/video-streaming/${streamId}`, patch);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { videoStreamings } = data;
    return {
        data: LinkedObject.stream(videoStreamings.find(stream => stream.streamId === streamId)),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: stream.get
*/
/**
 * ```js
 * import { getStream } from '@amityco/ts-sdk'
 * const stream = await getStream('foobar')
 * ```
 *
 * Fetches a {@link Amity.Stream} object
 *
 * @param streamId the ID of the {@link Amity.Stream} to fetch
 * @returns the associated {@link Amity.Stream} object
 *
 * @category Stream API
 * @async
 */
const getStream = async (streamId) => {
    const client = getActiveClient();
    client.log('stream/getStream', streamId);
    const { data } = await client.http.get(`/api/v3/video-streaming/${streamId}`);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { videoStreamings } = data;
    return {
        data: videoStreamings.find(stream => stream.streamId === streamId),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getStream } from '@amityco/ts-sdk'
 * const stream = getStream.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Stream} object
 *
 * @param streamId the ID of the {@link Amity.Stream} to fetch
 * @returns the associated {@link Amity.Stream} object
 *
 * @category Stream API
 */
getStream.locally = (streamId) => {
    const client = getActiveClient();
    client.log('stream/getStream', streamId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['stream', 'get', streamId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

// import { unwrapPayload } from '~/core/transports'
/* begin_public_function
  id: stream.delete
*/
/**
 * ```js
 * import { deleteStream } from '@amityco/ts-sdk'
 * const success = await deleteStream(streamId)
 * ```
 *
 * Deletes a {@link Amity.InternalStream}
 *
 * @param streamId The {@link Amity.InternalStream} ID to delete
 * @return A success boolean if the {@link Amity.InternalStream} was deleted
 *
 * @category Stream API
 * @async
 */
const deleteStream = async (streamId) => {
    const client = getActiveClient();
    client.log('stream/deleteStream', streamId);
    const stream = await getStream(streamId);
    // API-FIX: it returns { success: boolean } but seems it should be Amity.Response<{ success: boolean }
    // API-FIX: swagger docs are wrong!
    const { data } = await client.http.delete(`/api/v3/video-streaming/${streamId}`);
    const { success } = data; // unwrapPayload(data)
    const deleted = Object.assign(Object.assign({}, stream.data), { isDeleted: true });
    upsertInCache(['stream', 'get', streamId], deleted);
    return success;
};
/* end_public_function */

/**
 * ```js
 * import { disposeStream } from '@amityco/ts-sdk'
 * const stream = await disposeStream(streamId)
 * ```
 *
 * Dispose a {@link Amity.InternalStream}.
 * Streaming status will be updated to "ended" and streaming url will be invalidated
 *
 * @param streamId The {@link Amity.InternalStream} ID to dispose
 * @returns the associated {@link Amity.InternalStream} object
 *
 * @category Stream API
 * @async
 */
const disposeStream = async (streamId) => {
    const client = getActiveClient();
    client.log('stream/disposeStream', streamId);
    const { data } = await client.http.delete(`/api/v3/video-streaming/${streamId}/streaming-url`);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { videoStreamings } = data;
    return {
        data: videoStreamings.find(stream => stream.streamId === streamId),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { onStreamStarted } from '@amityco/ts-sdk'
 * const dispose = onStreamStarted(stream => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalStream} has started airing
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Stream Events
 */
const onStreamStarted = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.videoStreamings[0]);
    };
    return createEventSubscriber(client, 'stream/onStreamStarted', 'video-streaming.didStart', filter);
};

/**
 * ```js
 * import { onStreamStopped } from '@amityco/ts-sdk'
 * const dispose = onStreamStopped(stream => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalStream} has stopped airing
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Stream Events
 */
const onStreamStopped = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.videoStreamings[0]);
    };
    return createEventSubscriber(client, 'stream/onStreamStropped', 'video-streaming.didStop', filter);
};

/**
 * ```js
 * import { onStreamRecorded } from '@amityco/ts-sdk'
 * const dispose = onStreamRecorded(stream => {
 *   // ...
 * })
 * ```
 *
 * Fired when the recordings of a {@link Amity.InternalStream} are available
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Stream Events
 */
const onStreamRecorded = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.videoStreamings[0]);
    };
    return createEventSubscriber(client, 'stream/onStreamRecorded', 'video-streaming.didRecord', filter);
};

/**
 * ```js
 * import { onStreamFlagged } from '@amityco/ts-sdk'
 * const dispose = onStreamFlagged(stream => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalStream} has started airing
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Stream Events
 */
const onStreamFlagged = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.videoStreamings[0]);
    };
    return createEventSubscriber(client, 'stream/onStreamFlagged', 'video-streaming.didFlag', filter);
};

/**
 * ```js
 * import { onStreamTerminated } from '@amityco/ts-sdk'
 * const dispose = onStreamTerminated(stream => {
 *   // ...
 * })
 * ```
 *
 * Fired when a {@link Amity.InternalStream} has started airing
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Stream Events
 */
const onStreamTerminated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        ingestInCache(payload);
        callback(payload.videoStreamings[0]);
    };
    return createEventSubscriber(client, 'stream/onStreamTerminated', 'video-streaming.didTerminate', filter);
};

/* eslint-disable no-use-before-define */
/* begin_public_function
  id: stream.get
*/
/**
 * ```js
 * import { StreamRepository } from '@amityco/ts-sdk'
 * const unsub = StreamRepository.getStreamById('foobar')
 * unsub()
 * ```
 *
 * Fetches a {@link Amity.Stream} object
 *
 * @param streamId the ID of the {@link Amity.Stream} to get
 * @param callback
 * @returns the associated {@link Amity.Stream} object
 *
 * @category Stream Live Object
 */
const getStreamById = (streamId, callback) => {
    const reactor = (snapshot) => {
        const { data } = snapshot;
        callback(Object.assign(Object.assign({}, snapshot), { data: data ? LinkedObject.stream(snapshot.data) : data }));
    };
    return liveObject(streamId, reactor, 'streamId', getStream, [
        onStreamRecorded,
        onStreamStarted,
        onStreamStopped,
        onStreamFlagged,
        onStreamTerminated,
    ]);
};
/* end_public_function */
/**
 * ```js
 * import { StreamRepository } from '@amityco/ts-sdk'
 * const stream = StreamRepository.getStreamById.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Stream} live object
 *
 * @param streamId the ID of the {@link Amity.Stream} to fetch
 * @returns the associated {@link Amity.Stream} live object
 *
 * @category Stream API
 */
getStreamById.locally = (streamId) => {
    const client = getActiveClient();
    client.log('stream/getStreamById', streamId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['stream', 'get', streamId]);
    if (!cached)
        return;
    return {
        data: LinkedObject.stream(cached.data),
        cachedAt: cached.cachedAt,
    };
};

class GetStreamsPageController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v3/video-streaming`, {
            params: Object.assign(Object.assign({}, params), { options }),
        });
        return Object.assign(Object.assign({}, queryResponse.results), { paging: queryResponse.paging });
    }
}

class GetStreamsQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, paginationController) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.paginationController = paginationController;
    }
    // eslint-disable-next-line class-methods-use-this
    saveToMainDB(response) {
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(response, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.videoStreamings.map(getResolver('stream')),
                query: this.query,
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const messages = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: direction === 'next'
                    ? [...new Set([...messages, ...response.videoStreamings.map(getResolver('stream'))])]
                    : [...new Set([...response.videoStreamings.map(getResolver('stream')), ...messages])] }));
        }
    }
    reactor(action) {
        return (payload) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            collection.data = [...new Set([payload.streamId, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class GetStreamsLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['streams', 'collection', queryStreamId];
        const paginationController = new GetStreamsPageController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.applyFilter = (data) => {
            let streams = filterByPropEquality(data, 'isDeleted', this.query.isDeleted);
            streams = streams.sort(this.query.sortBy === 'lastCreated' ? sortByLastCreated : sortByFirstCreated);
            return streams;
        };
        this.query = query;
        this.queryStreamController = new GetStreamsQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), paginationController);
        this.paginationController = paginationController;
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    notifyChange({ origin, loading, error }) {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        let data = collection.data
            .map(streamId => pullFromCache(['stream', 'get', streamId]))
            .filter(Boolean)
            .map(stream => LinkedObject.stream(stream.data));
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        data = this.applyFilter(data);
        this.callback({
            onNextPage: () => this.loadPage({ initial: false, direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onStreamRecorded, action: 'onStreamRecorded' },
            { fn: onStreamStarted, action: 'onStreamStarted' },
            { fn: onStreamStopped, action: 'onStreamStopped' },
            { fn: onStreamFlagged, action: 'onStreamFlagged' },
            { fn: onStreamTerminated, action: 'onStreamTerminated' },
        ]);
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    persistModel(response) {
        this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
}

const getStreams = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getStreams(tmpid: ${timestamp}) > listen`);
    const liveCollection = new GetStreamsLiveCollectionController(params, callback);
    const disposers = liveCollection.startSubscription();
    const cacheKey = liveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getStreams(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createStream: createStream,
  updateStream: updateStream,
  deleteStream: deleteStream,
  disposeStream: disposeStream,
  onStreamStarted: onStreamStarted,
  onStreamStopped: onStreamStopped,
  onStreamRecorded: onStreamRecorded,
  onStreamFlagged: onStreamFlagged,
  onStreamTerminated: onStreamTerminated,
  getStreamById: getStreamById,
  getStreams: getStreams
});

/* begin_public_function
  id: poll.create
*/
/**
 * ```js
 * import { createPoll } from '@amityco/ts-sdk'
 * const created = await createPoll({
 *   question: 'question',
 *   answers: [
 *      { dataType: 'text', data: 'answer1' },
 *      { dataType: 'text', data: 'answer2' },
 *   ],
 *   closedIn: 1649136484
 * }))
 * ```
 *
 * Creates an {@link Amity.Poll}
 *
 * @param bundle The data necessary to create a new {@link Amity.Poll}
 * @returns The newly created {@link Amity.Poll}
 *
 * @category Poll API
 * @async
 */
const createPoll = async (bundle) => {
    const client = getActiveClient();
    client.log('post/createPoll', bundle);
    const { data } = await client.http.post('/api/v3/polls', bundle);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { polls } = data;
    return {
        data: polls[0],
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: poll.close
*/
/**
 * ```js
 * import { closePoll } from '@amityco/ts-sdk'
 * const updated = await closePoll(pollId)
 * ```
 *
 * Updates an {@link Amity.Poll}
 *
 * @param pollId The ID of the {@link Amity.Poll} to close
 * @returns the updated {@link Amity.Poll} object
 *
 * @category Poll API
 * @async
 */
const closePoll = async (pollId) => {
    const client = getActiveClient();
    client.log('user/closePoll', pollId);
    const { data } = await client.http.put(`/api/v3/polls/${encodeURIComponent(pollId)}`, { status: 'closed' });
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    fireEvent('poll.updated', data);
    const { polls } = data;
    return {
        data: polls.find(poll => poll.pollId === pollId),
        cachedAt,
    };
};
/* end_public_function */

/* begin_public_function
  id: poll.get
*/
/**
 * ```js
 * import { getPoll } from '@amityco/ts-sdk'
 * const poll = await getPoll('foobar')
 * ```
 *
 * Fetches a {@link Amity.Poll} object
 *
 * @param pollId the ID of the {@link Amity.Poll} to fetch
 * @returns the associated {@link Amity.Poll} object
 *
 * @category Poll API
 * @async
 */
const getPoll$1 = async (pollId) => {
    const client = getActiveClient();
    client.log('poll/getPoll', pollId);
    const { data } = await client.http.get(`/api/v3/polls/${pollId}`);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { polls } = data;
    return {
        data: polls.find(poll => poll.pollId === pollId),
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { getPoll } from '@amityco/ts-sdk'
 * const poll = getPoll.locally('foobar')
 * ```
 *
 * Fetches a {@link Amity.Poll} object
 *
 * @param pollId the ID of the {@link Amity.Poll} to fetch
 * @returns the associated {@link Amity.Poll} object
 *
 * @category Poll API
 */
getPoll$1.locally = (pollId) => {
    const client = getActiveClient();
    client.log('poll/getPoll', pollId);
    if (!client.cache)
        return;
    const cached = pullFromCache(['poll', 'get', pollId]);
    if (!cached)
        return;
    return {
        data: cached.data,
        cachedAt: cached.cachedAt,
    };
};

/* begin_public_function
  id: poll.delete
*/
/**
 * ```js
 * import { deletePoll } from '@amityco/ts-sdk'
 * const success = await deletePoll(pollId)
 * ```
 *
 * Deletes a {@link Amity.Poll}
 *
 * @param pollId The {@link Amity.Poll} ID to delete
 * @return A success boolean if the {@link Amity.Poll} was deleted
 *
 * @category Poll API
 * @async
 */
const deletePoll = async (pollId) => {
    const client = getActiveClient();
    client.log('poll/deletePoll', pollId);
    const poll = await getPoll$1(pollId);
    // API-FIX: it returns { success: boolean } but seems it should be Amity.Response<{ success: boolean }
    const { data } = await client.http.delete(`/api/v3/polls/${pollId}`);
    const { success } = data; // unwrapPayload(data)
    const deleted = Object.assign(Object.assign({}, poll.data), { isDeleted: true });
    upsertInCache(['poll', 'get', pollId], deleted);
    fireEvent('poll.deleted', { polls: [deleted], users: [] });
    return success;
};
/* end_public_function */

/* begin_public_function
  id: poll.vote
*/
/**
 * ```js
 * import { votePoll } from '@amityco/ts-sdk'
 * const voted = await votePoll(pollId)
 * ```
 *
 * Votes for an {@link Amity.Poll}
 *
 * @param pollId The ID of the {@link Amity.Poll} to vote
 * @param answerIds The IDs of the {@link Amity.Poll} answers to vote {@link Amity.Poll}
 * @returns the updated {@link Amity.Poll} object
 *
 * @category Poll API
 * @async
 */
const votePoll = async (pollId, answerIds) => {
    const client = getActiveClient();
    client.log('user/votePoll', pollId);
    const { data } = await client.http.post(`/api/v3/polls/${encodeURIComponent(pollId)}/votes`, { pollId, answerIds });
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        ingestInCache(data, { cachedAt });
    const { polls } = data;
    fireEvent('poll.updated', data);
    return {
        data: polls.find(poll => poll.pollId === pollId),
        cachedAt,
    };
};
/* end_public_function */

/**
 * ```js
 * import { onPollUpdated } from '@amityco/ts-sdk'
 * const dispose = onPollUpdated(poll => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Poll} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Poll Events
 */
const onPollUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (client.cache)
            ingestInCache(payload);
        callback(payload.polls[0]);
    };
    return createEventSubscriber(client, 'poll/onPollUpdated', 'poll.updated', filter);
};

/**
 * ```js
 * import { onPollDeleted } from '@amityco/ts-sdk'
 * const dispose = onPollDeleted(poll => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.Poll} has been deleted
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category Poll Events
 */
const onPollDeleted = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        if (client.cache)
            ingestInCache(payload);
        callback(payload.polls[0]);
    };
    return createEventSubscriber(client, 'poll/onPollDeleted', 'poll.deleted', filter);
};

/* begin_public_function
  id: poll.get
*/
/**
 * ```js
 * import { PollRepository } from '@amityco/ts-sdk';
 *
 * let poll;
 *
 * const unsub = PollRepository.getPoll(commentId, response => {
 *   poll = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.Poll}
 *
 * @param pollId the ID of the poll to observe
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the poll
 *
 * @category Poll Live Object
 */
const getPoll = (pollId, callback) => {
    return liveObject(pollId, callback, 'pollId', getPoll$1, [onPollUpdated, onPollDeleted]);
};
/* end_public_function */

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createPoll: createPoll,
  closePoll: closePoll,
  deletePoll: deletePoll,
  votePoll: votePoll,
  onPollUpdated: onPollUpdated,
  onPollDeleted: onPollDeleted,
  getPoll: getPoll
});

const privateKey = "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDHo80SecH7FuF2\nhFYnb+l26/VN8UMLXAQFLnxciNTEwkGVFMpdezlH8rU2HtUJL4RETogbAOLVY0XM\njs6sPn8G1nALmh9qeDpUtVqFOVtBHxEZ910TLOtQiunjqJKO5nWdqZ71EC3OFluR\niGQkO84BiIFbv37ub7xl3S8XarbtKoLcyVpkDHi+1wx1pgCAn6gtBUgckPL5NR8j\nLseabl3HAXQfhTCKo4tmOFM2Dxwl1IUMmIJrJg/aIU/U0tj/1Eoo7mG0JcNWX19l\nW3EecCbi0ncCJOrkUdwlBrcjaMayaX/ubEwyUeTGiLdyc4L3GRLHjyK8xgVNXRMH\nbZWJ2a5NAgMBAAECggEASxuE+35zTFO/XydKgmvIGcWL9FbgMlXb7Vcf0nBoG945\nbiz0NVc2paraIhJXc608xbYF3qLmtAE1MVBI0ORyRdBHNxY024l/6H6SH60Ed+uI\nM4ysp5ourY6Vj+DLwpdRiI9YDjqYAQDIUmhNxJP7XPhOMoZI6st+xZQBM34ic/bv\nAMSJm9OZphSp3+qXVkFZztr2mxD2EZSJJLYxi8BCdgM2qhazalbcJ6zDKHCZWVWm\n8RRxDGldyMb/237JxETzP40tAlzOZDmBAbUgEnurDJ93RVDIE3rbZUshwgeQd18a\nem096mWgvB1AIKYgsTAR3pw+V19YWAjq/glP6fz8wQKBgQD/oQq+ukKF0PRgBeM5\ngeTjSwsdGppQLmf5ndujvoiz/TpdjDEPu6R8kigQr1rG2t4K/yfdZoI8RdmJD1al\n3Q7N9hofooSy4rj6E3txzWZCHJjHad2cnCp/O26HiReGAl7wTcfTmNdiFHhZQzm5\nJBkvWAiwuvQMNfEbnXxw6/vIDwKBgQDH7fX8gsc77JLvAWgp1MaQN/sbqVb6JeT1\nFQfR8E/WFCSmzQBtNzd5KgYuCeelwr/8DyYytvN2BzCYZXp73gI1jF3YlW5jVn74\nOY6TwQ095digwo6Z0yuxopdIOApKgAkL9PRKgNrqAf3NAyMua6lOGifzjDojC3KU\nfylQmxMn4wKBgHp2B9O/H0dEBw5JQ8W0+JX6yWQz7mEjGiR2/1W+XXb8hQ1zr709\nw1r6Gb+EghRpnZ3fBpYGGbYOMFx8wKHM+N6qW3F0ReX8v2juFGE8aRSa5oYBrWzt\nU16Idjbv8hj84cZ1PJmdyvDtpYn9rpWHOZl4rxEbPvbqkIsOMyNVqdT5AoGAOSge\nmwIIU2le2FVeohbibXiToWTYKMuMmURZ5/r72AgKMmWJKbAPe+Q3wBG01/7FRBpQ\noU8Ma0HC8s6QJbliiEyIx9JwrJWd1vkdecBHONrtA4ibm/5zD2WcOllLF+FitLhi\n3qnX6+6F0IaFGFBPJrTzlv0P4dTz/OAdv52V7GECgYEA2TttOKBAqWllgOaZOkql\nLVMJVmgR7s6tLi1+cEP8ZcapV9aRbRzTAKXm4f8AEhtlG9F9kCOvHYCYGi6JaiWJ\nZkHjeex3T+eE6Di6y5Bm/Ift5jtVhJ4jCVwHOKTMej79NPUFTJfv8hCo29haBDv6\nRXFrv+T21KCcw8k3sJeJWWQ=\n-----END PRIVATE KEY-----";
/*
 * The crypto algorithm used for importing key and signing string
 */
const ALGORITHM = {
    name: 'RSASSA-PKCS1-v1_5',
    hash: { name: 'SHA-256' },
};
/*
 * IMPORTANT!
 * If you are recieving key from other platforms use an online tool to convert
 * the PKCS1 to PKCS8. For instance the key from Android SDK is of the format
 * PKCS1.
 *
 * If recieving from the platform, verify if it's already in the expected
 * format. Otherwise the crypto.subtle.importKey will throw a DOMException
 */
const PRIVATE_KEY_SIGNATURE = 'pkcs8';
/*
 * Ensure that the private key in the .env follows this format
 */
const PEM_HEADER = '-----BEGIN PRIVATE KEY-----';
const PEM_FOOTER = '-----END PRIVATE KEY-----';
/*
 * The crypto.subtle.sign function returns an ArrayBuffer whereas the server
 * expects a base64 string. This util helps facilitate that process
 */
function base64FromArrayBuffer(buffer) {
    const uint8Array = new Uint8Array(buffer);
    let binary = '';
    uint8Array.forEach(byte => {
        binary += String.fromCharCode(byte);
    });
    return jsBase64.btoa(binary);
}
/*
 * Convert a string into an ArrayBuffer
 * from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
 *
 * Solely used by the importPrivateKey method
 */
function str2ab(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i += 1) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function importPrivateKey(pem) {
    // fetch the part of the PEM string between header and footer
    const pemContents = pem.substring(PEM_HEADER.length, pem.length - PEM_FOOTER.length);
    /*
     * base64 decode the string to get the binary data
     */
    const binaryDerString = jsBase64.atob(pemContents);
    // convert from a binary string to an ArrayBuffer
    const binaryDer = str2ab(binaryDerString);
    return crypto.subtle.importKey(PRIVATE_KEY_SIGNATURE, binaryDer, ALGORITHM, false, ['sign']);
}
async function createSignature({ timestamp, streams, }) {
    const dataStr = streams
        .map(item => Object.keys(item)
        .sort()
        .map(key => `${key}=${item[key]}`)
        .join('&'))
        .join(';');
    /*
     * nonceStr needs to be unique for each request
     */
    const nonceStr = uuid__default["default"].v4();
    const signStr = `nonceStr=${nonceStr}&timestamp=${timestamp}&data=${dataStr}==`;
    const encoder = new TextEncoder();
    const data = encoder.encode(signStr);
    const key = await importPrivateKey(privateKey);
    const sign = await crypto.subtle.sign(ALGORITHM, key, data);
    return { signature: base64FromArrayBuffer(sign), nonceStr };
}

async function syncUsage({ bufferCurrentUsage, getActiveStreams, updateUsage, dispose, }) {
    const streams = bufferCurrentUsage();
    if (!streams.length)
        return;
    try {
        const timestamp = new Date().toISOString();
        const signatureData = await createSignature({ timestamp, streams });
        if (!signatureData || !signatureData.signature) {
            throw new Error('Signature is undefined');
        }
        const payload = {
            signature: signatureData.signature,
            nonceStr: signatureData.nonceStr,
            timestamp,
            streams,
        };
        const client = getActiveClient();
        await client.http.post('/api/v3/user-event/video-streaming', payload);
        if (!getActiveStreams().length && !bufferCurrentUsage().length) {
            dispose();
        }
        return true;
    }
    catch (err) {
        // push buffer back to usage collector and try again in the next interval
        streams.forEach(stream => updateUsage(stream));
        return false;
    }
}

/*
 * It was originally planned to be 10 seconds but the signature creation is a
 * slow process and can take upto 4 to 5 seconds, which might lead to data
 * inconsitencies and adds complexity to manging sync data.
 *
 * Hence, I've incerased the USAGE_SYNC_INTERVAL to ensure a more maintainable
 * code
 */
const USAGE_SYNC_INTERVAL = 20 * 1000; // 20 seconds;
/**
 * @class
 *
 * Usage Collector is responsible for collecting data from live stream video
 * events and periodically passing the collected data down to Usage Syncer
 *
 */
class UsageCollector {
    constructor() {
        this._unsyncedData = [];
        this._syncBuffer = [];
        this._activeStreams = [];
        this._startInterval();
        this._syncInterval = null;
    }
    registerStream(streamId) {
        this._activeStreams.push(streamId);
    }
    getActiveStreams() {
        return this._activeStreams;
    }
    unregisterStream(streamId) {
        this._activeStreams = this._activeStreams.filter(id => id !== streamId);
    }
    updateUsage(data) {
        this._unsyncedData.push(data);
    }
    /*
     * Buffer of all data that is currently being synced
     * This would help against data loss from new updates while the syncer is
     * attempting to update usage with the server.
     *
     * Also, makes it easier to keep track of synced data for successfull syncs.
     *
     * Without the buffer data integrity would need to be maintained between
     * what's been synced and whats not
     */
    bufferCurrentUsage() {
        const buffer = this._unsyncedData;
        this._unsyncedData = [];
        return buffer;
    }
    dispose() {
        // perform cleanup
        if (this._syncInterval)
            clearInterval(this._syncInterval);
    }
    _startInterval() {
        this._syncInterval = setInterval(() => {
            syncUsage({
                bufferCurrentUsage: this.bufferCurrentUsage.bind(this),
                getActiveStreams: this.getActiveStreams.bind(this),
                updateUsage: this.updateUsage.bind(this),
                dispose: this.dispose.bind(this),
            });
        }, USAGE_SYNC_INTERVAL);
    }
}

let usageCollector = null;
/**
 * Exposes methods to get the usage collector
 *
 * @memberof LiveStreamPlayer
 * @function getUsageCollector
 * @static
 *
 * @return {UsageCollector} usage collector
 *
 * @private
 */
const getUsageCollector = () => {
    if (usageCollector) {
        return usageCollector;
    }
    usageCollector = new UsageCollector();
    return usageCollector;
};

const SECOND = 1000;
/*
 * Usage collection interval is different from usage sync interval. Ideally it
 * needs to be slightly lower than the usage sync interval as it's more likely
 * that the live stream will stop playing than the sync failing
 */
const USAGE_COLLECTION_INTERVAL = 20 * SECOND;
/*
 * Register events and their handlers
 *
 * 3 Types: Play, Pause / Stop, & Unmount
 *  1. Each handler will have access to startTime, which can be an iso string or
 *  null
 *  2. Get the usage collector instance to update usage
 */
class EventRegister {
    constructor(player, resolution) {
        this.player = player;
        this.resolution = resolution;
        this._startTime = null;
        this._usageCollector = getUsageCollector();
        this._usageCollector.registerStream(player.id);
        this._sessionId = String(uuid__default["default"].v4());
        this._controller = new AbortController();
        /*
         * MutationObserver allows for auto removal of all event handlers that are
         * added to register usage
         */
        this._observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.removedNodes.forEach(node => {
                    if (node === player) {
                        this._unregisterEvents();
                    }
                });
            });
        });
    }
    _resetStartTime() {
        this._startTime = Date.now();
    }
    _shouldUpdateCollector() {
        /*
         * a null value on startTime indicates a stream that is not playing
         */
        if (!this._startTime)
            return false;
        if (Date.now() - this._startTime > USAGE_COLLECTION_INTERVAL) {
            return true;
        }
        return false;
    }
    _sendUsageToCollector() {
        if (!this._startTime)
            return;
        const endTime = Date.now();
        const watchMilliseconds = endTime - this._startTime;
        const watchSeconds = Math.round(watchMilliseconds / SECOND);
        /*
         * Quite rare but can happen
         */
        if (!watchSeconds)
            return;
        this._usageCollector.updateUsage({
            streamId: this.player.id,
            sessionId: this._sessionId,
            startTime: this._startTime ? new Date(this._startTime).toISOString() : null,
            endTime: new Date(endTime).toISOString(),
            watchSeconds,
            resolution: this.resolution,
        });
    }
    registerEvents() {
        this.player.addEventListener('play', () => {
            if (!this._startTime) {
                this._resetStartTime();
            }
        }, { signal: this._controller.signal });
        // Playing event is fired after playback is started after being paused
        this.player.addEventListener('playing', () => {
            if (!this._startTime) {
                this._resetStartTime();
            }
        }, { signal: this._controller.signal });
        this.player.addEventListener('timeupdate', () => {
            if (this._shouldUpdateCollector()) {
                this._sendUsageToCollector();
                this._resetStartTime();
            }
        }, { signal: this._controller.signal });
        this.player.addEventListener('pause', () => {
            this._sendUsageToCollector();
            this._startTime = null;
        }, {
            signal: this._controller.signal,
        });
        this.player.addEventListener('ended', () => {
            this._sendUsageToCollector();
            this._startTime = null;
        }, {
            signal: this._controller.signal,
        });
    }
    // perform cleanup when element is removed from DOM
    _unregisterEvents() {
        this._usageCollector.unregisterStream(this.player.id);
        // remove event listeners
        this._controller.abort();
        this._observer.disconnect();
    }
}

/**
 * Returns a live stream video player
 *
 * @memberof LiveStreamPlayer
 * @function getPlayer
 * @static
 *
 * @param {string} parameters.streamId - The ID of the stream.
 * @return {HTMLVideoElement} HTML video element
 *
 */
const getPlayer = async (parameters) => {
    const { streamId } = parameters;
    if (!document) {
        throw new Error('This method can be invoked within the browser enviornment only');
    }
    if (!Hls__default["default"].isSupported()) {
        throw new Error('This browswer does not support hls, unable to play stream');
    }
    // don't catch error let it throw
    const { data: stream } = await getStream(streamId);
    // if live recordings might be null, need to verify
    const { watcherUrl, status, recordings = [], resolution } = stream;
    if (!watcherUrl.hls) {
        throw new Error('This stream does not support hls. Unable to play');
    }
    const video = document.createElement('video');
    video.id = streamId;
    video.controls = true;
    const hls = new Hls__default["default"]();
    hls.attachMedia(video);
    // usage should not be calculated for recorded video
    if (status !== 'recorded') {
        let { url } = watcherUrl.hls;
        /*
         * Fixes mixed content error
         */
        url = url.replace('http:', 'https:');
        hls.loadSource(url);
    }
    else {
        const recording = recordings.find(rec => !!rec.mp4);
        if (!recording || !recording.mp4) {
            throw new Error('No playable recording available');
        }
        video.src = recording.mp4.url;
    }
    new EventRegister(video, resolution).registerEvents();
    return video;
};

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getPlayer: getPlayer
});

const convertStoryPayloadToRaw = (payload) => {
    var _a;
    const client = getActiveClient();
    const now = new Date();
    const expiresAt = now.getTime() + YEAR;
    const expiresAtDate = new Date(expiresAt).toISOString();
    let storyTarget = (_a = pullFromCache([
        "storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */,
        'get',
        payload.targetId,
    ])) === null || _a === void 0 ? void 0 : _a.data;
    if (!storyTarget) {
        // Save mock story target to cache
        storyTarget = {
            targetType: payload.targetType,
            targetId: payload.targetId,
            lastStoryExpiresAt: expiresAtDate,
            targetPublicId: payload.targetId,
            targetUpdatedAt: now.toISOString(),
        };
        ingestInCache({ storyTargets: [storyTarget] });
    }
    return {
        stories: [
            Object.assign({ createdAt: now.toISOString(), updatedAt: now.toISOString(), flagCount: 0, hashFlag: null, reactions: {}, reactionsCount: 0, storyId: payload.referenceId, path: '', creatorId: client.userId || '', creatorPublicId: client.userId || '', targetPublicId: payload.targetId, comments: [], commentsCount: 0, isDeleted: false, hasFlaggedComment: false, mentionedUsers: [], impression: 0, reach: 0, expiresAt: new Date(expiresAt).toISOString() }, payload),
        ],
        categories: [],
        communityUsers: [],
        comments: [],
        files: [],
        users: [],
        communities: [],
    };
};

const saveOptimisticToCache = (payload) => {
    const optimisticData = convertStoryPayloadToRaw(payload);
    ingestInCache(optimisticData);
    return optimisticData;
};
const createOptimisticEvent = ({ payload, formData = undefined, isVideo = false, }, callback) => {
    if (formData) {
        const files = formData.getAll('files');
        const fileObject = files[0] || undefined;
        if (!fileObject)
            return;
        const fileData = new FileReader();
        fileData.readAsDataURL(fileObject);
        fileData.onload = () => {
            return callback(saveOptimisticToCache(isVideo
                ? Object.assign(Object.assign({}, payload), { data: Object.assign(Object.assign({}, payload.data), { fileId: undefined, videoFileId: { original: undefined }, fileData: fileData === null || fileData === void 0 ? void 0 : fileData.result }) }) : Object.assign(Object.assign({}, payload), { data: Object.assign(Object.assign({}, payload.data), { fileId: undefined, fileData: fileData === null || fileData === void 0 ? void 0 : fileData.result }) })));
        };
    }
    return callback(saveOptimisticToCache(Object.assign(Object.assign({}, payload), { data: Object.assign(Object.assign({}, payload.data), { fileData: null }) })));
};

const createStory = async (payload) => {
    const client = getActiveClient();
    client.log('post/createStory', payload);
    const response = await client.http.post('/api/v4/stories', payload);
    const convertedResponse = convertRawStoryToInternal(response.data);
    if (client.cache)
        ingestInCache(convertedResponse);
    pushToCache(["story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */, payload.targetId], "synced" /* Amity.SyncState.Synced */);
    fireEvent('local.story.created', convertedResponse);
    const cachedAt = client.cache && Date.now();
    return {
        data: convertedResponse.stories.length > 0 ? convertedResponse.stories[0] : undefined,
        cachedAt,
    };
};

const createOptimisticTarget = async ({ targetId, targetType, }) => {
    var _a, _b;
    const targetCache = pullFromCache([
        "storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */,
        'get',
        targetId,
    ]);
    if (!targetCache) {
        let optimisticTarget = {
            targetId,
            targetType,
        };
        if (targetType === 'community') {
            const community = await getCommunity$1(targetId);
            optimisticTarget = Object.assign(Object.assign({}, optimisticTarget), { targetPublicId: community.data.communityId, targetUpdatedAt: (_a = community.data.updatedAt) !== null && _a !== void 0 ? _a : new Date().toISOString() });
        }
        if (targetType === 'user') {
            const user = await getUser$1(targetId);
            optimisticTarget = Object.assign(Object.assign({}, optimisticTarget), { targetPublicId: user.data.userPublicId, targetUpdatedAt: (_b = user.data.updatedAt) !== null && _b !== void 0 ? _b : new Date().toISOString() });
        }
        pushToCache(["storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */, 'get', targetId], optimisticTarget);
    }
};

/**
 * ```js
 * import { StoryRepository } from '@amityco/ts-sdk'
 * StoryRepository.createImageStory('community', 'communityId', formData, metadata, imageDisplayMode, items)
 * ```
 *
 * Create a new image story
 * @param targetType The type of the target
 * @param targetId The id of the target
 * @param formData The form data
 * @param metadata The metadata
 * @param imageDisplayMode The image display mode
 * @param items The story items
 * @returns The created story
 */
const createImageStory = async (targetType, targetId, formData, metadata = {}, imageDisplayMode = 'fit', items = []) => {
    if (!formData.getAll('files').length) {
        throw new Error('The formData object must have a `files` key.');
    }
    let payload = {
        data: {
            text: '',
            fileId: undefined,
            fileData: null,
            imageDisplayMode,
        },
        syncState: "syncing" /* Amity.SyncState.Syncing */,
        referenceId: uuid(),
        dataType: "image" /* Amity.StoryDataType.Image */,
        items,
        targetType,
        targetId,
        metadata,
    };
    const date = new Date();
    pushToCache(["story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */, targetId], "syncing" /* Amity.SyncState.Syncing */);
    // Update local story expires time
    pushToCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, targetId], new Date(date.setFullYear(date.getFullYear() + 1)));
    // Fire optimistic event
    createOptimisticEvent({ payload, formData }, optimisticData => {
        fireEvent('local.story.created', optimisticData);
    });
    try {
        const { data } = await uploadImage(formData);
        // @TODO: Need to implement retrying logic in a future
        if (data.length === 0)
            throw new Error('Failed to upload image');
        const { fileId } = data[0];
        payload = Object.assign(Object.assign({}, payload), { data: Object.assign(Object.assign({}, payload.data), { fileId }) });
        createOptimisticTarget({ targetId, targetType });
        // Fire optimistic event - update fileId
        createOptimisticEvent({ payload, formData }, optimisticData => {
            fireEvent('local.story.created', optimisticData);
        });
        const result = await createStory(payload);
        if (!result.data)
            return result;
        return Object.assign(Object.assign({}, result), { data: LinkedObject.story(result.data) });
    }
    catch (error) {
        pushToCache(["story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */, targetId], "error" /* Amity.SyncState.Error */);
        // Fire optimistic event - failed to upload image
        createOptimisticEvent({ payload: Object.assign(Object.assign({}, payload), { syncState: "error" /* Amity.SyncState.Error */ }), formData }, optimisticData => {
            fireEvent('local.story.error', optimisticData);
        });
        throw error;
    }
};

/**
 * ```js
 * import { StoryRepository } from '@amityco/ts-sdk'
 * StoryRepository.createVideoStory('community', 'communityId', formData, metadata, items)
 * ```
 *
 * Create a new video story
 * @param targetType
 * @param targetId
 * @param formData
 * @param metadata
 * @param items
 */
const createVideoStory = async (targetType, targetId, formData, metadata = {}, items = []) => {
    if (!formData.getAll('files').length)
        throw new Error('The formData object must have a `files` key.');
    let payload = {
        data: {
            text: '',
            fileId: undefined,
            fileData: null,
        },
        syncState: "syncing" /* Amity.SyncState.Syncing */,
        referenceId: uuid(),
        dataType: "video" /* Amity.StoryDataType.Video */,
        items,
        targetType,
        targetId,
        metadata,
    };
    const date = new Date();
    pushToCache(["story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */, targetId], "syncing" /* Amity.SyncState.Syncing */);
    // Update local story expires time
    pushToCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, targetId], new Date(date.setFullYear(date.getFullYear() + 1)));
    createOptimisticTarget({ targetId, targetType });
    // Fire optimistic event
    createOptimisticEvent({ payload, formData, isVideo: true }, optimisticData => {
        fireEvent('local.story.created', optimisticData);
    });
    try {
        const { data } = await uploadVideo(formData, ContentFeedType.STORY);
        // @TODO: Need to implement retrying logic in a future
        if (data.length === 0)
            throw new Error('Failed to upload video');
        const { fileId } = data[0];
        payload = Object.assign(Object.assign({}, payload), { data: Object.assign(Object.assign({}, payload.data), { fileId, videoFileId: { original: fileId } }) });
        // Fire optimistic event - update fileId
        createOptimisticEvent({ payload, formData, isVideo: true }, optimisticData => {
            fireEvent('local.story.created', optimisticData);
        });
        const result = await createStory(payload);
        if (!result.data)
            return result;
        return Object.assign(Object.assign({}, result), { data: LinkedObject.story(result.data) });
    }
    catch (error) {
        pushToCache(["story-sync-state" /* STORY_KEY_CACHE.SYNC_STATE */, targetId], "error" /* Amity.SyncState.Error */);
        // Fire optimistic upload failed
        createOptimisticEvent({ payload: Object.assign(Object.assign({}, payload), { syncState: "error" /* Amity.SyncState.Error */ }), formData, isVideo: true }, optimisticData => {
            fireEvent('local.story.error', optimisticData);
        });
        throw error;
    }
};

const getStoryCache = (storyId) => {
    if (!storyId)
        return { data: undefined, cachedAt: undefined };
    return pullFromCache(['story', 'get', storyId]);
};

const deleteStory = async (storyId, permanent = false) => {
    var _a, _b, _c;
    const client = getActiveClient();
    client.log('story/deleteStory', storyId);
    let cached;
    if (client.cache) {
        cached = getStoryCache(storyId);
        if (cached === null || cached === void 0 ? void 0 : cached.data) {
            const { data } = cached;
            fireEvent('local.story.deleted', {
                categories: [],
                comments: [],
                communities: [],
                communityUsers: [],
                files: [],
                users: [],
                stories: [Object.assign(Object.assign({}, data), { isDeleted: true })],
            });
            /* ------ Unsynced story case ------ */
            if (data.syncState !== "synced" /* Amity.SyncState.Synced */) {
                if (permanent) {
                    dropFromCache(["story" /* STORY_KEY_CACHE.STORY */, 'get', storyId]);
                }
                else {
                    pushToCache(["story" /* STORY_KEY_CACHE.STORY */, 'get', storyId], Object.assign(Object.assign({}, cached.data), { isDeleted: true }));
                }
                const unsyncedStoriesCache = (_a = queryCache([
                    "story" /* STORY_KEY_CACHE.STORY */,
                    'get',
                ])) === null || _a === void 0 ? void 0 : _a.filter(story => story.data.syncState !== "synced" /* Amity.SyncState.Synced */ &&
                    story.data.targetId === data.targetId &&
                    story.data.isDeleted !== true);
                // update localLastStoryExpiresAt to be the last story expires
                if (unsyncedStoriesCache && unsyncedStoriesCache.length > 0) {
                    const lastStoryExpires = unsyncedStoriesCache.reduce((acc, story) => {
                        const expireAt = new Date(story.data.expiresAt || 0);
                        return expireAt > acc ? expireAt : acc;
                    }, new Date(0));
                    pushToCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, cached.data.targetId], lastStoryExpires.toISOString());
                }
                else {
                    // if no unsynced stories, remove last story expires since there is no more story
                    dropFromCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, cached.data.targetId]);
                }
                return true;
            }
            /* ------ Synced story case ------ */
            const targetCache = (_b = pullFromCache([
                "storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */,
                'get',
                data.targetId,
            ])) === null || _b === void 0 ? void 0 : _b.data;
            const syncedStoriesCache = (_c = queryCache([
                "story" /* STORY_KEY_CACHE.STORY */,
                'get',
            ])) === null || _c === void 0 ? void 0 : _c.filter(story => story.data.syncState === "synced" /* Amity.SyncState.Synced */ &&
                story.data.targetId === data.targetId &&
                story.data.isDeleted !== true);
            let lastStoryExpiresAt;
            if (syncedStoriesCache && syncedStoriesCache.length > 0) {
                lastStoryExpiresAt = syncedStoriesCache === null || syncedStoriesCache === void 0 ? void 0 : syncedStoriesCache.reduce((acc, story) => {
                    const expireAt = new Date(story.data.expiresAt || 0);
                    return expireAt > acc ? expireAt : acc;
                }, new Date(0));
            }
            // update lastStoryExpiresAt from lastest synced story
            if (targetCache) {
                pushToCache(["storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */, 'get', data.targetId], Object.assign(Object.assign({}, targetCache), { lastStoryExpiresAt }));
            }
        }
    }
    const response = await client.http.delete(`/api/v4/stories/${storyId}`, {
        params: { permanent },
    });
    return response.data.success;
};

const hardDeleteStory = async (storyId) => {
    const result = await deleteStory(storyId, true);
    return result;
};

const softDeleteStory = async (storyId) => {
    const result = await deleteStory(storyId);
    return result;
};

const onStoryUpdated = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        // Apply the necessary field for story payload
        const convertPayload = convertRawStoryToInternal(payload);
        ingestInCache(convertPayload);
        callback(convertPayload.stories);
    };
    const disposers = [createEventSubscriber(client, 'onStoryUpdated', 'story.updated', filter)];
    return () => {
        disposers.forEach(fn => fn());
    };
};
const onStoryUpdatedLocal = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache(payload);
        callback(payload.stories);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryUpdated', 'local.story.updated', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const onStoryReactionAdded = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const { reactions } = payload, rest = __rest(payload, ["reactions"]);
        const internalStory = convertRawStoryToInternal(rest);
        const convertedPayload = prepareStoryReactionPayloadFormEvent('story.reactionAdded', Object.assign(Object.assign({}, internalStory), { reactions }));
        ingestInCache(convertedPayload);
        callback(convertedPayload.stories);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryReactionAdded', 'story.reactionAdded', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};
const onStoryReactionAddedLocal = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache({ stories: [payload.story] });
        callback([payload.story]);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryReactionAdded', 'local.story.reactionAdded', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const onStoryReactionRemoved = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const { reactions } = payload, rest = __rest(payload, ["reactions"]);
        const internalStory = convertRawStoryToInternal(rest);
        const convertedPayload = prepareStoryReactionPayloadFormEvent('story.reactionRemoved', Object.assign(Object.assign({}, internalStory), { reactions }));
        ingestInCache(convertedPayload);
        callback(convertedPayload.stories);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryReactionRemoved', 'story.reactionRemoved', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};
const onStoryReactionRemovedLocal = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache({ stories: [payload.story] });
        callback([payload.story]);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryReactionRemoved', 'local.story.reactionRemoved', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const updateLocalLastStoryExpires = (stories) => {
    stories.forEach(story => {
        const currentCache = pullFromCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, story.targetId]);
        const currentExpireAt = new Date(story.expiresAt || 0);
        const localExpireAt = new Date((currentCache === null || currentCache === void 0 ? void 0 : currentCache.data) || 0);
        if (currentExpireAt < localExpireAt)
            return;
        pushToCache(["story-expire" /* STORY_KEY_CACHE.EXPIRE */, story.targetId], currentExpireAt.toISOString());
    });
};

const mappingStoryIdToReferenceId = (stories) => {
    stories.forEach(story => {
        pushToCache(["story-reference" /* STORY_KEY_CACHE.STORY_ID_TO_REFERENCE_ID */, story.storyId], story.referenceId);
    });
};

const getActiveStoriesByTarget$1 = async ({ targetType, targetId, options, }) => {
    const client = getActiveClient();
    client.log('story/getActiveStoriesByTarget');
    const cachedAt = client.cache && Date.now();
    const response = await client.http.get('/api/v4/stories', {
        params: {
            targetType,
            targetId,
            options: {
                sortBy: (options === null || options === void 0 ? void 0 : options.sortBy) || 'createdAt',
                orderBy: (options === null || options === void 0 ? void 0 : options.orderBy) || 'desc',
            },
        },
    });
    const convertedData = convertRawStoryToInternal(response.data);
    if (client.cache) {
        ingestInCache(convertedData);
        // Update local last story expires
        updateLocalLastStoryExpires(convertedData.stories);
        // Map storyId to referenceId
        mappingStoryIdToReferenceId(convertedData.stories);
    }
    return {
        data: convertedData.stories,
        cachedAt,
        paging: { next: undefined, previous: undefined }, // Disable pagination for this API
    };
};

const onStoryCreated = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        // Apply the necessary field for story payload
        const convertPayload = convertRawStoryToInternal(payload, true);
        ingestInCache(convertPayload);
        callback(convertPayload.stories);
    };
    const disposers = [createEventSubscriber(client, 'onStoryCreated', 'story.created', filter)];
    return () => {
        disposers.forEach(fn => fn());
    };
};
const onStoryCreatedLocal = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache(payload);
        callback(payload.stories);
    };
    const disposers = [
        createEventSubscriber(client, 'onStoryCreated', 'local.story.created', filter),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

const onStoryDeleted = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        const convertPayload = convertRawStoryToInternal(payload);
        ingestInCache(convertPayload);
        callback(convertPayload.stories);
    };
    const disposer = [createEventSubscriber(client, 'onStoryDeleted', 'story.deleted', filter)];
    return () => {
        disposer.forEach(fn => fn());
    };
};
const onStoryDeletedLocal = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache(payload);
        callback(payload.stories);
    };
    const disposer = [createEventSubscriber(client, 'onStoryDeleted', 'local.story.deleted', filter)];
    return () => {
        disposer.forEach(fn => fn());
    };
};

const onStoryError = (callback) => {
    const client = getActiveClient();
    const filter = async (payload) => {
        ingestInCache(payload);
        callback(payload.stories);
    };
    return createEventSubscriber(client, 'onStoryError', 'local.story.error', filter);
};

const onStoryLocalDataUpdated = (callback) => {
    const client = getActiveClient();
    const filter = (payload) => {
        callback(payload);
    };
    return createEventSubscriber(client, 'onStoryLocalDataUpdated', 'local.story.reload', filter);
};

/**
 * ```js
 * import { StoryRepository } from '@amityco/js-sdk';
 * let storiesData;
 *
 * const unsubscribe = StoryRepository.getActiveStoriesByTarget({ targetId, targetType }, response => {
 *  storiesData = response.data;
 * });
 *
 * unsubscribe();
 * ```
 *
 * Observe all mutations on a given {@link Amity.Story}
 *
 * @param params for querying stories from a community
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the story
 *
 * @category SubChannel Live Object
 */
const getActiveStoriesByTarget = (params, callback) => {
    const { log, cache } = getActiveClient();
    const disposers = [];
    const cacheKey = ['story-target', 'collection', params];
    const timestamp = Date.now();
    log(`getActiveStoriesByTarget(tmpid: ${timestamp}) > listen`);
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const storySorting = (story) => {
        var _a, _b;
        const sortBy = ((_a = params.options) === null || _a === void 0 ? void 0 : _a.sortBy) || 'createdAt';
        const orderBy = ((_b = params.options) === null || _b === void 0 ? void 0 : _b.orderBy) || 'desc';
        if (story.length === 0)
            return [];
        if (sortBy === 'createdAt') {
            return orderBy === 'asc' ? story.sort(sortByFirstCreated) : story.sort(sortByLastCreated);
        }
        return orderBy === 'asc' ? story.sort(sortByFirstUpdated) : story.sort(sortByLastUpdated);
    };
    const responder = (snapshot) => {
        var _a;
        const stories = snapshot.data
            .map(referenceId => {
            const story = getStoryCache(referenceId);
            if (!(story === null || story === void 0 ? void 0 : story.data))
                return undefined;
            return LinkedObject.story(story.data);
        })
            .filter(Boolean)
            // Remove all deleted stories
            .filter(item => {
            if (!item)
                return false;
            return !item.isDeleted;
        });
        const newStoryList = [];
        if (stories.length > 0) {
            const storiesBySyncState = stories.reduce((acc, story) => {
                if (!story)
                    return acc;
                const { syncState } = story;
                if (!syncState)
                    return acc;
                let currentValue = acc.get(syncState);
                if (!currentValue) {
                    currentValue = [];
                }
                currentValue.push(story);
                acc.set(syncState, currentValue);
                return acc;
            }, new Map());
            if (storiesBySyncState.has("error" /* Amity.SyncState.Error */)) {
                const errorStories = storySorting(storiesBySyncState.get("error" /* Amity.SyncState.Error */) || []);
                newStoryList.push(...errorStories);
            }
            if (storiesBySyncState.has("syncing" /* Amity.SyncState.Syncing */)) {
                const syncingStories = storySorting(storiesBySyncState.get("syncing" /* Amity.SyncState.Syncing */) || []);
                newStoryList.push(...syncingStories);
            }
            if (storiesBySyncState.has("synced" /* Amity.SyncState.Synced */)) {
                const syncedStories = storySorting(storiesBySyncState.get("synced" /* Amity.SyncState.Synced */) || []);
                newStoryList.push(...syncedStories);
            }
        }
        callback({
            onNextPage: () => false,
            data: newStoryList || stories,
            hasNextPage: !!((_a = snapshot.params) === null || _a === void 0 ? void 0 : _a.page),
            loading: snapshot.loading || false,
        });
    };
    const processNewData = (result, event, initial = false, loading = false, error = false) => {
        var _a;
        const cached = pullFromCache(cacheKey);
        const data = {
            loading,
            error,
            params: { page: undefined },
            data: (cached === null || cached === void 0 ? void 0 : cached.data) || [],
        };
        if (result) {
            if (event === "onDelete" /* Amity.StoryActionType.OnDelete */) {
                const deletedIds = result.map(({ referenceId }) => referenceId);
                data.data = data.data.filter(refId => !deletedIds.includes(refId)) || [];
            }
            else {
                data.data = initial
                    ? result.map(getResolver('story'))
                    : [...new Set([...data.data, ...result.map(getResolver('story'))])];
            }
        }
        const unSyncedStories = (_a = queryCache(["story" /* STORY_KEY_CACHE.STORY */, 'get'])) === null || _a === void 0 ? void 0 : _a.filter(story => story.data.targetId === params.targetId &&
            story.data.syncState !== "synced" /* Amity.SyncState.Synced */).map(story => getResolver('story')(story.data));
        if (unSyncedStories && (unSyncedStories === null || unSyncedStories === void 0 ? void 0 : unSyncedStories.length) > 0) {
            unSyncedStories.forEach(referenceId => {
                if (!data.data.includes(referenceId))
                    data.data.push(referenceId);
            });
        }
        pushToCache(cacheKey, data.data);
        responder(data);
    };
    const realtimeRouter = (event) => (story) => {
        processNewData(story, event);
    };
    const reloadData = () => (newData) => {
        const cached = pullFromCache(cacheKey);
        if (!cached)
            return;
        if (newData.referenceIds.length === 0 || (cached === null || cached === void 0 ? void 0 : cached.data.length) === 0)
            return;
        const shouldUpdate = cached === null || cached === void 0 ? void 0 : cached.data.find(referenceId => newData.referenceIds.includes(referenceId));
        if (!shouldUpdate)
            return;
        const data = {
            loading: false,
            error: false,
            params: { page: undefined },
            data: (cached === null || cached === void 0 ? void 0 : cached.data) || [],
        };
        responder(data);
    };
    const onFetch = (initial) => {
        const query = createQuery(getActiveStoriesByTarget$1, params);
        runQuery(query, ({ data: result, error, loading }) => {
            processNewData(result, 'fetch', initial, loading, error);
        });
    };
    onFetch(true);
    disposers.push(onStoryCreated(realtimeRouter("onCreate" /* Amity.StoryActionType.OnCreate */)), onStoryUpdated(realtimeRouter("onUpdate" /* Amity.StoryActionType.OnUpdate */)), onStoryDeleted(realtimeRouter("onDelete" /* Amity.StoryActionType.OnDelete */)), onStoryReactionAdded(realtimeRouter("onReactionAdded" /* Amity.StoryActionType.OnReactionAdded */)), onStoryReactionRemoved(realtimeRouter("onReactionRemoved" /* Amity.StoryActionType.OnReactionRemoved */)), onStoryError(realtimeRouter("onError" /* Amity.StoryActionType.OnError */)), onStoryCreatedLocal(realtimeRouter("onCreate" /* Amity.StoryActionType.OnCreate */)), onStoryUpdatedLocal(realtimeRouter("onUpdate" /* Amity.StoryActionType.OnUpdate */)), onStoryDeletedLocal(realtimeRouter("onDelete" /* Amity.StoryActionType.OnDelete */)), onStoryReactionAddedLocal(realtimeRouter("onReactionAdded" /* Amity.StoryActionType.OnReactionAdded */)), onStoryReactionRemovedLocal(realtimeRouter("onReactionRemoved" /* Amity.StoryActionType.OnReactionRemoved */)), onStoryLocalDataUpdated(reloadData()), () => dropFromCache(cacheKey));
    return () => {
        log(`getActiveStoriesByTarget(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

const getSingleItemFromArray = (func) => (callback) => func((result) => callback(result[0]));
const getStoryByStoryId = (storyId, callback) => {
    return liveObject(storyId, data => {
        if (!(data === null || data === void 0 ? void 0 : data.data)) {
            callback(data);
            return;
        }
        callback(Object.assign(Object.assign({}, data), { data: LinkedObject.story(data.data) }));
    }, 'storyId', getStoryByStoryId$1, [
        getSingleItemFromArray(onStoryUpdated),
        getSingleItemFromArray(onStoryDeleted),
        getSingleItemFromArray(onStoryReactionAdded),
        getSingleItemFromArray(onStoryReactionRemoved),
        getSingleItemFromArray(onStoryError),
        getSingleItemFromArray(onStoryUpdatedLocal),
        getSingleItemFromArray(onStoryDeletedLocal),
        getSingleItemFromArray(onStoryReactionAddedLocal),
        getSingleItemFromArray(onStoryReactionRemovedLocal),
    ]);
};

const getTargetsByTargetIds$1 = async (targets) => {
    const client = getActiveClient();
    client.log('story/getTargetsByTargetIds', targets);
    const response = await client.http.get('/api/v4/stories/seen', {
        params: { targets },
    });
    const { data } = response;
    if (client.cache)
        ingestInCache(response.data);
    return {
        data: data.storyTargets,
        cachedAt: Date.now(),
    };
};

const getTargetById = (params, callback) => {
    return liveObject(
    // @TODO: Now I put @ts-ignore here because I don't know how to fix this, it always say that params is not assignable to `NEVER`
    // @ts-ignore
    params, result => {
        if (!(result === null || result === void 0 ? void 0 : result.data)) {
            callback(result);
            return;
        }
        callback(Object.assign(Object.assign({}, result), { data: LinkedObject.storyTarget(result.data[0]) }));
    }, 'query', param => {
        return getTargetsByTargetIds$1([param]);
    }, []);
};

const getTargetsByTargetIds = (params, callback) => {
    const { log, cache } = getActiveClient();
    const disposers = [];
    const cacheKey = ['storyTargets', 'collection', params];
    const timestamp = Date.now();
    log(`getTargetsByTargetIds(tmpid: ${timestamp}) > listen`);
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const responder = (snapshot) => {
        var _a;
        const storyTargets = snapshot.data
            .map(targetId => {
            const storyTargetCache = pullFromCache([
                'storyTarget',
                'get',
                targetId,
            ]);
            if (!(storyTargetCache === null || storyTargetCache === void 0 ? void 0 : storyTargetCache.data))
                return undefined;
            return LinkedObject.storyTarget(storyTargetCache.data);
        })
            .filter(Boolean);
        callback({
            onNextPage: undefined,
            data: storyTargets,
            hasNextPage: !!((_a = snapshot.params) === null || _a === void 0 ? void 0 : _a.page),
            loading: snapshot.loading || false,
        });
    };
    const processNewData = (result, initial = false, loading = false, error = false) => {
        const cached = pullFromCache(cacheKey);
        const data = {
            loading,
            error,
            params: { page: undefined },
            data: [],
        };
        if (result) {
            data.data = initial
                ? result.map(getResolver('storyTarget'))
                : [...new Set([...((cached === null || cached === void 0 ? void 0 : cached.data) || []), ...result.map(getResolver('storyTarget'))])];
        }
        pushToCache(cacheKey, data.data);
        responder(data);
    };
    const onFetch = (initial) => {
        const query = createQuery(getTargetsByTargetIds$1, params);
        runQuery(query, ({ data: result, error, loading }) => {
            processNewData(result, initial, loading, error);
        });
    };
    onFetch(true);
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getTargetsByTargetIds(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

class StoryQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, paginationController) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.paginationController = paginationController;
    }
    // eslint-disable-next-line class-methods-use-this
    saveToMainDB(response) {
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        const convertedData = convertRawStoryToInternal(response);
        if (client.cache) {
            ingestInCache(convertedData, { cachedAt });
            // Update local last story expires
            updateLocalLastStoryExpires(convertedData.stories);
            // Map storyId to referenceId
            mappingStoryIdToReferenceId(convertedData.stories);
        }
    }
    // eslint-disable-next-line class-methods-use-this
    getStoryReferenceIds(story) {
        if (story === null || story === void 0 ? void 0 : story.referenceId) {
            return story.referenceId;
        }
        return story.storyId;
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.stories.map(this.getStoryReferenceIds),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const stories = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...stories, ...response.stories.map(this.getStoryReferenceIds)])] }));
        }
    }
    reactor(action) {
        return (payload) => {
            var _a;
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            if (!collection)
                return;
            const newReferenceIds = payload.map(({ referenceId }) => referenceId);
            collection.data = [...new Set([...newReferenceIds, ...collection.data])];
            pushToCache(this.cacheKey, collection);
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

class StoryPaginationNoPageController extends PaginationNoPageController {
    async getRequest(queryParams) {
        const { data: queryResponse } = await this.http.get('/api/v4/stories-by-targets', {
            params: Object.assign({}, queryParams),
        });
        return queryResponse;
    }
}

class StoryLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ["story-target-ids" /* STORY_KEY_CACHE.STORY_TARGET_IDS */, 'collection', queryStreamId];
        const paginationController = new StoryPaginationNoPageController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new StoryQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), paginationController);
        this.paginationController = paginationController;
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    persistModel(response) {
        this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    notifyChange({ origin, loading, error }) {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        let data = collection.data
            .map(referenceId => pullFromCache(["story" /* STORY_KEY_CACHE.STORY */, 'get', referenceId]))
            .filter(Boolean)
            .map(internStory => LinkedObject.story(internStory.data));
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        data = this.applyFilter(data);
        this.callback({
            onNextPage: undefined,
            data,
            hasNextPage: false,
            loading,
            error,
        });
    }
    applyFilter(data) {
        var _a, _b;
        const internalStories = data;
        const orderBy = ((_b = (_a = this.query) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.orderBy) || 'desc';
        return orderBy === 'asc'
            ? internalStories.sort(sortByFirstCreated)
            : internalStories.sort(sortByLastCreated);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onStoryCreated, action: "onCreate" /* Amity.StoryActionType.OnCreate */ },
            { fn: onStoryUpdated, action: "onUpdate" /* Amity.StoryActionType.OnUpdate */ },
            { fn: onStoryDeleted, action: "onDelete" /* Amity.StoryActionType.OnDelete */ },
            { fn: onStoryError, action: "onError" /* Amity.StoryActionType.OnError */ },
        ]);
    }
}

const getStoriesByTargetIds = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getStoriesByTargetIds(tmpid: ${timestamp}) > listen`);
    const storyLiveCollection = new StoryLiveCollectionController(params, callback);
    const disposers = storyLiveCollection.startSubscription();
    const cacheKey = storyLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getStoriesByTargetIds(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

const updateLocalList = (cacheKey, targetIds) => {
    var _a, _b;
    const collection = (_a = pullFromCache(cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
    const storyTargets = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
    pushToCache(cacheKey, Object.assign(Object.assign({}, collection), { data: [...new Set([...storyTargets, ...targetIds])] }));
};
class GlobalStoryQueryStreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, paginationController, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.paginationController = paginationController;
        // Fix ESLint, "Expected 'this' to be used by class method"
        this.preparePayload = preparePayload;
    }
    saveToMainDB(response) {
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        // Fix Eslint error for "Expected 'this' to be used by class method"
        const data = this.preparePayload(response);
        if (client.cache) {
            ingestInCache(data, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.storyTargets.map(({ targetId }) => targetId),
            });
        }
        else {
            updateLocalList(this.cacheKey, response.storyTargets.map(({ targetId }) => targetId));
        }
    }
    reactor(actionType) {
        return (payload) => {
            if (actionType === "onCreate" /* Amity.StoryActionType.OnCreate */ &&
                this.query.seenState !== "seen" /* Amity.StorySeenQuery.SEEN */) {
                updateLocalList(this.cacheKey, payload.map(({ targetId }) => targetId));
            }
            this.notifyChange({ origin: "event" /* Amity.LiveDataOrigin.EVENT */, loading: false });
        };
    }
    subscribeRTE(createSubscriber) {
        return createSubscriber.map(subscriber => subscriber.fn(this.reactor(subscriber.action)));
    }
}

const mergeResult = (resultA, resultB) => {
    return {
        categories: resultA.categories.concat(resultB.categories),
        communities: resultA.communities.concat(resultB.communities),
        communityUsers: resultA.communityUsers.concat(resultB.communityUsers),
        files: resultA.files.concat(resultB.files),
        storyTargets: resultA.storyTargets.concat(resultB.storyTargets),
        users: resultA.users.concat(resultB.users),
        paging: resultB.paging,
    };
};
const addFlagLocalFilter = (payload, filter) => {
    return Object.assign(Object.assign({}, payload), { storyTargets: payload.storyTargets.map(item => (Object.assign(Object.assign({}, item), { localFilter: filter }))) || [] });
};
class GlobalStoryPageController extends PaginationController {
    constructor() {
        super(...arguments);
        this.smartFilterState = "unseen" /* Amity.StorySeenQuery.UNSEEN */;
    }
    async getRequest(queryParams, token) {
        var _a;
        // Apply default values for parameters
        const { limit = 10, seenState = "unseen" /* Amity.StorySeenQuery.UNSEEN */ } = queryParams;
        const result = await this.createRequest({
            seenState: seenState === "smart" /* Amity.StorySeenQuery.SMART */ ? this.smartFilterState : seenState,
            limit,
            token,
        });
        // Use Early return to reduce condition complexity
        if ((_a = result.paging) === null || _a === void 0 ? void 0 : _a.next)
            return result;
        if (seenState !== "smart" /* Amity.StorySeenQuery.SMART */)
            return result;
        if (this.smartFilterState === "seen" /* Amity.StorySeenQuery.SEEN */)
            return result;
        this.smartFilterState = "seen" /* Amity.StorySeenQuery.SEEN */;
        const additionalResult = await this.createRequest({
            seenState: this.smartFilterState,
            limit,
        });
        return mergeResult(result, additionalResult);
    }
    async createRequest(params) {
        const { data: queryResponse } = await this.http.get('/api/v5/me/global-story-targets', {
            params,
        });
        return addFlagLocalFilter(queryResponse, params.seenState);
    }
}

class GlobalStoryLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ["story-global-feed" /* STORY_KEY_CACHE.STORY_GLOBAL_FEED */, 'collection', queryStreamId];
        const paginationController = new GlobalStoryPageController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new GlobalStoryQueryStreamController(this.query, this.cacheKey, this.notifyChange.bind(this), paginationController, (data) => {
            const _a = prepareCommunityPayload(Object.assign(Object.assign({}, data), { feeds: [] })), rest = __rest(_a, ["feeds"]);
            return Object.assign(Object.assign({}, data), rest);
        });
        this.paginationController = paginationController;
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    persistModel(response) {
        this.queryStreamController.saveToMainDB(response);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    notifyChange({ origin, loading, error }) {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const targetIds = collection.data;
        const cachedTargets = queryCache(["storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */]);
        if (cachedTargets && (cachedTargets === null || cachedTargets === void 0 ? void 0 : cachedTargets.length) > 0) {
            cachedTargets === null || cachedTargets === void 0 ? void 0 : cachedTargets.forEach(({ key }) => {
                if (!collection.data.includes(key[2]))
                    targetIds.push(key[2]);
            });
        }
        let data = targetIds
            .map(targetId => pullFromCache(["storyTarget" /* STORY_KEY_CACHE.STORY_TARGET */, 'get', targetId]))
            .filter(Boolean)
            .map(storyTarget => LinkedObject.storyTarget(storyTarget.data));
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        data = this.applyFilter(data)
            // exclude story targets with invalid stories
            .filter(({ localSortingDate }) => !!localSortingDate)
            // Remove internal fields
            .map((_a) => {
            var rest = __rest(_a, ["localFilter", "localLastExpires", "localLastSeen", "localSortingDate"]);
            return rest;
        });
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
    applyFilter(data) {
        if (this.query.seenState !== "smart" /* Amity.StorySeenQuery.SMART */) {
            return data
                .filter(({ hasUnseen }) => {
                if (this.query.seenState === "all" /* Amity.StorySeenQuery.ALL */)
                    return true;
                if (this.query.seenState === "seen" /* Amity.StorySeenQuery.SEEN */ && !hasUnseen)
                    return true;
                return this.query.seenState === "unseen" /* Amity.StorySeenQuery.UNSEEN */ && hasUnseen;
            })
                .sort(sortByLocalSortingDate);
        }
        // Smart Filter - Apply local sorting on each list of data
        const result = data.reduce((acc, storyTarget) => {
            if (storyTarget.localFilter === "unseen" /* Amity.StorySeenQuery.UNSEEN */) {
                acc.unseen.push(storyTarget);
            }
            else if (storyTarget.localFilter === "seen" /* Amity.StorySeenQuery.SEEN */) {
                acc.seen.push(storyTarget);
            }
            else {
                acc.unknown.push(storyTarget);
            }
            return acc;
        }, { unseen: [], seen: [], unknown: [] });
        const sortedUnknown = result.unknown.sort(sortByLocalSortingDate) || [];
        const sortedUnseen = result.unseen.sort(sortByLocalSortingDate) || [];
        const sortedSeen = result.seen.sort(sortByLocalSortingDate) || [];
        // Merge all status and remove internal fields
        return sortedUnknown.concat(sortedUnseen, sortedSeen);
    }
    startSubscription() {
        return this.queryStreamController.subscribeRTE([
            { fn: onStoryCreated, action: "onCreate" /* Amity.StoryActionType.OnCreate */ },
            { fn: onStoryUpdated, action: "onUpdate" /* Amity.StoryActionType.OnUpdate */ },
            { fn: onStoryDeleted, action: "onDelete" /* Amity.StoryActionType.OnDelete */ },
            { fn: onStoryCreatedLocal, action: "onCreate" /* Amity.StoryActionType.OnCreate */ },
            { fn: onStoryUpdatedLocal, action: "onUpdate" /* Amity.StoryActionType.OnUpdate */ },
            { fn: onStoryDeletedLocal, action: "onDelete" /* Amity.StoryActionType.OnDelete */ },
            { fn: onStoryError, action: "onError" /* Amity.StoryActionType.OnError */ },
        ]);
    }
}

const getGlobalStoryTargets = (params, callback, config) => {
    const { log, cache, userId } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getGlobalStoryTarget(tmpid: ${timestamp}) > listen`);
    const storyLiveCollection = new GlobalStoryLiveCollectionController(params, callback);
    const disposers = storyLiveCollection.startSubscription();
    const cacheKey = storyLiveCollection.getCacheKey();
    disposers.push(() => {
        dropFromCache(cacheKey);
    });
    return () => {
        log(`getGlobalStoryTarget(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createImageStory: createImageStory,
  createVideoStory: createVideoStory,
  hardDeleteStory: hardDeleteStory,
  softDeleteStory: softDeleteStory,
  getActiveStoriesByTarget: getActiveStoriesByTarget,
  getStoryByStoryId: getStoryByStoryId,
  getTargetById: getTargetById,
  getTargetsByTargetIds: getTargetsByTargetIds,
  getStoriesByTargetIds: getStoriesByTargetIds,
  getGlobalStoryTargets: getGlobalStoryTargets
});

const convertToInternalAd = (ad) => {
    return Object.assign(Object.assign({}, ad), { endAt: ad.endAt ? ad.endAt : null });
};
const convertToInternalAdvertiser = (advertiser) => {
    return Object.assign({}, advertiser);
};
const getNetworkAds = async () => {
    const client = getActiveClient();
    const { data } = await client.http.get('/api/v1/ads/me');
    const internalAds = data.ads.map(convertToInternalAd);
    const internalAdvertisers = data.advertisers.map(convertToInternalAdvertiser);
    ingestInCache({
        ads: internalAds,
        advertisers: internalAdvertisers,
        files: data.files,
    });
    pushToCache(['ad', 'setting'], data.settings);
    return {
        ads: internalAds.map(LinkedObject.ad),
        settings: data.settings,
    };
};

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getNetworkAds: getNetworkAds
});

/**
 * Retrieves accessToken info to use in Beta services
 *
 * @param apiKey for the Http Client instance
 * @param apiRegion endpoint to connect to
 * @param params The token parameters
 * @param params.userId The userId to use to issue a token
 * @param params.displayName The user's displayName
 * @param params.authToken The authentication token - necessary when network option is set to secure
 * @return An accessToken info object for the given userId
 *
 * @category External API
 * @hidden
 */
const createUserToken = async (apiKey, apiRegion, params) => {
    const deviceId = await getDeviceId();
    const deviceInfo = getDeviceInfo();
    const http = createHttpTransport(computeUrl('http', apiRegion));
    const { data } = await http.post('/api/v5/sessions', Object.assign(Object.assign({}, params), { deviceId, deviceInfo: Object.assign(Object.assign({}, deviceInfo), { model: 'token management API on TS-SDK' }) }), { headers: { 'X-API-Key': apiKey } });
    return { accessToken: data.accessToken };
};

/* begin_public_function
  id: notificationTray.getNotificationTraySeen
*/
/**
 * ```js
 * import { notificationTray } from '@amityco/ts-sdk'
 * const notificationTraySeen = await notificationTray.getNotificationTraySeen()
 * ```
 *
 *
 * @returns A page of {@link Amity.NotificationTraySeen} objects
 *
 * @category NotificationTray API
 * @async
 * */
const getNotificationTraySeen$1 = async () => {
    const client = getActiveClient();
    client.log('notificationTray/getNotificationTraySeen', {});
    const { data: payload } = await client.http.get(`api/v1/notification-tray/tray/seen`);
    const cachedAt = client.cache && Date.now();
    if (client.cache) {
        const cacheKey = ['notificationTraySeen', 'get', client.userId];
        pushToCache(cacheKey, {
            userId: client.userId,
            lastTraySeenAt: payload.lastTraySeenAt,
            lastTrayOccuredAt: payload.lastTrayOccurredAt,
        });
    }
    return {
        data: {
            userId: client.userId,
            lastTraySeenAt: payload.lastTraySeenAt,
            lastTrayOccurredAt: payload.lastTrayOccurredAt,
            isSeen: payload.lastTraySeenAt > payload.lastTrayOccurredAt,
        },
        cachedAt,
    };
};
/* end_public_function */
/**
 * ```js
 * import { notificationTray } from '@amityco/ts-sdk'
 * const notificationTraySeen = await notificationTray.getNotificationTraySeen.locally()
 * ```
 *
 * Queries a paginable list of {@link Amity.NotificationTraySeen} objects from cache
 *
 * @returns A page of {@link Amity.NotificationTraySeen} objects
 *
 * @category NotificationTray API
 * @async
 * */
getNotificationTraySeen$1.locally = () => {
    var _a;
    const client = getActiveClient();
    client.log('notificationTray/getNotificationTraySeen.locally', {});
    if (!client.cache)
        return;
    const queryKey = ['notificationTraySeen', 'get'];
    const { data, cachedAt } = (_a = pullFromCache(queryKey)) !== null && _a !== void 0 ? _a : {};
    if (!data)
        return;
    return { data, cachedAt };
};

/**
 * ```js
 * import { onNotificationTraySeenUpdated } from '@amityco/ts-sdk'
 * const dispose = onNotificationTraySeenUpdated(data => {
 *   // ...
 * })
 * ```
 *
 * Fired when an {@link Amity.NotificationTraySeen} has been updated
 *
 * @param callback The function to call when the event was fired
 * @returns an {@link Amity.Unsubscriber} function to stop listening
 *
 * @category NotificationTraySeen Events
 */
const onNotificationTraySeenUpdated = (callback) => {
    const client = getActiveClient();
    const disposers = [
        createEventSubscriber(client, 'onNotificationTraySeenUpdated', 'local.notificationTraySeen.updated', payload => callback(payload)),
    ];
    return () => {
        disposers.forEach(fn => fn());
    };
};

/* begin_public_function
  id: notificationTray.getNotificationTraySeen
*/
/**
 * ```js
 * import { notificationTray } from '@amityco/ts-sdk';
 *
 * let notificationTraySeen;
 *
 * const unsubscribe = getNotificationTraySeen(response => {
 *   notificationTraySeen = response.data;
 * });
 * ```
 *
 * Observe all mutation on a given {@link Amity.NotificationTraySeen}
 *
 * @param callback the function to call when new data are available
 * @returns An {@link Amity.Unsubscriber} function to run when willing to stop observing the message
 *
 * @category NotificationTraySeen Live Object
 */
const getNotificationTraySeen = (callback) => {
    const { userId } = getActiveUser();
    return liveObject(userId, callback, 'userId', getNotificationTraySeen$1, [onNotificationTraySeenUpdated], {
        callbackDataSelector: (data) => {
            let isSeen = true;
            if (data === null || data === void 0 ? void 0 : data.lastTrayOccurredAt) {
                if (!data.lastTraySeenAt) {
                    isSeen = false;
                }
                else {
                    isSeen =
                        convertDateStringToTimestamp(data.lastTraySeenAt) >
                            convertDateStringToTimestamp(data.lastTrayOccurredAt);
                }
            }
            return {
                lastTrayOccurredAt: data === null || data === void 0 ? void 0 : data.lastTrayOccurredAt,
                lastTraySeenAt: data === null || data === void 0 ? void 0 : data.lastTraySeenAt,
                isSeen,
            };
        },
    });
};
/* end_public_function */

/**
 * TODO: handle cache receive cache option, and cache policy
 * TODO: check if querybyIds is supported
 */
class NotificationTrayItemsPaginationController extends PaginationController {
    async getRequest(queryParams, token) {
        const { limit = COLLECTION_DEFAULT_PAGINATION_LIMIT } = queryParams, params = __rest(queryParams, ["limit"]);
        const options = token ? { token } : { limit };
        const { data: queryResponse } = await this.http.get(`/api/v1/notification-tray`, {
            params: Object.assign(Object.assign({}, params), { options }),
        });
        return queryResponse;
    }
}

class NotificationTrayItemsQuerystreamController extends QueryStreamController {
    constructor(query, cacheKey, notifyChange, preparePayload) {
        super(query, cacheKey);
        this.notifyChange = notifyChange;
        this.preparePayload = preparePayload;
    }
    async saveToMainDB(response) {
        const processedPayload = await this.preparePayload(response);
        const client = getActiveClient();
        const cachedAt = client.cache && Date.now();
        if (client.cache) {
            ingestInCache(processedPayload, { cachedAt });
        }
    }
    appendToQueryStream(response, direction, refresh = false) {
        var _a, _b;
        if (refresh) {
            pushToCache(this.cacheKey, {
                data: response.notificationTrayItems.map(getResolver('notificationTrayItem')),
            });
        }
        else {
            const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
            const notifications = (_b = collection === null || collection === void 0 ? void 0 : collection.data) !== null && _b !== void 0 ? _b : [];
            pushToCache(this.cacheKey, Object.assign(Object.assign({}, collection), { data: [
                    ...new Set([
                        ...notifications,
                        ...response.notificationTrayItems.map(getResolver('notificationTrayItem')),
                    ]),
                ] }));
        }
    }
}

const prepareNotificationTrayItemsPayload = (rawPayload) => {
    const users = rawPayload.users.map(convertRawUserToInternalUser);
    return Object.assign(Object.assign({}, rawPayload), { users });
};

class NotificationTrayItemsLiveCollectionController extends LiveCollectionController {
    constructor(query, callback) {
        const queryStreamId = hash__default["default"](query);
        const cacheKey = ['notificationTrayItem', 'collection', queryStreamId];
        const paginationController = new NotificationTrayItemsPaginationController(query);
        super(paginationController, queryStreamId, cacheKey, callback);
        this.query = query;
        this.queryStreamController = new NotificationTrayItemsQuerystreamController(this.query, this.cacheKey, this.notifyChange.bind(this), prepareNotificationTrayItemsPayload);
        this.callback = callback.bind(this);
        this.loadPage({ initial: true });
    }
    setup() {
        var _a;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection) {
            pushToCache(this.cacheKey, {
                data: [],
                params: {},
            });
        }
    }
    async persistModel(queryPayload) {
        await this.queryStreamController.saveToMainDB(queryPayload);
    }
    persistQueryStream({ response, direction, refresh, }) {
        this.queryStreamController.appendToQueryStream(response, direction, refresh);
    }
    // eslint-disable-next-line class-methods-use-this
    startSubscription() {
        return [];
    }
    notifyChange({ origin, loading, error }) {
        var _a, _b;
        const collection = (_a = pullFromCache(this.cacheKey)) === null || _a === void 0 ? void 0 : _a.data;
        if (!collection)
            return;
        const data = ((_b = collection.data
            .map(id => pullFromCache(['notificationTrayItem', 'get', id]))
            .filter(isNonNullable)
            .map(({ data }) => data)) !== null && _b !== void 0 ? _b : []).map(LinkedObject.notificationTray);
        if (!this.shouldNotify(data) && origin === 'event')
            return;
        this.callback({
            onNextPage: () => this.loadPage({ direction: "next" /* Amity.LiveCollectionPageDirection.NEXT */ }),
            data,
            hasNextPage: !!this.paginationController.getNextToken(),
            loading,
            error,
        });
    }
}

/**
 * Get notification tray items for a notification tray page
 *
 * @param params the limit query parameters
 * @param callback the callback to be called when the notification tray items are updated
 * @returns items in the notification tray
 *
 * @category Notification tray items Live Collection
 *
 */
const getNotificationTrayItems = (params, callback, config) => {
    const { log, cache } = getActiveClient();
    if (!cache) {
        console.log(ENABLE_CACHE_MESSAGE);
    }
    const timestamp = Date.now();
    log(`getNotificationTrayItems(tmpid: ${timestamp}) > listen`);
    const notiTrayItemsLiveCollection = new NotificationTrayItemsLiveCollectionController(params, callback);
    const disposers = notiTrayItemsLiveCollection.startSubscription();
    const cacheKey = notiTrayItemsLiveCollection.getCacheKey();
    disposers.push(() => dropFromCache(cacheKey));
    return () => {
        log(`getNotificationTrayItems(tmpid: ${timestamp}) > dispose`);
        disposers.forEach(fn => fn());
    };
};

/* begin_public_function
  id: notificationTrayItem.markSeen
*/
/**
 * ```js
 * import { notificationTray } from '@amityco/ts-sdk'
 * const updated = await notificationTray.markItemsSeen()
 * ```
 *
 * Updates an {@link Amity.NotificationItemSeen}
 *
 * @param trayItems[] that include id and lastTraySeenAt, The ID of the {@link Amity.NotificationItemSeen} to edit
 * @returns the updated {@link Amity.NotificationItemSeen} object
 *
 * @category NotificationItemSeen API
 * @async
 */
const markItemsSeen = async (trayItems) => {
    const client = getActiveClient();
    client.log('notificationTray/markItemsSeen', {});
    const { data: payload } = await client.http.post(`api/v1/notification-tray/items/seen`, {
        trayItems: trayItems.map(item => ({
            id: item.id,
            lastSeenAt: item.lastSeenAt,
        })),
    });
    const updatedData = payload.trayItems
        .map(patchItem => {
        var _a;
        const cacheData = (_a = pullFromCache([
            'notificationTrayItem',
            'get',
            patchItem.id,
        ])) === null || _a === void 0 ? void 0 : _a.data;
        if (!cacheData)
            return;
        const data = Object.assign(Object.assign({}, cacheData), { lastSeenAt: patchItem.lastSeenAt });
        if (client.cache) {
            const cachedAt = Date.now();
            pushToCache(['notificationTrayItem', 'get'], data, { cachedAt });
        }
        return data;
    })
        .filter(Boolean);
    fireEvent('local.notificationTrayItem.updated', { notificationTrayItems: updatedData });
};
/* end_public_function */

/* begin_public_function
  id: notificationTray.markSeen
*/
/**
 * ```js
 * import { notificationTray } from '@amityco/ts-sdk'
 * const updated = await notificationTray.markTraySeen({
 *   lastSeenAt: Amity.timestamp,
 * })
 * ```
 *
 * Updates an {@link Amity.NotificationTraySeen}
 *
 * @param userId The ID of the {@link Amity.NotificationTraySeen} to edit
 * @param lastSeenAt The patch data to apply
 * @returns the updated {@link Amity.NotificationTraySeen} object
 *
 * @category Post API
 * @async
 */
const markTraySeen = async (lastSeenAt) => {
    var _a;
    const client = getActiveClient();
    client.log('notificationTray/markTraySeen', {});
    const { data: payload } = await client.http.post(`api/v1/notification-tray/tray/seen`, {
        lastSeenAt,
    });
    const cacheData = (_a = pullFromCache([
        'notificationTraySeen',
        'get',
    ])) === null || _a === void 0 ? void 0 : _a.data;
    const data = {
        userId: client.userId,
        lastTraySeenAt: payload.lastSeenAt,
    };
    const updateCacheData = Object.assign(Object.assign({}, cacheData), data);
    const cachedAt = client.cache && Date.now();
    if (client.cache)
        pushToCache(['notificationTraySeen', 'get', client.userId], updateCacheData, { cachedAt });
    fireEvent('local.notificationTraySeen.updated', data);
    return {
        data: payload,
        cachedAt,
    };
};
/* end_public_function */

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getNotificationTraySeen: getNotificationTraySeen,
  getNotificationTrayItems: getNotificationTrayItems,
  markItemsSeen: markItemsSeen,
  markTraySeen: markTraySeen,
  onNotificationTraySeenUpdated: onNotificationTraySeenUpdated
});

exports.API_REGIONS = API_REGIONS;
exports.AdRepository = index$1;
exports.CategoryRepository = index$9;
exports.ChannelRepository = index$d;
exports.Client = index$m;
exports.CommentRepository = index$7;
exports.CommunityPostSettingMaps = CommunityPostSettingMaps;
exports.CommunityPostSettings = CommunityPostSettings;
exports.CommunityRepository = index$a;
exports.ContentFeedType = ContentFeedType;
exports.DefaultCommunityPostSetting = DefaultCommunityPostSetting;
exports.FeedRepository = index$8;
exports.FileRepository = index$j;
exports.FileType = FileType;
exports.LiveStreamPlayer = index$3;
exports.MessageContentType = MessageContentType;
exports.MessageRepository = index$h;
exports.PollRepository = index$4;
exports.PostContentType = PostContentType;
exports.PostRepository = index$6;
exports.ReactionRepository = index$i;
exports.StoryRepository = index$2;
exports.StreamRepository = index$5;
exports.SubChannelRepository = index$g;
exports.UserRepository = index$k;
exports.VERSION = VERSION;
exports.VideoResolution = VideoResolution;
exports.VideoSize = VideoSize;
exports.VideoTranscodingStatus = VideoTranscodingStatus;
exports.backupCache = backupCache;
exports.createQuery = createQuery;
exports.createReport = createReport;
exports.createUserToken = createUserToken;
exports.deleteReport = deleteReport;
exports.disableCache = disableCache;
exports.dropFromCache = dropFromCache;
exports.enableCache = enableCache;
exports.filterByChannelMembership = filterByChannelMembership;
exports.filterByCommunityMembership = filterByCommunityMembership;
exports.filterByFeedType = filterByFeedType;
exports.filterByPostDataTypes = filterByPostDataTypes;
exports.filterByPropEquality = filterByPropEquality;
exports.filterByPropInclusion = filterByPropInclusion;
exports.filterByPropIntersection = filterByPropIntersection;
exports.filterBySearchTerm = filterBySearchTerm;
exports.filterByStringComparePartially = filterByStringComparePartially;
exports.getChannelTopic = getChannelTopic;
exports.getCommentTopic = getCommentTopic;
exports.getCommunityStoriesTopic = getCommunityStoriesTopic;
exports.getCommunityTopic = getCommunityTopic;
exports.getLiveStreamTopic = getLiveStreamTopic;
exports.getMarkedMessageTopic = getMarkedMessageTopic;
exports.getMarkerUserFeedTopic = getMarkerUserFeedTopic;
exports.getMessageTopic = getMessageTopic;
exports.getMyFollowersTopic = getMyFollowersTopic;
exports.getMyFollowingsTopic = getMyFollowingsTopic;
exports.getNetworkTopic = getNetworkTopic;
exports.getPostTopic = getPostTopic;
exports.getRole = getRole;
exports.getSmartFeedChannelTopic = getSmartFeedChannelTopic;
exports.getSmartFeedMessageTopic = getSmartFeedMessageTopic;
exports.getSmartFeedSubChannelTopic = getSmartFeedSubChannelTopic;
exports.getStoryTopic = getStoryTopic;
exports.getSubChannelTopic = getSubChannelTopic;
exports.getUserTopic = getUserTopic;
exports.isAfterBefore = isAfterBefore;
exports.isAfterBeforeRaw = isAfterBeforeRaw;
exports.isCachable = isCachable;
exports.isFetcher = isFetcher;
exports.isFresh = isFresh;
exports.isLocal = isLocal;
exports.isMutator = isMutator;
exports.isOffline = isOffline;
exports.isPaged = isPaged;
exports.isReportedByMe = isReportedByMe;
exports.isSkip = isSkip;
exports.mergeInCache = mergeInCache;
exports.notificationTray = index;
exports.onChannelMarkerFetched = onChannelMarkerFetched;
exports.onFeedMarkerFetched = onFeedMarkerFetched;
exports.onFeedMarkerUpdated = onFeedMarkerUpdated;
exports.onMessageMarked = onMessageMarked;
exports.onMessageMarkerFetched = onMessageMarkerFetched;
exports.onSubChannelMarkerFetched = onSubChannelMarkerFetched;
exports.onSubChannelMarkerUpdated = onSubChannelMarkerUpdated;
exports.onUserMarkerFetched = onUserMarkerFetched;
exports.onUserMarkerFetchedLegacy = onUserMarkerFetchedLegacy;
exports.pullFromCache = pullFromCache;
exports.pushToCache = pushToCache;
exports.queryCache = queryCache;
exports.queryOptions = queryOptions;
exports.queryRoles = queryRoles;
exports.restoreCache = restoreCache;
exports.runQuery = runQuery;
exports.sortByChannelSegment = sortByChannelSegment;
exports.sortByDisplayName = sortByDisplayName;
exports.sortByFirstCreated = sortByFirstCreated;
exports.sortByFirstUpdated = sortByFirstUpdated;
exports.sortByLastActivity = sortByLastActivity;
exports.sortByLastCreated = sortByLastCreated;
exports.sortByLastUpdated = sortByLastUpdated;
exports.sortByLocalSortingDate = sortByLocalSortingDate;
exports.sortByName = sortByName;
exports.sortBySegmentNumber = sortBySegmentNumber;
exports.subscribeTopic = subscribeTopic;
exports.toPage = toPage;
exports.toPageRaw = toPageRaw;
exports.toToken = toToken;
exports.upsertInCache = upsertInCache;
exports.wipeCache = wipeCache;
